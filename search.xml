<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式生成ID的几种方式]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%9F%E6%88%90ID%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为什么要用分布式什么是分布式ID拿MySQL数据库举个例子：在业务数据量不大的时候，单库单表完全可以支撑现有业务，数据量再大点可以弄MySQL主从同步读写分离来对付。但是随着数据日渐增长，主从也扛不住了，就需要对数据库进行分库分表，但分库分表需要有一个唯一ID来标识一条数据，数据库的自增ID显然是不能满足需求；特别一点的如订单、优惠券也都需要唯一ID作为标识。此时一个能够生成全局唯一ID的系统是非常必要的。那这个全局唯一ID就叫做分布式ID 分布式ID需要满足哪些条件 全局唯一：必须保证ID是全局唯一的 高性能：高可用低延迟，ID生成相应快，否则会成为业务瓶颈 高可用：需要无线接近于100%的可用性 好接入：要秉承拿来即用的原则 趋势递增：最好趋势递增，这个要求就看具体业务场景，不严格要求 分布式ID都有哪些生成方式下面有9种： UUID 数据库自增ID 数据库多主模式 号段模式 Redis 雪花算法（SnowFlake） 滴滴出品（TinyID） 百度（Uidgenerator） 美团（Leaf） 几种分布式生成ID的优缺点基于UUID在Java的世界里，想要得到一个具有唯一性的ID，首先想到的就是UUID，UUID是全球唯一的特性。UUID也是可以做分布式ID的，但是不推荐1234public static void main(String args[])&#123; String uuid = UUID.randomUUID().toString.replaceAll("-",""); System.out.print(uuid);&#125; UUID的生成简单到只有一行代码，但是UUID缺并不适用于实际的业务需求，像作为订单号UUID这样的字符串没有丝毫意义，看不出订单的相关信息；而对于数据库来说作为业务主键ID，不仅太长还是字符串，存储性能差，查询也很好使，所以不推荐作为分布式ID优点 生成足够简单，本地生成无网络小号，具有唯一性缺点 无序的字符串，不具备趋势自增特性 没有具体的业务含义 长度过长，对数据性能消耗过大，MySQL官方明确建议主键应该尽量越短越好，作为数据库主键UUID的无序性会导致数据位置频繁变动，影响性能基于数据库自增ID基于数据库的auto_increment自增ID完全可以充当分布式ID，具体实现需要一个单独的MySQL实例来完成，建表结构如下123456CREATE DATABASE 'SEQ_ID';CREATE TABLE `sequence_id` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `value` char(10) NOT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8; 当我们需要一个ID的时候，向表中插入一条记录返回主键ID，但是这种方式由一个致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐 优点 实现简单，ID单调自增，数据类型查询速度快缺点 DB单点存在宕机风险，无法抗住高并发场景 基于数据库集群模式前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一些主节点挂点没法用，那就做双主模式集群，也就是两个MySQL实例都能单独生成自增ID。那这样还会有个问题，两个MySQL实例的自增ID都是从1开始，会生成重复的ID怎么办解决方案设置起始值和自增步长 MySQL_1配置： 12set @@auto_increment_offset = 1; -- 起始值set @@auto_increment_increment = 2; -- 步长 MySQL_2配置： 12set @@auto_increment_offset = 2; -- 起始值set @@auto_increment_increment = 2; -- 步长 水平扩展的数据库集群，有利于解决数据库单点的压力问题，同时为了ID生成特性，将自增步长按照机器数量来设置。增加第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长，把第三台的ID其实生成位置设置为比现有自增ID的位置远一些，但必须在前两台MySQL实例ID还没有增长到第三台实例的其实ID值的时候，否则会出现ID重复，必要时还需要停机修改优点 解决DB单点问题缺点不利于后续扩容，而且实际上单个数据库自身压力还是大，已久无法满足高并发场景 基于数据库的号段模式号段模式是当下分布式ID生成器的主流实现方式之一，号段可以理解为从数据库批量的获取自增ID，每次从数据库去除一个号段范围，例如(0,1000]代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下12345678CREATE TABLE `id_generator` ( `id` int(10) NOT NULL, `max_id` bigint(20) NOT NULL COMMENT '当前最大id', `step` int(20) NOT NULL COMMENT '号段的步长', `biz_type` int(20) NOT NULL COMMENT '业务类型', `version` int(20) NOT NULL COMMENT '版本号', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; biz_type:代表不同业务类型max_id：当前最大的可用idstep:代表号段的长度version:是一个乐观锁，每次都更新version，保证并发数据的正确性|id|biz_type|max_id|step|version||-|-|-|-|-||1|101|1000|2000|0|等这批号段ID用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id = max_id+step,update 成功后则说明新号段获取成功，新的号段范围是(max_id,max_id+step]1update id_generator set max_id = #&#123;max_id+step&#125;, version = version + 1 where version = # &#123;version&#125; and biz_type = XXX 由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖与数据库，不会频繁的访问数据库，对数据库的压力小很多 基于Redis模式Redis也同样可以实现，原理就是利用Redis的incr命令实现ID的原子性自增1234127.0.0.1:6379&gt; set seq_id 1 // 初始化自增ID为1OK127.0.0.1:6379&gt; incr seq_id // 增加1，并返回递增后的数值(integer) 2 用Redis实现需要注意一点，要考虑redis的持久化的问题。redis有两种持久化方式分别是RDB和AOF RDB会定时打一个快照进行持久化，加入持续自增但Redis没及时持久化，而这会Redis挂掉了，重启Redis会出现ID重复的情况 AOF会对每条写命令都进行持久化，即使Redis挂掉了也不会出现重复ID的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长 基于雪花算法（Snowflake）模式雪花算法（Snowflake）介绍雪花酸防是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器Snowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。Snowflake ID组成结构：正数位（占1比特）+时间戳（占41比特）+机器ID（占5比特）+数据中心（占5比特）+自增值（占12比特），共64比特组成的一个Long类型 第一个bit（1bit）：Java中long类的最高位是代表正负，正数是0，附属是1，一般生成ID都是正数，所以默认为0 时间戳部分（41bit）：毫秒级时间，不建议存当前时间戳，而是用（当前时间戳-固定开始时间戳）的差值，可以是产生的ID从更小的值开始；41位的时间可以使用69年，（1L&lt;&lt;41）/(1000L606024365) = 69年，解析下： 12^41/(1000*365*24*60*60)=69 工作机器id(10bit):也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以 序列号部分（12bit），自增值支持统一毫秒内同一个节点可以生成4096个ID根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器ID即可，而不需要单独去搭建分布式ID的应用 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL * * https://github.com/beyondfengyu/SnowFlake */public class SnowFlakeShortUrl &#123; /** * 起始的时间戳 */ private final static long START_TIMESTAMP = 1480166465631L; /** * 每一部分占用的位数 */ private final static long SEQUENCE_BIT = 12; //序列号占用的位数 private final static long MACHINE_BIT = 5; //机器标识占用的位数 private final static long DATA_CENTER_BIT = 5; //数据中心占用的位数 /** * 每一部分的最大值 */ private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT); private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT); private final static long MAX_DATA_CENTER_NUM = -1L ^ (-1L &lt;&lt; DATA_CENTER_BIT); /** * 每一部分向左的位移 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; private final static long DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; private final static long TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT; private long dataCenterId; //数据中心 private long machineId; //机器标识 private long sequence = 0L; //序列号 private long lastTimeStamp = -1L; //上一次时间戳 private long getNextMill() &#123; long mill = getNewTimeStamp(); while (mill &lt;= lastTimeStamp) &#123; mill = getNewTimeStamp(); &#125; return mill; &#125; private long getNewTimeStamp() &#123; return System.currentTimeMillis(); &#125; /** * 根据指定的数据中心ID和机器标志ID生成指定的序列号 * * @param dataCenterId 数据中心ID * @param machineId 机器标志ID */ public SnowFlakeShortUrl(long dataCenterId, long machineId) &#123; if (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; 0) &#123; throw new IllegalArgumentException("DtaCenterId can't be greater than MAX_DATA_CENTER_NUM or less than 0！"); &#125; if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123; throw new IllegalArgumentException("MachineId can't be greater than MAX_MACHINE_NUM or less than 0！"); &#125; this.dataCenterId = dataCenterId; this.machineId = machineId; &#125; /** * 产生下一个ID * * @return */ public synchronized long nextId() &#123; long currTimeStamp = getNewTimeStamp(); if (currTimeStamp &lt; lastTimeStamp) &#123; throw new RuntimeException("Clock moved backwards. Refusing to generate id"); &#125; if (currTimeStamp == lastTimeStamp) &#123; //相同毫秒内，序列号自增 sequence = (sequence + 1) &amp; MAX_SEQUENCE; //同一毫秒的序列数已经达到最大 if (sequence == 0L) &#123; currTimeStamp = getNextMill(); &#125; &#125; else &#123; //不同毫秒内，序列号置为0 sequence = 0L; &#125; lastTimeStamp = currTimeStamp; return (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT //时间戳部分 | dataCenterId &lt;&lt; DATA_CENTER_LEFT //数据中心部分 | machineId &lt;&lt; MACHINE_LEFT //机器标识部分 | sequence; //序列号部分 &#125; public static void main(String[] args) &#123; SnowFlakeShortUrl snowFlake = new SnowFlakeShortUrl(2, 3); for (int i = 0; i &lt; (1 &lt;&lt; 4); i++) &#123; //10进制 System.out.println(snowFlake.nextId()); &#125; &#125;&#125; 百度（uid-generator）uid-generator是一个由百度技术开发，Github地址为https://github.com/baidu/uid-generatoruid-generator是基于SnowFlake算法实现的，与原始snowflake算法不同在于，uid-id_generator支持自定义时间戳、工作ID和序列号等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略uid-generator需要与数据库配合使用，需要新增一个WORKER_NODE表，当应用启动时会想数据库中插入一条数据，插入后返回的自增ID就是该机器的workId数据由host和port组成 对于uid-generator ID组成结构workId，占用22个bit，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId 美团（Leaf）Leaf是由美团开发，Github地址https://github.com/Meituan-Dianping/LeafLeaf同时支持号段模式和snowflake算法模式，可以切换使用 号段模式首先导入源码https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf，再新建一张表leaf_alloc12345678910DROP TABLE IF EXISTS `leaf_alloc`;CREATE TABLE `leaf_alloc` ( `biz_tag` varchar(128) NOT NULL DEFAULT '' COMMENT '业务key', `max_id` bigint(20) NOT NULL DEFAULT '1' COMMENT '当前已经分配了的最大id', `step` int(11) NOT NULL COMMENT '初始步长，也是动态调整的最小步长', `description` varchar(256) DEFAULT NULL COMMENT '业务key的描述', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '数据库维护的更新时间', PRIMARY KEY (`biz_tag`)) ENGINE=InnoDB; 然后在项目中启动号段模式，配置对应的数据库信息，并关闭snowflake模式123456789leaf.name=com.sankuai.leaf.opensource.testleaf.segment.enable=trueleaf.jdbc.url=jdbc:mysql://localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8leaf.jdbc.username=rootleaf.jdbc.password=rootleaf.snowflake.enable=false#leaf.snowflake.zk.address=#leaf.snowflake.port= 启动leaf-server 模块的 LeafServerApplication项目就跑起来了号段模式获取分布式自增ID的测试url ：http：//localhost：8080/api/segment/get/leaf-segment-test监控号段模式：http://localhost:8080/cache snowflake模式Leaf的snowflake模式依赖于ZooKeeper，不同于原始snowflake算法也主要是在workId的生成上，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。123leaf.snowflake.enable=trueleaf.snowflake.zk.address=127.0.0.1leaf.snowflake.port=2181 snowflake模式获取分布式自增ID的测试url:http://localhost:8080/api/snowflake/get/test 滴滴（Tinyid）Tinyid由滴滴开发，Github地址https://github.com/didi/tinyidTinyid是基于号段模式原理实现的与Leaf如出一辙，每个服务获取一个较短(1000,2000],(2000,3000],(3000,4000] Tinyid提供http和tinyid-client两种方式接入 HTTP 方式接入 导入源码 1git clone https://github.com/didi/tinyid 创建数据表 1234567891011121314151617181920212223242526272829303132333435363738394041CREATE TABLE `tiny_id_info` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键', `biz_type` varchar(63) NOT NULL DEFAULT '' COMMENT '业务类型，唯一', `begin_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同', `max_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '当前最大id', `step` int(11) DEFAULT '0' COMMENT '步长', `delta` int(11) NOT NULL DEFAULT '1' COMMENT '每次id增量', `remainder` int(11) NOT NULL DEFAULT '0' COMMENT '余数', `create_time` timestamp NOT NULL DEFAULT '2010-01-01 00:00:00' COMMENT '创建时间', `update_time` timestamp NOT NULL DEFAULT '2010-01-01 00:00:00' COMMENT '更新时间', `version` bigint(20) NOT NULL DEFAULT '0' COMMENT '版本号', PRIMARY KEY (`id`), UNIQUE KEY `uniq_biz_type` (`biz_type`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT 'id信息表';CREATE TABLE `tiny_id_token` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `token` varchar(255) NOT NULL DEFAULT '' COMMENT 'token', `biz_type` varchar(63) NOT NULL DEFAULT '' COMMENT '此token可访问的业务类型标识', `remark` varchar(255) NOT NULL DEFAULT '' COMMENT '备注', `create_time` timestamp NOT NULL DEFAULT '2010-01-01 00:00:00' COMMENT '创建时间', `update_time` timestamp NOT NULL DEFAULT '2010-01-01 00:00:00' COMMENT '更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT 'token信息表';INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)VALUES (1, 'test', 1, 1, 100000, 1, 0, '2018-07-21 23:52:58', '2018-07-22 23:19:27', 1);INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)VALUES (2, 'test_odd', 1, 1, 100000, 2, 1, '2018-07-21 23:52:58', '2018-07-23 00:39:24', 3);INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)VALUES (1, '0f673adf80504e2eaa552f5d791b644c', 'test', '1', '2017-12-14 16:36:46', '2017-12-14 16:36:48');INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)VALUES (2, '0f673adf80504e2eaa552f5d791b644c', 'test_odd', '1', '2017-12-14 16:36:46', '2017-12-14 16:36:48'); 配置数据库 12345datasource.tinyid.names=primarydatasource.tinyid.primary.driver-class-name=com.mysql.jdbc.Driverdatasource.tinyid.primary.url=jdbc:mysql://ip:port/databaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8datasource.tinyid.primary.username=rootdatasource.tinyid.primary.password=123456 启动tinyid-server后测试 123456获取分布式自增ID: http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&apos;返回结果: 3批量获取分布式自增ID:http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=10&apos;返回结果: 4,5,6,7,8,9,10,11,12,13 Java客户端方式接入 重复HTTP中的2和3步骤 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;/groupId&gt; &lt;artifactId&gt;tinyid-client&lt;/artifactId&gt; &lt;version&gt;$&#123;tinyid.version&#125;&lt;/version&gt;&lt;/dependency&gt; 12tinyid.server =localhost:9999tinyid.token =0f673adf80504e2eaa552f5d791b644c test 、tinyid.token是在数据库表中预先插入的数据，test 是具体业务类型，tinyid.token表示可访问的业务类型12345// 获取单个分布式自增IDLong id = TinyId . nextId( " test " );// 按需批量分布式自增IDList&lt; Long &gt; ids = TinyId . nextId( " test " , 10 );]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Session、Token、OAuth2解析]]></title>
    <url>%2F2020%2F02%2F23%2FCookie%E3%80%81Session%E3%80%81Token%E3%80%81OAuth2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[认证（Authentication）和授权（Authorization） 认证（Authentication）：登录，也就是你是谁，验证你身份的凭据，例如用户名和密码，通过这个凭据，系统能够知道你是谁，也就是说系统存在你这个用户，所以Authentication被称为身份/用户验证 授权（Authorization）：权限，也就是你能够干什么，其发生在Authentication之后，长官你访问的权限，比如有些特定资源只能具有特定权限的人才能够访问，有些系统资源操作比如删除、添加、更新只有特定的人才能具有 CookieCookie是什么，有什么作用Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。Cookie：Cookies是某些网站为了辨别客户身份二存储在用户本地终端上的数据（通常是加密过的）。简单来说，Cookie存放在客户端，一般用来保存用户信息。 应用场景首先要知道HTTP是无状态的，意思是HTTP协议对交互场景没有记忆能力，简单来说就是很多人请求html资源文件时，每次请求，每个人的请求，返回的内容都是一样的，返回的都是相同的内容，也就是HTTP协议没法记录你是你这块的信息，没法区分你和别人的信息，就像你购物的时候，应该是你登陆账号显示的是你的订单的数据，别人登录显示别人的订单数据，但是HTTP协议无法是你还是别人 在Cookie中保存已经登陆过的用户信息，下次访问网站的时候页面可以自动帮你登陆的一些基本信息给填了。除此之外，Cookie还能保存用户的首选项，主题和其他设置信息 使用Cookie保存session或者token，向后端发送请求的时候带上Cookie，这样后端就能够取到session或者token了。这样就能够记录用户当前的状态了 Cookie还可以用来记录和分析用户的行为。举个简单的例子，你在网站上购物的时候，因为HTTP协议无状态，如果服务器想要获取你在某个网页的停留状态或者看哪些商品，一种常用的方式就是将这些信息存放在Cookie中，当你再打开APP或者继续刷新产品列表的时候可以根据Cookie中存储的信息给你进行产品的推荐或者后台进行相应的数据分析，你停留的时间长了，说不定你对产品的关注度就高，有想买的想法，从而对你的推荐进行优化，推荐你经常停留的产品 服务端使用Cookie服务端设置Cookie返回客户端 常规设置方法1234567891011@GetMapping("/change-username")public String setCookie(HttpServletResponse response) &#123; // 创建一个 cookie Cookie cookie = new Cookie("username", "Jovan"); //设置 cookie过期时间 cookie.setMaxAge(7 * 24 * 60 * 60); // expires in 7 days //添加到 response 中 response.addCookie(cookie); return "Username is changed!";&#125; 读取客户端传上来的Cookie的值 使用Spring注解@CookieValue获取指定Cookie的值 1234@GetMapping("/getSpecifiedCookie")public String getSpecifiedCookie(@CookieValue(value="username",defaultValue="tempUsername") String username)&#123; return "Hey! Your Cookie save your Name is "+username;&#125; 读取所有的Cookie的值 123456789@GetMapping("/getAllCookies")public String getAllCookies(HttpServletRequest request)&#123; Cookie[] cookies = request.getCookies(); if(cookies != null)&#123; return Arrays.stream(cookies).map(c-&gt;c.getName()+"="+c.getValue()).collect(Collectors.joining(",")) &#125;else&#123; return "No Cookie" &#125;&#125; Cookie和Session的区别Session的主要作用就是利用服务端记录用户的状态。典型的场景就是购物车，当你添加商品到购物车的时候，系统不知道是哪个用户操作的。服务端给特定的用户创建特定的Session之后就可以标识这个用户并且将商品添加到你的购物车中。 Cookie数据保存在客户端（浏览器），Session数据保存在服务端。相对来说Session的安全性更高。如果使用Cookie，一些敏感信息就不要写入Cookie中，最好能将Cookie信息加密后使用，到时候再去服务器端解密 使用Session进行身份验证很多时候我们通过SessionID来识别对应的客户，SessionID一般会存放在Redis中。举个例子：用户成功登陆系统后，然后返回给客户端具有SessionID的Cookie，当用户发起后端请求的时候，会把SessionID带上，这样后端就知道你的身份状态了，下图详解过程：步骤解析： 用户想服务器发送用户名和密码用于登陆系统 服务器验证通过后，服务器为用户创建一个Session，并将Session信息存储起来 服务器向用户返回一个SessionID，写入用户的Cookie 当用户保持登录状态时，Cookie将于每个后续请求一起发送出去 服务器可以将存储在Cookie上的SessionID与存储在内存中或者数据库中的Session信息进行比较，来验证用户的身份，返回用户客户端相应的信息的时候会附带用户当前的登录状态。 TokenToken定义上面我们讨论了使用Session来鉴别用户身份。我们知道Session信息需要保存一份在服务端。这种方式会带来一些麻烦，比如需要我们保存Session信息服务器的可用心、不适用于移动端APP（移动端没有Cookie）等，为了解决这个问题，Token就上场了。JWT（JSON Web Token）就是通过Token实现的用户信息的数据保存，而不保存Session数据了，只要在客户端保存服务端返回给客户的Token就可以了。JWT本质上就是一段签名的JSON格式的数据。由于带有签名，因此接收者就可以验证它的真实性。 JWT的构成： Header：描述JWT的源数据。定义了生成签名的算法及Token的类型 Payload：负载，就是用来存放实际需要传递的数据 Signature：签名，服务器通过Patload、Hreader和一个密钥（secret）使用Header里面指定的签名算法生成，默认算法是HMAC SHA256 在基于Token进行身份验证的应用中，服务器通过Payliad、Header和一个密钥secret创建一个令牌，也就是Token并将Token发送给客户端，客户端将Token保存在Cookie或者localStorage里面，以后客户端发出的请求都会携带这个令牌。你就可以把放在Cookie里面自动发，但是这样是没法跨域的，所以更好的做法是放在HTTP Header的Authorzation字段中：Authorization: Bearer &lt;token&gt; 步骤解析： 用户向服务器发送用户名和密码用于登陆系统 身份验证服务相应返回了签名的JWT，上面包含了用户是谁的内容 用户以后每次想后端发送请求都在Header中带上JWT 服务端检查JWT并从中获取用户相关信息 JWT的几个特点 JWT默认是不加密的，但是也可以加密。生成原始Token以后，可以用密钥再加密一次。 JWT不加密的情况下，不能将秘密数据写入JWT JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数 JWT 最大的缺点是，由于服务器不保存session状态，因此无法在使用过程中废止某个token，或者更改token的权限。也就是说，一旦JWT签发后，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT本身会包含认证信息，一旦泄露，任何人都可以获得该令牌的权限。为了减少盗用，JWT的有效期应该设置的比较短。对于一些比较重要的权限，使用时，应该再次对用户进行认证。 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输 OAuth 2.0什么是OAuth2.0OAuth是一个行业的标准授权协议，主要是来授权第三方应用获取有限的网页权限。实际上他是一种授权机制，他的最终目的是为第三方办法一个有时效性的令牌token，是的第三方能够通过该令牌获取相应的资源。 resource owner:资源所有者，能够允许访问受保护资源的实体 resource server:资源服务器，托管受保护资源的服务器 client：客户端，使用资源所有者的授权代表资源所有者发起对受保护资源的请求的应用程序 authorization server: 授权服务器，能够向客户端颁发令牌 user-agent:用户代理，帮助资源所有者与客户端沟通的工具，一般为web浏览器，移动APP等简单来说：加入想在某个网站上用QQ的账号登录，那这个网站就相当于QQ的客户端。而我们使用浏览器操作，浏览器就是一个用户代理。当从QQ授权服务器获得token后，这个网站是需要请求qq账号信息的，从哪里请求，从QQ的资源服务器上请求 使用场景OAuth2.0比较常用的场景就是三方登录，当你的网站接入第三方登录一般都是使用的OAuth2.0协议，具体的使用方法，可以使用下面这个网站 10 分钟理解什么是 OAuth 2.0 协议]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Session</tag>
        <tag>Cookie</tag>
        <tag>Token</tag>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson中SerializerFeature的用法及中文注解]]></title>
    <url>%2F2020%2F02%2F22%2Ffastjson%E4%B8%ADSerializerFeature%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E4%B8%AD%E6%96%87%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[发现问题今天在给前端写接口的时候，发现了个问题，当从数据库中查数据时，如果数据字段是NULL，就会出现通过JSON.toJSONString转化后的字符串中，字段值为NULL的字段都消失了，这个对于前端来说可算是噩梦，因为他们给页面赋值的时候，会出现字段值为undefined的情况，当然，这个他们也是可以解决的，直接使用this.data.objval = res.data.objval||&#39;&#39;;就能够解决，但是本着方便他人就是方便自己的原则，还是查了下，到底问题出在了哪里 解决问题解决问题的方案，查了下，载使用JSON.toJSONString的时候，它不仅接收需要转化的对象，还会接收一个对象，也就是标题SerializerFeature的一个变量，可以讲待转化对象中的值为null的对象，转化为空字符串，下面是对应的解释内容及使用方法 名称 含义 QuoteFieldNames 输出key时是否使用双引号,默认为true UseSingleQuotes 使用单引号而不是双引号,默认为false WriteMapNullValue 是否输出值为null的字段,默认为false WriteEnumUsingToString Enum输出name()或者original,默认为false UseISO8601DateFormat Date使用ISO8601格式输出，默认为false WriteNullListAsEmpty List字段如果为null,输出为[],而非null WriteNullStringAsEmpty 字符类型字段如果为null,输出为””,而非null WriteNullNumberAsZero 数值字段如果为null,输出为0,而非null WriteNullBooleanAsFalse Boolean字段如果为null,输出为false,而非null SkipTransientField 如果是true，类中的Get方法对应的Field是transient，序列化时将会被忽略。默认为true SortField 按字段名称排序后输出。默认为false WriteTabAsSpecial 把\t做转义输出，默认为false PrettyFormat 结果是否格式化,默认为false WriteClassName 序列化时写入类型信息，默认为false。反序列化是需用到 DisableCircularReferenceDetect 消除对同一对象循环引用的问题，默认为false WriteSlashAsSpecial 对斜杠’/’进行转义 BrowserCompatible 将中文都会序列化为\uXXXX格式，字节数会多一些，但是能兼容IE 6，默认为false WriteDateUseDateFormat 全局修改日期格式,默认为false。JSON.DEFFAULT_DATE_FORMAT = “yyyy-MM-dd”;JSON.toJSONString(obj, SerializerFeature.WriteDateUseDateFormat); DisableCheckSpecialChar 一个对象的字符串属性中如果有特殊字符如双引号，将会在转成json时带有反斜杠转移符。如果不需要转义，可以使用这个属性。默认为false NotWriteRootClassName BeanToArray 将对象转为array输出 WriteNonStringKeyAsString NotWriteDefaultValue BrowserSecure IgnoreNonFieldGetter WriteEnumUsingName 含义 使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182public class SerializerFeatureTest &#123; private static Word word; private static void init() &#123; word = new Word(); word.setA("a"); word.setB(2); word.setC(true); word.setD("d"); word.setE(""); word.setF(null); word.setDate(new Date()); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); User user1 = new User(); user1.setId(1); user1.setOld("11"); user1.setName("用户1"); user1.setAdd("北京"); User user2 = new User(); user2.setId(2); user2.setOld("22"); user2.setName("用户2"); user2.setAdd("上海"); User user3 = new User(); user3.setId(3); user3.setOld("33"); user3.setName("用户3"); user3.setAdd("广州"); list.add(user3); list.add(user2); list.add(null); list.add(user1); word.setList(list); Map&lt;String , Object&gt; map = new HashedMap(); map.put("mapa", "mapa"); map.put("mapo", "mapo"); map.put("mapz", "mapz"); map.put("user1", user1); map.put("user3", user3); map.put("user4", null); map.put("list", list); word.setMap(map); &#125; public static void main(String[] args) &#123; init();// useSingleQuotes();// writeMapNullValue();// useISO8601DateFormat();// writeNullListAsEmpty();// writeNullStringAsEmpty();// sortField();// prettyFormat();// writeDateUseDateFormat();// beanToArray(); showJsonBySelf(); &#125; /** * 9:自定义 * 格式化输出 * 显示值为null的字段 * 将为null的字段值显示为"" * DisableCircularReferenceDetect:消除循环引用 */ private static void showJsonBySelf() &#123; System.out.println(JSON.toJSONString(word)); System.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteNullListAsEmpty)); &#125; /** * 8: * 将对象转为array输出 */ private static void beanToArray() &#123; word.setMap(null); word.setList(null); System.out.println(JSON.toJSONString(word)); System.out.println(JSON.toJSONString(word, SerializerFeature.BeanToArray)); &#125; /** * 7: * WriteDateUseDateFormat:全局修改日期格式,默认为false。 */ private static void writeDateUseDateFormat() &#123; word.setMap(null); word.setList(null); System.out.println(JSON.toJSONString(word)); JSON.DEFFAULT_DATE_FORMAT = "yyyy-MM-dd"; System.out.println(JSON.toJSONString(word, SerializerFeature.WriteDateUseDateFormat)); &#125; /** * 6: * PrettyFormat */ private static void prettyFormat() &#123; word.setMap(null); word.setList(null); System.out.println(JSON.toJSONString(word)); System.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat)); &#125; /** * SortField:按字段名称排序后输出。默认为false * 这里使用的是fastjson：为了更好使用sort field martch优化算法提升parser的性能，fastjson序列化的时候， * 缺省把SerializerFeature.SortField特性打开了。 * 反序列化的时候也缺省把SortFeidFastMatch的选项打开了。 * 这样，如果你用fastjson序列化的文本，输出的结果是按照fieldName排序输出的，parser时也能利用这个顺序进行优化读取。 * 这种情况下，parser能够获得非常好的性能。 */ private static void sortField() &#123; System.out.println(JSON.toJSONString(word)); System.out.println(JSON.toJSONString(word, SerializerFeature.SortField)); &#125; /** * 5: * WriteNullStringAsEmpty:字符类型字段如果为null,输出为"",而非null * 需要配合WriteMapNullValue使用，现将null输出 */ private static void writeNullStringAsEmpty() &#123; word.setE(null); System.out.println(JSONObject.toJSONString(word)); System.out.println("设置WriteMapNullValue后："); System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue)); System.out.println("设置WriteMapNullValue、WriteNullStringAsEmpty后："); System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty)); &#125; /** * 4: * WriteNullListAsEmpty:List字段如果为null,输出为[],而非null * 需要配合WriteMapNullValue使用，现将null输出 */ private static void writeNullListAsEmpty() &#123; word.setList(null); System.out.println(JSONObject.toJSONString(word)); System.out.println("设置WriteNullListAsEmpty后："); System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullListAsEmpty)); &#125; /** * 3: * UseISO8601DateFormat:Date使用ISO8601格式输出，默认为false */ private static void useISO8601DateFormat() &#123; System.out.println(JSONObject.toJSONString(word)); System.out.println("设置UseISO8601DateFormat后："); System.out.println(JSONObject.toJSONString(word, SerializerFeature.UseISO8601DateFormat)); &#125; /** * 2: * WriteMapNullValue:是否输出值为null的字段,默认为false */ private static void writeMapNullValue() &#123; System.out.println(JSONObject.toJSONString(word)); System.out.println("设置WriteMapNullValue后："); System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue)); &#125; /** * 1: * UseSingleQuotes:使用单引号而不是双引号,默认为false */ private static void useSingleQuotes() &#123; System.out.println(JSONObject.toJSONString(word)); System.out.println("设置useSingleQuotes后："); System.out.println(JSONObject.toJSONString(word, SerializerFeature.UseSingleQuotes)); &#125;&#125; 既然上面说到JSON.toJSONString会出现这种问题，那么@Responsebody估计也会出现这种问题吧，没做深究，如果有的话，后期再来补这篇文章吧 本文引自：fastjson SerializerFeature详解]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>fastjson</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uni-app开发技巧备忘录]]></title>
    <url>%2F2020%2F02%2F18%2Funi-app%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[下拉框（picker）开发原因常规下下拉框开发的，后台返回的数据都是下面这种类型的，但是uni-app的数据是类似于这种的array: [&#39;中国&#39;, &#39;美国&#39;, &#39;巴西&#39;, &#39;日本&#39;]，所以使用起来不是很方便，谁TM要保存汉字到数据库，所以下面记录下项目中使用的公共方法1234567891011121314[ &#123; "id": 1, "name": "男" &#125;, &#123; "id": 2, "name": "女" &#125;, &#123; "id": 3, "name": "未知" &#125;] 下拉框技巧下面的这段代码是一个公共下拉框的封装方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;view class="content"&gt; &lt;view class="uni-list"&gt; &lt;view class="uni-list-cell"&gt; &lt;picker @change="pickSelect($event,'sex',data.sexData,'sex')" :value="indexs.sex" :range="data.sexData" range-key="name"&gt; &lt;view class="uni-input"&gt;&#123;&#123;data.sexData[indexs.sex]?data.sexData[indexs.sex].name:'请选择'&#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;button type="primary" @tap="consoleData()"&gt;获取数据&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; indexs: &#123; sex: '' &#125;, data:&#123; sexData: [&#123; "id": 1, "name": "男" &#125;, &#123; "id": 2, "name": "女" &#125;, &#123; "id": 3, "name": "未知" &#125; ], sex:'' &#125; &#125; &#125;, onLoad() &#123; &#125;, methods: &#123; pickSelect(e, indexKey, optionArr, baseInfoKey) &#123; debugger; this.indexs[indexKey] = e.target.value this.data[baseInfoKey] = optionArr[e.target.value].id &#125;, consoleData()&#123; console.log(this.data); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .content &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; &#125; .uni-list-cell-left&#123; width:150rpx; text-align: left; &#125;&lt;/style&gt; 代码解析： indexs是用做一个页面中如果有多个picker的时候，可以在indexs中添加一个变量，当做下拉框索引变量使用，也就是选择的是第几个 pickSelect方法中的四个变量说明：第一个变量是事件，这个就不说了；第二个是1中说的索引的变量名称；第三个是下拉框的数组数据；第四个是data变量中的变量名称 pickSelect方法说明：当下拉框选择发生变化的时候，触发该方法，首先会通过事件获取它选择的是第几个，然后通过设置indexs中的索引值来实现picker中汉字的切换，最后设置data变量中的值，这个地方有个使用json对象的技巧，直接对象名称[变量]就能获取到json中的变量对应变量名的对象 :value属性说明：是1中所说indexs中变量 :range属性说明：是下拉框的数组数据 :range-key属性说明：是下拉框数组数据中对应需要显示在下拉框中的汉字对应的变量名 添加一个button按钮，用于打印表单数据 后端返回数据处理问题及解决方案后端目前给前端扔数据的时候会出现如果字段在数据库中存储的空的时候，直接用JSON转完后，JSON串中就没有这个字段了，因此有两种解决方案: 如果是要查出来的数据转化了一遍字符串之后又扔到前台的（像我们这种内外网分离，外网查数据库得去内网执行以下的这种），可以JSON.toJSONString(custList,SerializerFeature.WRITE_MAP_NULL_FEATURES);，把null的字段转成””，数字转0等等，具体没试过，可以自己尝试下 第二种就是前端进行处理，处理的方法也很简单var objVal = this.data.objVal||’’;也就是当接收到为undefined或者null的时候，直接转成’’了]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>uni-app</category>
      </categories>
      <tags>
        <tag>前端开发框架</tag>
        <tag>uni-app</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局-基础篇]]></title>
    <url>%2F2020%2F02%2F12%2FFlex%E5%B8%83%E5%B1%80-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文引自A Complete Guide to Flexbox 背景 The Flexbox Layout (Flexible Box) module (a W3C Candidate Recommendation as of October 2017) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”).Flex布局是W3C推荐的一种更有效的布局方式，即使他们的大小都是未知的或者动态的，都可以进行合理的布局 The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space or shrinks them to prevent overflow.flex布局的主要思想是使容器能够更改其项目的宽度/高度（和顺序），以最好地填充可用空间（主要是适应各种显示设备和屏幕尺寸），Flex容器会扩展项目以填充可用的可用空间，或收缩它们以防止溢出。（这里的项目个人理解是容器中的对象，以DOM为例，那就是子标签了） Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the Grid layout is intended for larger scale layouts.Flexbox布局最适合应用程序的组件和小规模布局，而Grid布局则用于较大规模的布局 基础和术语这块根据英语翻译过来的，我真是搞不懂，看来英语水平有限啊 flex container:parent element，也就是父级标签 flex items:child element，也就是子标签 main axis(主轴):flex items会沿着flex container的主轴进行布局，但是不一定是水平的，它依赖于flex-direction属性 main-start|main-end:flex items在flex container 中的起始到截止的位置 main-size:flex item的高度和宽度，是flex item的主大小 cross axis（翻译为横轴，但是不理解为啥叫横轴）:垂直于主轴的叫横轴，他的方向依据与主轴的方向 cross-start|cross-end:Flex线填充有物品，并从Flex容器的交叉起点侧开始向交叉端侧放置。 cross-size:flex items的宽度或高度（以横截面尺寸中的较大者为准）为item的横截面尺寸。交叉尺寸属性是交叉尺寸中的“宽度”或“高度”中的任意一个。 属性讲解flex container的属性 display属性这个是定义一个flex container；行模式还是块模式依据与设定的值。它能够为直接的子标签设置flex 布局12345&lt;style&gt;.container&#123; display: flex;/*或者display: inline-flex;*/&#125;&lt;/style&gt; flex-direction1234.container &#123; display: flex; flex-direction: row | row-reverse | column | column-reverse;&#125; 属性值 作用 row(默认) 从左到右横向布局 row-reverse 从右向左横向布局 column 从上到下纵向布局 column-reverse 从下到上纵向布局 flex-wrap默认情况下，flex items会自动尝试在一行中布局，当然你可以通过是否允许换行来控制他1234.container&#123; display: flex; flex-wrap: wrap|nowrap|wrap-reverse;&#125; 属性值 作用 nowrap 不换行 wrap 换行 wrap-reverse 如果总共占两行，先排满二行，然后再排第一行 flex-flowflex-flow是flex-direction和flex-wrap的缩写 1234.container&#123; display: flex; flex-flow: row wrap-reverse;&#125; justify-content定义的是子标签在父标签中主轴上的对齐方式 1234.container&#123; display: flex; justify-content: start;&#125; 属性值 作用 flex-start 主轴上向左对齐 flex-end 主轴上右对齐 center 主轴上居中 space-between 两端对齐，项目之间的间隔相等 space-around 每个子对象都间隔相等，项目之间的间隔比项目与父项目的间隔大一倍 align-items属性定义子标签在交叉轴上的对齐方式12345.container&#123; display: flex; height: 500px; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 属性值 作用 flex-start 交叉轴起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对齐 stretch 如果flex item未设置高度或设置为auto，将沾满整个容器的高度 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用12345.box &#123; display: flex; height: 500px; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性值 作用 flex-start 和交叉轴的起点对齐 flex-end 和交叉轴的终点对齐 center 和交叉轴的中点对齐 space-between 和交叉轴两端对齐，轴线之间的间隔平均分布 space-around 每根轴线两侧的间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍 stretch 轴线沾满整个交叉轴 flex items的属性以下的6个属性是用在item上面的 order flex-grow flex-shrink flex-basis flex align-self orderorder 是定义item的排序顺序的，数值越小，排列越靠前，默认是0 123.item &#123; order:&lt;integer&gt;;&#125; flex-growflex-grow定义item的放大比例，默认是0，即如果存在剩余空间也不放大 123.item&#123; flex-grow:&lt;number&gt;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrinkflex-shrink定义了item的缩小比例，默认为1，即如果空间不足时，该项目将被缩小123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小，因为负值对该属性无效。 flex-basis(这个属性没太弄懂)flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。他默认是auto，即项目的本来大小。123.item&#123; flex-basis:&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个item与其他item不一样的对其方式，可覆盖align-item属性。默认是auto，表示集成父元素的align-item属性，如果没有父元素，则等同于stretch123.item&#123; align-self:auto|flex-start|flex-end|center|baseline|stretch&#125; 实战1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;view style="width: 100%;background-color: #000000;padding: 20px;"&gt; &lt;view class="face box"&gt; &lt;view class="column"&gt; &lt;view class="point item"&gt;&lt;/view&gt; &lt;view class="point item"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="column"&gt; &lt;view class="point item"&gt;&lt;/view&gt; &lt;view class="point item"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;&#125;;&lt;/script&gt;&lt;style&gt;.face &#123; height: 120px; width: 120px; background-color: #ffffff; border: 2px solid #c8c7cc; border-radius: 20px; padding: 5px;&#125;.point &#123; height: 30px; width: 30px; background-color: #000000; border: #8f8f94 2px solid; border-radius: 17px; margin: 3px;&#125;.box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125;.column&#123; display: flex; flex-basis: 100%; justify-content: space-between;&#125;.item &#123;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>Flex</category>
      </categories>
      <tags>
        <tag>Flex</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码大全]]></title>
    <url>%2F2020%2F02%2F09%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[标准扩展码1xx Informational 信息化100 Continue 继续101 Switching Protocols 交换协议102 Processing 处理 2xx Success 成功200 OK201 Created 创建202 Accepted 已接受203 Non-Authoritative Information 非授权信息204 No Content 无内容205 Reset Content 重置内容206 Partial Content 部分内容207 Multi-Status 多状态208 Already Reported 已报告226 IMIM Used 使用的 3xx Redirection 重定向300 Multiple Choices 多种选择301 Moved Permanently 永久移动302 Found 发现303 See Other 查看其它304 Not Modified 未修改305 Use Proxy 使用代理306 Switch Proxy 开关代理307 Temporary Redirect 临时重定向308 Permanent Redirect 永久重定向 4xx Client Error 客户端错误400 Bad Request 错误的请求401 Unauthorized 未授权402 Payment Required 需要付费403Forbidden 拒绝访问404 Not Found 未找到405 Method Not Allowed 不允许的方法406 Not Acceptable 不可接受407 Proxy Authentication Required 代理服务器需要身份验证408 Request Timeout 请求超时409 Conflict 冲突410 Gone 完成411 Length Required 需要长度412 Precondition Failed 前提条件失败413 Payload Too Large 负载过大414 URI Too Long 太长415 Unsupported Media Type 不支持的媒体类型416 Range Not Satisfiable 的范围不合适417 Expectation Failed 预期失败418 I’m a teapot 我是一个茶壶421 Misdirected Request 误导请求422 Unprocessable Entity 无法处理的实体423 Locked 锁定424 Failed Dependency 失败的依赖426 Upgrade Required 升级所需428 Precondition Required 所需的先决条件429 Too Many Requests 太多的请求431 Request Header Fields Too Large 请求头字段太大451 Unavailable For Legal Reasons 不可出于法律原因 5xx Server Error 服务器错误500 Internal Server Error 内部服务器错误501 Not Implemented 未执行502 Bad Gateway 错误的网关503 Service Unavailable 服务不可用504 Gateway Timeout 网关超时505 HTTP Version Not Supported 不支持HTTP版本506 Variant Also Negotiates 变体也进行协商507 Insufficient Storage 存储空间不足508 Loop Detected 检测到循环510 Not Extended 不延长511 Network Authentication Required 网络需要身份验证 非官方扩展码103 Checkpoint 检查点420 Method Failure (Spring Framework) 故障的方法（Spring框架）420 Enhance Your Calm (Twitter) 增强您的平静（微博）450 Blocked by Windows Parental Controls (Microsoft) 被Windows阻止家长控制（微软）498 Invalid Token (Esri) 无效的令牌（ESRI的）499 Token Required (Esri) 令牌必需（ESRI的）499 Request has been forbidden by antivirus 请求已被禁止反病毒509 Bandwidth Limit Exceeded (Apache Web Server/cPanel) 超出带宽限制（Apache的Web服务器/的cPanel）530 Site is frozen 网站被冻结 互联网信息服务扩展状态码440 Login Timeout 登录超时449 Retry With 重新发送带451 Redirect 重定向 NGINX 扩展状态码444 No Response 没有响应495 SSL Certificate Error 证书错误496 SSL Certificate Required证书要求497 HTTP Request Sent to HTTPS Port 发送到HTTPS端口请求499 Client Closed Request 客户端请求关闭]]></content>
      <categories>
        <category>办公知识</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sftp命令上传下载文件]]></title>
    <url>%2F2020%2F02%2F06%2Fsftp%E5%91%BD%E4%BB%A4%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前提是这样的，最近公司的一台内网机上面只有Xshell没有Sftp，所以在上传和下载文件的时候点击了Xshell上的Sftp，发现直接跳转了一个新的bash界面，而且显示的是Sftp+当前的路径，那也就意味着是可以使用命令进行执行的，然后就查了下，果然是有的 发现ssh远程和ftp好像是使用的一个端口，都是22，不知道是自己无知还是真的就是这样的 远程到SFTP 方法1：首先在执行命令之前，得先远程到SFTP服务器上才行，常规下载XShell上，点击绿色文件夹按钮就会弹出提示没有安装XFTP，点击确认后就会自己创建一个新的页卡，页卡就会直接远程到SFTP下面 方法2：点击顶部TAB页卡中的+号按钮，打开一个新的TAB页，然后执行下面的命令（当然命令中的信息需要换成你自己服务器的信息）12345678910111213[E:\~]$ sftp user@ip port# 回车后会弹出输入密码，输入密码后会显示如下信息Host 'xxx.xxxx.xxx' resolved to xxx.xxx.xxx.xxx.Connecting to xxx.xxx.xxx.xxx:xxx...Connection established.To escape to local shell, press 'Ctrl+Alt+]'.Your current local directory isE:\杂七杂八\Xshell\Xshell\SessionsType help to browse available commnands.sftp:/root&gt;# 接下来就能执行SFTP命令了 SFTP命令常用命令 ls:展示远程服务器上的文件列表 lls:展示本机上的文件列表 cd:切换远程服务器上所在的路径 lcd:切换本机上的所在的路径 pwd:展示远程服务器上当前所在的路径 lpwd:展示本机当前所在的路径 put:将本机的文件发送到服务器上 get:将服务器上的文件下载到本机上 quit:退出sftp 使用方法ls展示远程服务器上的文件列表12345678910sftp:/root&gt; lsdrwxr-xr-x 2 root root 4096 Nov 3 2014 .kettle-rw------- 1 root root 44 Jul 17 2014 .lesshstdrwxr-xr-x 2 root root 4096 Nov 23 2015 视频-rw-r--r-- 1 root root 176 Sep 23 2004 .bashrc-rw------- 1 root root 0 Oct 16 17:25 .mysql_history.TMP-rw------- 1 root root 4352 Oct 16 09:42 .mysql_historydrwx------ 2 root root 4096 Mar 18 2019 .gconfd-rw-r--r-- 1 root root 18 May 20 2009 .bash_logout-rw------- 1 root root 69 Dec 15 2016 .rediscli_history lls展示本机上的文件列表12345678sftp:/root&gt; lls02/06/2020 07:01上 &lt;DIR&gt; .02/06/2020 07:01上 &lt;DIR&gt; ..02/02/2020 06:12上 7762 default02/06/2020 06:59上 21 folder.ini02/06/2020 07:00上 &lt;DIR&gt; ITL02/06/2020 07:01上 &lt;DIR&gt; 个人02/02/2020 06:12上 7852 新建会话.xsh cd切换远程服务器上所在的路径12sftp:/root&gt; cd /home/oraclesftp:/home/oracle&gt; lcd切换本机上的所在的路径12sftp:/home/oracle&gt; lcd E:\Local directory is now E:\ pwd展示远程服务器上当前所在的路径12sftp:/home/oracle&gt; pwdRemote directory is /home/oracle lpwd展示本机当前所在的路径12sftp:/home/oracle&gt; lpwdLocal directory is E:\ put将本机的文件发送到服务器上12sftp:/home/oracle&gt; put E:\20200206.tar.gz# 这会将E盘的20200206.tar.gz文件上传到服务器的/home/oracle下 get将服务器上的文件下载到本机上1234sftp:/home/oracle&gt; get 20200206.tar.gzFetching /home/oracle/20200206.tar.gz to 20200206.tar.gz160 KB, 204 KB/sec# 从服务器上将/home/oracle/下的20200206.tar.gz下载到当前window路径下，可以使用lpwd查看当前win的路径 quit退出sftp123456sftp:/root&gt; quitConnection closing...Socket close.Connection closed by foreign host.Disconnected from remote host(xxx.xxx.xxxx:xxxx) at 17:16:42.Type `help' to learn how to use Xshell prompt.[E:\~]$]]></content>
      <categories>
        <category>办公知识</category>
        <category>Sftp</category>
      </categories>
      <tags>
        <tag>SFTP</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestTemplate模拟HTTP-POST请求发送文件]]></title>
    <url>%2F2020%2F01%2F08%2FRestTemplate%E6%A8%A1%E6%8B%9FHTTP-POST%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[今天项目上碰到一个比较不常用的需求，即业务子系统之间通过接口传递文件的功能，起初想到的上传的都是图片，可以直接转Base64字符串，直接通过POST传递过去就可以了，但是本着负责的原则，别后期挖坑，还是又通过其他的方式实现的，方式就是通过RestTemplate的postForEntity方法实现文件的POST请求发送 发送端代码123456789101112131415161718192021222324252627282930313233343536public static String sendRestTempPost(String url, Map&lt;String,Object&gt; paramsMap, MultipartFile file) throws Exception&#123; //创建一个RestTemplate对象 RestTemplate restTemplate =new RestTemplate(); //MultiValueMap里面，用作发送文件 MultiValueMap&lt;String, Object&gt; params = new LinkedMultiValueMap&lt;&gt;(); //1. 首先将字符串等类型的参数放入参数对象中 if (!paramsMap.isEmpty()) &#123; for (Map.Entry&lt;String, Object&gt; entries : paramsMap.entrySet()) &#123; params.add(entries.getKey(), entries.getValue()); &#125; &#125; File tempFile = null; //2.处理文件 if(!file.isEmpty())&#123; String tempFilePath = System.getProperty("java.io.tmpdir") + file.getOriginalFilename(); tempFile = new File(tempFilePath); //生成临时文件 file.transferTo(tempFile); // 文件必须封装成FileSystemResource这个类型后端才能收到附件 FileSystemResource resource = new FileSystemResource(tempFilePath); params.add("file",resource); &#125; // 调用接口即可 ResponseEntity&lt;String&gt; responseStr = restTemplate.postForEntity(url, params, String.class); //如果文件存在的话，进行删除操作 if(tempFile!= null &amp;&amp; tempFile.exists())&#123; tempFile.delete(); &#125; //根据自己需求判断statuscode等相关字段，这里只是简单的实现，所以直接拿了body的内容返回 return responseStr.getBody();&#125; 解析 这里使用MultiValueMap而不是常规Map的原因应该是显而易见的，常规的Map应该是无法满足存放java.io.File类型的文件的能力吧，这里只是猜测 接下来是传递的参数进行了遍历，遍历从调用的方法传递过来的参数，然后组装到MultiValueMap 判断传递过来的文件是不是空的，如果不是空的，进行如下处理 首先创建一个临时文件，当然如果你在当前服务器已经保存过文件，那就更好不过了，直接读取过来，就可以操作了 然后将文件封装成FileSystemResource对象，这个是必须得封装的，不封装的话是没法传递过去的 将文件放入到MultiValueMap中 调用接口进行文件及相关参数的发送操作 最后还需要判断文件不为空的时候的删除操作 阶段总结这个地方发现了一个问题和一个优化的点： 问题是传递过去如果不带header的时候会出现传递的参数汉字会乱码的问题 优化的点是如果一次性发送多个文件的时候，该如何去做处理(这个地方尝试了一下，结果一直报错，后续再试试) 接收端代码1public JSONObject upLoadImg(String _userId,String applid,String doc_code,String file_type,String file_path,String file_id,String file_name,MultipartFile file) 解析接收端相信我写到这里，下面的应该都会吧，能拿到MultipartFile剩下的都不是问题了，直接从文件读取流，根据路径和文件名输出到硬盘路径就可以了 补充下面补充下MultipartFile文件转成流并保存的代码1234567891011121314151617181920212223242526272829303132333435363738/** * @param file //文件对象 * @param filePath //上传路径 * @param fileName //文件名 * @return 文件名 */public static String fileUp(MultipartFile file, String filePath, String fileName)&#123; String extName = ""; // 扩展名格式： try &#123; if (file.getOriginalFilename().lastIndexOf(".") &gt;= 0)&#123; extName = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".")); &#125; copyFile(file.getInputStream(), filePath, fileName+extName).replaceAll("-", ""); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println(e); &#125; return fileName+extName;&#125;/** * 写文件到当前目录的upload目录中 * * @param in * @throws IOException */private static String copyFile(InputStream in, String dir, String realName) throws IOException &#123; File file = new File(dir, realName); if (!file.exists()) &#123; if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; file.createNewFile(); &#125; FileUtils.copyInputStreamToFile(in, file); return realName;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>RestTemplate</category>
      </categories>
      <tags>
        <tag>POST</tag>
        <tag>RestTemplate</tag>
        <tag>HTTP</tag>
        <tag>文件发送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档学Drools（一）]]></title>
    <url>%2F2019%2F12%2F26%2F%E8%B7%9F%E7%9D%80%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6Drools%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言首先介绍一下Drools是个什么东西: Drools is a Business Rules Management System (BRMS) solution. It provides a core Business Rules Engine (BRE), a web authoring and rules management application (Drools Workbench), full runtime support for Decision Model and Notation (DMN) models at Conformance level 3 and an Eclipse IDE plugin for core development 说人话： Drools是一个商业规则引擎系统解决方案。它提供了一个核心商业规则引擎，一个网页认证和规则管理的程序，完全符合级别3的决策模型和注释（DMN）模型的运行时支持，以及用于核心开发的Eclipse IDE插件； 说人话！！！ 简单来说就是一个系统，可以定义一些规则，然后别的系统通过接口或者其他的方式访问这个系统，把数据发给这个系统，这个系统决定这个用户通不通过，或者给予什么建议等等，就是它会帮你给出决策信息，当然前提是得把决策模型创建好才行。 安装准备环境，环境要求如下： JDK1.8 Eclipse IDE（建议Mars版本） 下载Droolsruntime和tools]]></content>
      <categories>
        <category>中间件</category>
        <category>Drools</category>
      </categories>
      <tags>
        <tag>Drools</tag>
        <tag>规则引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock工具-Rap2部署]]></title>
    <url>%2F2019%2F12%2F07%2FMock%E5%B7%A5%E5%85%B7-Rap2%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Mock测试定义Mock是在测试过程中，对于一些不容易构造/获取的对象，创建一个mock对象来模拟对象的行为；用人话或者个人理解来说，就是在前后端分离情况下，或者目标接口暂时没法测试的情况下，可以通过模拟返回数据的形式，进行初步的联调测试 RAP2RAP2简介RAP2 是在 RAP1 基础上重做的新项目，它能给你提供方便的接口文档管理、Mock、导出等功能，包含两个组件(对应两个 Github Repository) RAP2部署Docker、Docker Compose安装可以按照下面的命令进行安装，也可以按照https://get.daocloud.io/进行安装，这个链接有各种关于Docker安装、卸载的相关资料12# 首先安装Docker，适用于Ubuntu，Debian,Centos等大部分Linuxcurl -sSL https://get.daocloud.io/docker | sh 12345# 安装 Docker Composecurl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 设置执行权限chmod +x /usr/local/bin/docker-compose RAP2配置 在/usr/local目录下创建目录rap 下载这个Github项目下的docker-compose.yml文件到rap目录下 Rap 前端服务的端口号默认为 3000，你可以在 docker-compose.yml 中按照注释自定义 在 rap 目录下执行下面的命令： 12345678910111213141516171819202122# 启动Dockersystemctl start docker# 拉取镜像并启动docker-compose up -d# 等待5分钟，服务器性能如果不行的情况下，拉取完镜像，mysql需要一会才能启动成功# 启动后，第一次运行需要手动初始化mysql数据库# ⚠️注意: 只有第一次该这样做docker-compose exec delos node scripts/init# 部署成功后 访问http://localhost:3000 # 前端（可自定义端口号）http://localhost:38080 # 后端# 如果访问不了可能是数据库没有链接上，关闭 rap 服务docker-compose down# 再重新运行docker-compose up -d# 如果 Sequelize 报错可能是数据库表发生了变化，运行下面命令同步docker-compose exec delos node scripts/updateSchema 注意：第一次运行后 rap 目录下会被自动创建一个 docker 目录，里面存有 rap 的数据库数据，可千万不要删除。]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>Mock</category>
      </categories>
      <tags>
        <tag>Mock</tag>
        <tag>API管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 Vue基础-安装]]></title>
    <url>%2F2019%2F10%2F18%2F%E7%AC%AC1%E7%AB%A0-Vue%E5%9F%BA%E7%A1%80-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Vue基础之安装兼容性不支持IE8以下 直接script引入如果下面的下载地址没法下载，可以直接去官网进行下载，官网地址开发版生产版 CDN 学习和制作原型，可以使用最新版本，地址为 生产环境，使用地址为 如果使用原生ESModule ，这里兼容ES Module的构建文件123&lt;script type="module"&gt; import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.esm.browser.js'&lt;/script&gt; NPM在用 Vue 构建大型应用时推荐使用 NPM 安装，NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件12# 最新稳定版$ npm install vue 创建第一个Vue应用监控value值的变化1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var data = &#123;a:1&#125;; var vm = new Vue(&#123; el:'#app', data:data &#125;) //监控a值的变化 vm.$watch('a',function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;) data.a = '123123'; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 生命周期函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'hi vue' &#125;, //实例化初始之后,数据观测(data observer)和event/watcher事件配置之前被调用 beforeCreate:function() &#123; console.log("beforeCreate"); &#125;, //实例创建完成之后立即调用,但是挂载阶段还没开始,$el属性目前不可见 created:function() &#123; console.log("created"); &#125;, //在挂载开始之前被调用:相关渲染函数首次被调用 beforeMount:function() &#123; console.log("beforeMount"); &#125;, //挂载成功,el被创建,vm.$el替换 mounted:function() &#123; console.log("mounted"); &#125;, //数据更新之前调用 beforeUpdate:function() &#123; console.log("beforeUpdate"); &#125;, //组件DOM已经更新,组件更新完毕 updated:function() &#123; console.log("updated"); &#125; &#125;); setTimeout(function() &#123; vm.msg = "changing....." &#125;, 3000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 模板语法插值v-once只赋值一次，后续不可再修改值12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- v-once 只能一次赋值，后续操作将不执行 --&gt; &lt;div id="app" v-once&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'zhangsan' &#125; &#125;) //因为添加了v-once,所以只能赋值一次,这里就不会再进行赋值操作了 vm.$msg = 'hi vue' &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-html输出html标签并渲染1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- v-once 只能一次赋值，后续操作将不执行 --&gt; &lt;div id="app" v-once&gt; &#123;&#123;msg&#125;&#125; &lt;!-- 不使用的情况下是没法显示的 --&gt; &lt;p&gt; Using v-html:&#123;&#123;rawhtml&#125;&#125; &lt;/p&gt; &lt;!-- 使用v-html标签值指向变量，需要将v-html添加在一个标签上 --&gt; &lt;p&gt; Using v-html:&lt;span v-html="rawhtml"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'zhangsan', rawhtml:'&lt;span style="color: #FF0000;"&gt;this is should be red&lt;/span&gt;' &#125; &#125;) //因为添加了v-once,所以只能赋值一次,这里就不会再进行赋值操作了 vm.$msg = 'hi vue' &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 动态绑定元素属性12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 绑定样式 --&gt; &lt;div v-bind:class="color"&gt; test red &lt;!-- 绑定元素的id --&gt; &lt;span v-bind:id="testBindId"&gt;123123&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; //通过绑定的color属性修改元素的样式 color:'red', testBindId:'123123' &#125; &#125;); //通过绑定元素修改对应元素的id属性 vm.$data.testBindId = "updateId" &lt;/script&gt; &lt;style type="text/css"&gt; .red&#123; color: #FF0000; &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; 使用Javascript表达式12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 加法表达式 --&gt; &lt;p&gt;&#123;&#123;number+1&#125;&#125;&lt;/p&gt; &lt;!-- 三元运算符 --&gt; &lt;p&gt;&#123;&#123;ok?hello:bye&#125;&#125;&lt;/p&gt; &lt;!-- 字符串操作：将字符串拆分然后反向排序之后再拼接 --&gt; &lt;p&gt;&#123;&#123;msg.split('').reverse().join('')&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; number:1, msg:'abcedfg', hello:'Hello Vue', bye:'Bye Vue', ok:true &#125; &#125;); setTimeout(function() &#123; vm.$data.ok = false; &#125;, 3000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 模板语法-指令指令是带有v-前缀的特殊特性。指令的特性是值逾期是单个JavaScript表达式。指令的职责是当表达式的值发生改变时，其将产生的连带影响，响应式的作用域DOM123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;p v-if="seen"&gt;现在你能看到我&lt;/p&gt; &lt;!-- 常规情况下，点击click me会触发父级点击，添加click的修饰符stop就会点击完之后不触发父级事件 --&gt; &lt;div @click="click1"&gt; &lt;div @click.stop="click2"&gt; click me &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; seen:false &#125;, methods:&#123; click1:function()&#123; console.log('click1'); &#125;, click2:function()&#123; console.log("click2"); &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; class和style的绑定对象语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 1. active样式是否生效，取决于isActive --&gt; &lt;!-- 2. 动态属性和静态属性可以并存 --&gt; &lt;!-- 3. 可以通过对象添加多样式 --&gt; &lt;div class="test" v-bind:class="&#123;active:isActive,green:isGreen&#125;" style="height: 12.5rem;width: 12.5rem;text-align: center;line-height: 12.5rem;"&gt; hi vue &lt;/div&gt; &lt;br&gt; &lt;!-- 通过数组绑定多样式 --&gt; &lt;div v-bind:class="['active','green']" style="height: 12.5rem;width: 12.5rem;text-align: center;line-height: 12.5rem;"&gt; 通过数组绑定多样式 &lt;/div&gt; &lt;br&gt; &lt;!-- 三元运算动态控制样式 --&gt; &lt;div v-bind:class="[isActive?'active':'',isGreen?'green':'']" style="height: 12.5rem;width: 12.5rem;text-align: center;line-height: 12.5rem;"&gt; 通过数组绑定多样式 &lt;/div&gt; &lt;!-- v-bind:style绑定样式 --&gt; &lt;div :style="&#123;color:color,fontSize:size,background:isRed?'#ff0000':''&#125;"&gt; hi vue &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; isActive:true, isGreen:true, color:'#ffffff', size:'30px', isRed:true &#125; &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; /* 声明样式 */ .active&#123; background-color: #FF0000; &#125; .test&#123; font-size: 30px; &#125; .green&#123; color: #00FF00; &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; 条件渲染1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 通过if else 判断是走哪个 --&gt; &lt;div v-if="type === 'A'"&gt; A &lt;/div&gt; &lt;div v-else-if="type === B"&gt; B &lt;/div&gt; &lt;div v-else-if="type === C"&gt; C &lt;/div&gt; &lt;div v-else&gt; NOT A/B/C &lt;/div&gt; &lt;!-- 使用v-show控制显示 --&gt; &lt;div v-show="isShow"&gt; &lt;p&gt;是否显示&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; type:'A', isShow:true &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 列表渲染1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul id="v-for-object"&gt; &lt;li v-for="item,index in items"&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item.message&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="value,key in objects" :key="key"&gt; &lt;li&gt;&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; items:[ &#123;message:'Foo'&#125;, &#123;message:'Bar'&#125;, ], objects:&#123; title:'How to do lists in Vue', author:'zp', publishedAt:'2019-10-27 09:54:53' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件绑定123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;button v-on:click="cliclkcount += 1"&gt;&#123;&#123;cliclkcount&#125;&#125;&lt;/button&gt; &lt;button type="button" v-on:click="addOnce('abc',$event)"&gt;AddOnce&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; cliclkcount:0, name:'Vue' &#125;, methods:&#123; addOnce:function(str,e)&#123; alert('hi'); alert(this.name); alert(str); console.log(e); this.cliclkcount ++; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 表单输入绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input v-model="message" placeholder="Edit me" /&gt; &lt;p&gt;输入的内容为：&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;textarea v-model="message2" placeholder="Hint me"&gt; &lt;/textarea&gt; &lt;p&gt;输入的内容为：&#123;&#123;message2&#125;&#125;&lt;/p&gt; &lt;div class="mui-input-row mui-radio "&gt; &lt;input v-model="names" type="radio" value="Jone"&gt; &lt;label&gt;Jone&lt;/label&gt; &lt;input v-model="names" type="radio" value="Lily" /&gt; &lt;label&gt;Lily&lt;/label&gt; &lt;/div&gt; &lt;div class="mui-input-row mui-checkbox mui-left"&gt; &lt;input type="checkbox" v-model="sex" value="Man" &gt; &lt;label&gt;Man&lt;/label&gt; &lt;input type="checkbox" v-model="sex" value="Woman" &gt; &lt;label&gt;Woman&lt;/label&gt; &lt;input type="checkbox" v-model="sex" value="UnKnown" &gt; &lt;label&gt;UnKnown&lt;/label&gt; &lt;/div&gt; &lt;button type="button" @click="submit"&gt;Sumbit&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; message:"123123", message2:'测试内容', names:"Lily", sex:['Man','Woman'] &#125;, methods:&#123; submit:function()&#123; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件基础12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;button-container title="title1" @clicknow="clicknow"&gt; &lt;!-- 使用slot插入元素 --&gt; &lt;h1&gt;123123&lt;/h1&gt; &lt;/button-container&gt; &lt;button-container&gt;&lt;/button-container&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; Vue.component('button-container',&#123; //自定义属性 props:['title'], data: function()&#123; return &#123; count:0 &#125; &#125;, template:'&lt;div&gt;&lt;button type="button" v-on:click="clickFun"&gt;&#123;&#123;title&#125;&#125;点击了我&#123;&#123;count&#125;&#125;次&lt;/button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;', methods:&#123; clickFun()&#123; this.count ++; //组件传递参数到外部 this.$emit('clicknow',this.count); &#125; &#125; &#125;) var vm = new Vue(&#123; el:'#app', data:&#123; &#125;, methods:&#123; //自定义事件传出的数据 clicknow:function(e)&#123; console.log(e); &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 组件注册局部组件注册及使用1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 局部组件使用 --&gt; &lt;test&gt;&lt;/test&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:'#app', data:&#123; &#125;, // 局部组件定义 components:&#123; test:&#123; template:'&lt;h2&gt;h2.....&lt;/h2&gt;', &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 单文件组件基础插件安装在使用单文件组件之前，需要先安装以下环境12345//1. 安装npmnpm 全称Node Package Manager，是一个基于Node.js的包管理器，也是整个Node.js社区最流行、支持的第三方模块最多的包管理器npm -v//2. 由于网络原因，需安装cnpm，是npm的中国镜像npm install -g cnpm --registry=https://registry.npm.taobao.org //3. 安装vue-clicnpm install -g @vue/cli // 4. 安装webpack，webpack是Javascript打包器（module bundler）cnpm install -g webpack 使用vue-cli创建项目 使用cmd命令输入vue ui，会自动打开浏览器，并跳转到Vuecli创建项目的界面 选择创建项目，修改项目路径，点击创建 选择默认，继续创建，一段时间后，看所选择的路径下就会创建好项目 12]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle导入导出步骤]]></title>
    <url>%2F2019%2F10%2F18%2FOracle%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[Oracle导入导出步骤导出查看字符集查看下字符集，需要在导出和导入的时候使用123456789101112131415# 切换到oracle用户[oracle@MCDB bin]$ su - oracle# 连接到Oracle数据库[oracle@MCDB bin]$ sqlplus /nologSQL*Plus: Release 11.2.0.4.0 Production on Fri Oct 18 18:18:06 2019Copyright (c) 1982, 2013, Oracle. All rights reserved.# 使用用户登录SQL&gt; conn mgplat/mgplatConnected.SQL&gt; select userenv('language') from dual;USERENV('LANGUAGE')----------------------------------------------------AMERICAN_AMERICA.ZHS16GBK 查看数据库实例用作下面导出命令中的instanceid12345SQL&gt; select name from v$database;NAME---------JNMCDB （重要）设置环境123export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1export ORACLE_SID=JNMCDBexport NLS_LANG=AMERICAN_AMERICA.ZHS16GBK 执行导出命令1[oracle@MCDB bin]$ exp username/password@serverip:serverport/instanceid file=/home/oracle/temp.dmp owner=username 导入创建表空间和用户需要看导出文件中的表空间，常规会创建一个数空间和一个临时表空间1234567891011121314[root@MCDB ~]#su - oracle[oracle@MCDB ~]$ sqlplus /nologSQL*Plus: Release 11.2.0.4.0 Production on Fri Oct 18 16:18:31 2019Copyright (c) 1982, 2013, Oracle. All rights reserved.SQL&gt; conn /as sysdba;Connected.# 创建临时表空间SQL&gt; create temporary tablespace USR_XYD_DATA_TEMP tempfile '/home/oracle/app/oradata/jnmcdb/usr_xyd_data_temp.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;# 创建表空间SQL&gt; create tablespace USR_XYD_DATA logging datafile '/home/oracle/app/oradata/jnmcdb/user_xyd_data.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;# 创建用户（注意换成对应的表空间和临时表空间）SQL&gt; create user XYD identified by xydtech default tablespace USR_XYD_DATA temporary tablespace USR_XYD_DATA_TEMP ;# 赋权限(这里根据实际需求来，为了简单我直接给了DBA)SQL&gt; grant dba to XYD; （重要）设置字符集、ORACLE_HOME、ORACLE_SID上面导出的时候会有对应的字符集，如果只有dmp文件没法连接导出的数据时，可通过下面的命令查看字符集这个命令会输出一个数字，拿着这个数字（这里是0345），放在下面的SQL里面执行下，字符集就出来了，这里的字符集是ZHS16GBK12[root@MCDB oracle]# cat XYD.dmp |od -x|head -1|awk '&#123;print $2 $3&#125;'|cut -c 3-60354 12SQL&gt; select nls_charset_name(to_number('0354','xxxx')) from dual; ZHS16GBK 设置环境123export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1/export ORACLE_SID=JNMCDBexport NLS_LANG=AMERICAN_AMERICA.ZHS16GBK 导入命令1234567891011121314151617[oracle@MCDB ~]$ imp username/password@serverip:serverport/instanceid file=/home/oracle/XYD.dmp full=yImport: Release 11.2.0.4.0 - Production on Fri Oct 18 16:23:34 2019Copyright (c) 1982, 2011, Oracle and/or its affiliates. All rights reserved.Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsExport file created by EXPORT:V11.02.00 via conventional pathimport done in ZHS16GBK character set and AL16UTF16 NCHAR character set. importing XYD's objects into XYD. . importing table "AA" 198 rows imported. . importing table "BANKLOG_BASEINFO" 11 rows imported. . importing table "BANKLOG_FLOWLIST" 280 rows imported. . importing table "BB" 0 rows imported. . importing table "BUSIFL_DOCLIST" 7 rows imported. . importing table "BUSIFL_DOCREG" 14 rows imported. . importing table "BUSIFL_HISTORYTASK" 8 rows imported. . importing table "BUSIFL_INSTANCE" 6 rows imported.....]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>导入导出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo入门知识]]></title>
    <url>%2F2019%2F10%2F17%2Fdubbo%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Dubbo入门知识Dubbo简介 Apache Dubbo |ˈdʌbəʊ| is a high-performance, light weight, java based RPC framework. Dubbo offers three key functionalities, which include interface based remote call, fault tolerance &amp; load balancing, and automatic service registration &amp; discovery. 从上面的描述可以看出Dubbo是一个高性能、轻量化的Java为基础的RPC框架，其能提供基于接口的远程调用，容错、负载均衡以及自动服务注册和发现。从功能上来看是和SpringCloud一样，包含服务注册、订阅、治理等方面的功能。 工作原理解析图 节点说明 Registry：服务注册于发现的注册中心 Consumer：调用远程服务的消费方 Provider：暴露服务的服务提供方 Monitor：统计服务调用次数和调用时间监控中心 Container：服务器运行容器 过程说明 0：服务容器负责启动，加载，运行服务提供者 1：服务提供者在启动时，向注册中心注册自己提供的服务 2：服务消费者在启动时，向注册中心订阅自己所需要的服务 3：注册中心返回服务提供者地址列表给消费者，如有变更，注册中心将基于长链接推送边封数据给消费者 4：服务消费者，从提供者地址列表中，基于软负载均衡酸防，西安一台提供者进行调用，如果调用失败，再选择另一台调用 5：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 简单实践该简单实践是Dubbo官网的Quick start]]></content>
      <categories>
        <category>后端框架</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第17章 分布式开发-Spring Cloud]]></title>
    <url>%2F2019%2F09%2F08%2F%E7%AC%AC17%E7%AB%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91-Spring-Cloud%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[第16章 部署、测试和监控]]></title>
    <url>%2F2019%2F09%2F08%2F%E7%AC%AC16%E7%AB%A0-%E9%83%A8%E7%BD%B2%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[部署和运行部署分为连个步骤，第一步是项目打包（war或者jar），第二步是如何运行项目。运行项目又可分为内嵌服务器和第三方服务器。 打包使用IDEA创建项目时，采用的是war打包方式，二十几上还可以使用jar打包，只是这种创建方式不是主流，毕竟Java当前的开发方向是以Web应用为主。使用war创建项目后，IDE会帮助生成Web应用所需要的目录，例如JSP页面的webapp目录，与此同时还会在Maven的配置文件pom.xml中添加一些内容和，其中需要注意的是其中的打包方式packaging标签中的内容是war。123456&lt;groupId&gt;com.xyd&lt;/groupId&gt;&lt;artifactId&gt;mc&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;name&gt;mc&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt; 在IDEA中，点击Build，选择Build Artifacts..即可编译打包项目，打包完成后会在项目的target目录下生成打包成的war包 运行项目 使用内嵌服务器运行项目运行项目的方式很简单，对于IDE打出来的包，可以直接java -jar命令就可以直接运行，如下命令1java -jar projectname.war 有时候可能希望使用命令指定参数，这也是没有问题的。比方说运行时候发现8080端口被占用了，此时希望使用9080，于是可以把命令修改为1java -jar projectname.war --server.port=9080 这样就可以启用9080端口运行服务器，这里注意项目配置文件中设置的端口也会被这个命令行的参数所覆盖。 使用外部服务器运行项目最常用的中间件服务器是Tomcat，对于部署第三方非内嵌服务器，需要自己初始化Spring MVC的DispatcherServlet，关于这点IDE会帮助我们自动生成，在选择使用war打包项目时，他还会自动生成一个ServletInitializer.java。从名称看，他就是初始化Servlet的，代码如下123456789101112package com.xyd.mc;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(McApplication.class); &#125;&#125; 这里可以看到，他继承可SpringBootServletInitializer，然后实现了configure方法，实现这个方法时为了载入Spring Boot的启动类，依靠这个启动类来读取配置。那么Web容器是如何识别到这SpringBootServletInitializer类的呢。原因是，在Servlet3.1规范之后允许Web容器不通过web.xml配置，只需要实现ServletContainerInitializer接口。在SpringMVC中已经提供了ServletContainerInitializer的实现类SpringServletContainerInitializer，这个实现类会遍历WebApplicationInitializer接口的实现类，加载它所配置的内容。根据以上内容，只需要将生成的war包拷贝到Tomcat的webapps目录下，就可以完成部署 热部署热部署，是在应用正在运行的时候升级软件，缺不需要重启应用。在Spring Boot中热部署也十分简单，通过Maven导入spring-boot-devtools即可，代码清单如下123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 然后重启系统，这样当修改其中的文件时，文件就会自动即时生效。其中配置了optional选项为true，代表别的项目依赖于当前项目，这个热部署不会在该项目上生效。热部署是通过LiveReload进行支持的，所以在日志中会看到下面的内容12019-09-08 11:18:11.872 INFO 18080 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 35729 关于热部署的配置，主要有一下选项12345678910111213141516171819# 是否启用一个livereload.com兼容的服务器spring.devtools.livereload.enabled=true# livereload.com服务器端口spring.devtools.livereload.port=35729# 在原来的基础上新增重启服务的文件夹目录spring.devtools.restart.additional-paths=# 在原来的基础上新增不重启服务的文件夹目录spring.devtools.restart.additional-exclude=# 是否启用自动重启功能spring.devtools.restart.enabled=true# 不重启服务的文件夹配置spring.devtools.restart.exclude=# 设置对路径变化进行检测的时间间隔（毫秒为单位）spring.devtools.restart.poll-interval=1000ms# 在没有改变任何classpath的情况下，在重启被出发前的静默时长(毫秒为单位)spring.devtools.restart.quiet-period=300ms# 设置触发文件，当需要实现触发启动检查时，则需要修改这个文件spring.devtools.restart.trigger-file= 测试在pom文件中引入测试包12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; spring-boot-starter-text会引入JUnit的测试包，这也就是先中使用最多的方案，所以下面基于它进行讨论，在Spring Boot可以支持多种方面的测试，如JPA，MongoDB、Rest风格和Redis等，基于使用原则]]></content>
  </entry>
  <entry>
    <title><![CDATA[第15章 实践一下——抢购商品]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%AC%AC15%E7%AB%A0-%E5%AE%9E%E8%B7%B5%E4%B8%80%E4%B8%8B%E2%80%94%E2%80%94%E6%8A%A2%E8%B4%AD%E5%95%86%E5%93%81%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[第14章 Spring5新框架——WebFlux]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%AC%AC14%E7%AB%A0-Spring5%E6%96%B0%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94WebFlux%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[第13章 学点Spring其他的技术]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%AC%AC13%E7%AB%A0-%E5%AD%A6%E7%82%B9Spring%E5%85%B6%E4%BB%96%E7%9A%84%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[第12章 安全——Spring Security]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%AC%AC12%E7%AB%A0-%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94Spring-Security%2F</url>
    <content type="text"><![CDATA[安全——Spring Security为了保证系统的安全性，Spring提供了安全框架Spring Security，他是一种能够为基于Spring生态圈，提供安全访问控制解决方案的框架。它提供了一组可以在Spring应用上下文中配置的机制，充分的利用了Spring的强大特性，微应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。为了使用Spring Security，需要引入依赖12345&lt;!--Spring Security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 这样工程就能够把Spring Security的依赖包引入进来 概述和简单安全认证在Java项目中一般使用Servlet过滤器（Filter）队请求进行拦截，然后在Filter中通过自己的验证逻辑来决定是否放行请求。同样Spring Security中也是基于这个原理，在进入到DispatcherServlet钱就可以对Spring MVC的请求进行拦截，然后通过一定的验证，从而决定是否放行请求系统。为了对请求进行拦截，Spring Security提供了过滤器DelegatingFilterProxy类给予开发者配置。传统Web工程中，可以使用web.xml进行配置，在Spring Boot中推荐使用注解。在这里只需要引入上面的pom就可以自动启动Spring Secutiry启动项目你会发现在日志的打印内容会包含如下内容122019-08-31 11:39:06.517 INFO 13924 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration :Using generated security password: 7f859ab3-d0e6-4676-9b93-253e7865102c 在文本框中输入用户名（User）为user，密码为日志打印出来的随机密码，然后点击登录（Login）按钮，就可以跳转到请求路径但是上面的情况遇到了很多问题： 每次启动都会造成密码不同，客户需要输入不同的密码，不方便 用户只能使用user，无法多样化，无法构建不同的用户的不同权限 不能自定义验证的方法，毕竟有些企业拥有自己的验证方式和策略 登录页面不能自定义，不美观 不能自定义那些请求需要安全验证，那些请求不需要安全验证下面一步一步的揭开面纱，首先Spring Boot的自动配置机制，允许开发者很快的修改用户名和密码。例如，我们在application.properties文件中加入代码清单所示配置。 123# 自定义用户名和密码spring.security.user.name=rootspring.security.user.password=ceshimima 有了安全配置的属性，即使不加入@EnableWebSecurity，SpringBoot也会根据配置的项自动启动安全机制。只是用户名和密码会修改成上面配置的，而不是生成的随机密码，除了上面的配置外，SpringBoot还支持其他的配置，如下123456789101112# Spring Security过滤器排序spring.security.filter.order=-100# 安全过滤器责任链拦截的分发类型spring.security.filter.dispatcher-types=async,error,request# 用户角色spring.security.user.roles=#Oauth提供者详细配置信息spring.security.oauth2.client.provider.*=##Oauth客户端登记信息spring.security.oauth2.client.registration.*= 以上是Spring Boot关于Spring Security可以配置的选项。在实际工作中，只需要配置少量的内容即可。 使用WebSecurityConfigurerAdapter自定义开发者可以通过集成WebSecurityConfigurer得到默认的安全功能。也可以通过覆盖它提供的方法来自定义自己的安全拦截方案。下面是WebSecurityConfigurerAdapter中默认的3个方法12345678910111213141516/*** 用来配置用户签名服务，主要是user-details机制，你可以给予用户赋予角色* @param auth 签名管理器构造器，用于构建用户具体权限控制* /protected void configure(AuthenticationManagerBuilder auth);/*** 用来配置Filter链* @param web Spring Web Security对象*/public void configure(WebSecurity web);/*** 用来配置拦截保护的请求，比如什么请求放行，什么请求需要验证* @param http http 安全请求对象*/ WebSecurityConfigurerAdapter提供空实现，也没有任何配置。而对于AuthenticationManagerBuilder参数的方法，则是定义用户（user），密码（password）和角色（role），在默认的情况下Spring不互为你创建任何的用户和密码，也就是有登录页面二没有可登录的用户。对于HtppSecurity参数的方法，则是指定用户和角色与对应URL的访问权限，也就是开发者可以通过覆盖这个方法来指定用户或者角色的访问权限。在WebSecurityConfigurerAdapter提供的验证方式下满足通过用户验证或者HTTP基本验证的任何请求，Spring Security都会放行 自定义用户服务信息正如之前所论述的，在WebSecurityConfigurerAdapter中的方法1protected void configure(AuthenticationManagerBuilder auth); 是一个用户配置用户信息的方法，在Spring Security中默认是没有任何用户配置的。而在Spring Boot中，如果没有用户的配置，他将会自动生成一个名为user、密码通过随机生成的用户，密码则可以在日志中观察得到。但是这样就存在各类的弊端，这里先来讨论如何进行自定义用户签名服务。这里主要包含使用内存签名服务、数据库签名服务和自定义签名服务。 使用内存签名服务如标题克制，是将用户的信息存放在内存中。相对而言，他比较简单，适合测试的快速环境搭建，代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.xyd.mc;import com.xyd.mc.interceptor.ApplicationInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.connection.MessageListener;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.listener.ChannelTopic;import org.springframework.data.redis.listener.RedisMessageListenerContainer;import org.springframework.data.redis.listener.Topic;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Repository;import org.springframework.web.servlet.config.annotation.InterceptorRegistration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.annotation.PostConstruct;/** * @Description: * @param: * @return: * @Author: zp * @Date: 2019/8/31 */@SpringBootApplication(scanBasePackages = &#123;"com.xyd.mc"&#125;)@EntityScan(basePackages = "com.xyd.mc.*.*.pojo")@MapperScan( basePackages = "com.xyd.mc.*", sqlSessionTemplateRef = "sqlSessionTemplate", annotationClass = Repository.class)@EnableCachingpublic class McApplication extends WebSecurityConfigurerAdapter implements WebMvcConfigurer &#123;/****************其他代码********************/ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //密码编译器 PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); //使用内存存储 auth.inMemoryAuthentication() //设置密码编译器 .passwordEncoder(passwordEncoder) //注册用户admin，密码为abc，并赋予USER和ADMIN的角色权限 .withUser("admin") //通过passwordEncoder.encode("abc")得到加密后的密码 .password(passwordEncoder.encode("abc")) .roles("USER","ADMIN") //连接方法and .and() //注册用户myuser，密码为123456，并赋予USER的角色权限 .withUser("myuser") .password(passwordEncoder.encode("123456")) .roles("USER"); &#125;&#125; 在Spring5的Security中都要求使用密码编码器，否则会发生异常，所以代码中首先创建一个BCryptPasswordEncoder实例，这个类实现了PasswordEncoder接口，它采用的是单项不可逆的密码加密方式，这里的AuthenticationManagerBuilder是关注的焦点，其中inMeneoryAuthentication方法将返回内存保存用户信息的管理配置前，这样启用内存缓存的机制保护用户信息。首先通过passwordEncoder方法，设置了密码编码器，这里的withUser方法是注册用户名称，返回用户详细构造器（UserDetailsBuilder）对象，这样就能够去配置用户的信息了；password方法是设置密码，采用的BCrypt加密方式加密后的密码字符串，于是用户登录就需要这个密码；roles方法赋予角色类型，将来就可以通过这个角色名称赋权限。知识这个role方法还有内涵，他实际是另外一个方法的简写，这个方法是authorities，使用它可以注册角色名称，而代码中roles方法给的角色名称实际上Spring Security都会加入前缀“ROLE_”；and方法则是一个连接方法，也就是开启另外一个用户的注册。上面的代码使用了and方法作为连接。有时候这样显得比较冗余，于是我们可以修改代码清单中的configure方法，代码如下12345678910111213141516@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //密码编译器 PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); //使用内存存储 InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; userConfig = auth.inMemoryAuthentication() //设置密码编码器 .passwordEncoder(passwordEncoder); //注册用户admin，并赋予abc，并赋予USER和ADMIN的角色权限 userConfig.withUser("admin").password(passwordEncoder.encode("abc")).authorities("ROLE_USER","ROLE_ADMIN"); //注册用户myuser，面膜为123456，并赋予USER的角色权限 userConfig.withUser("myuser").password(passwordEncoder.encode("123456")).authorities("ROLE_USER");&#125; 这里和上面实现的功能相同，只是这里将role方法修改为了authenorities方法，所以多加入了前缀“ROLE_”。但是无论如何，使用内存缓存用户信息方式不是主要的方式，因为空间毕竟有限，而且会占用JVM内存。因为用户详情构造器（UserDetailBuilder）后面还会经常用到，所以给出下面的表来介绍其他放的使用 项目类型 描述 accountExpired(boolean) 设置账号是否过期 accountLocked(boolean) 是否锁定账号 credentialsExpired(boolean) 定义凭据是否过期 diabled(boolean) 是否禁用用户 username(String) 定义用户名 authorities(GrantedAuthority…) 赋予一个或者多个权限 authorities(List&lt;? extends GrantedAuthority&gt;) 使用列表赋予权限 password(String) 定义密码 roles(String…) 赋予角色，会自动加入前缀ROLE_ 使用数据库定义用户认证服务大部分情况下，用户的信息会存放在数据库，为此Spring Security提供了对数据库的查询方法来满足开发者的需求。JdbcUserDetailsManagerConfigurer是一个Spring Securty对于数据库配置的支持，并且他也提供默认的SQL。知识大部分的情况下，不会采用它默认提供的SQL，基于使用的原则，下面先准备表和数据 创建用户权限和用户权限关系表 1234567891011121314151617181920212223242526272829-- 角色表CREATE TABLE t_role ( id INT (12) NOT NULL auto_increment, role_name VARCHAR (60) NOT NULL, note VARCHAR (256), PRIMARY KEY (id));-- 用户表CREATE TABLE t_user ( id INT (12) NOT NULL auto_increment, user_name VARCHAR (60) NOT NULL, pwd VARCHAR (100) NOT NULL, available INT (1) DEFAULT 1 CHECK (available IN(0, 1)), note VARCHAR (256), PRIMARY KEY (id), UNIQUE (user_name))-- 用户角色表CREATE TABLE t_user_role ( id INT (12) NOT NULL auto_increment, role_id INT (12) NOT NULL, user_id INT (12) NOT NULL, PRIMARY KEY (id), UNIQUE (role_id, user_id))-- 外键约束ALTER TABLE t_user_role ADD CONSTRAINT FK_Reference_1 FOREIGN KEY (role_id) REFERENCES t_role (id) ON DELETE RESTRICT ON UPDATE RESTRICT;ALTER TABLE t_user_role ADD CONSTRAINT FK_Reference_2 FOREIGN KEY (user_id) REFERENCES t_user (id) ON DELETE RESTRICT ON UPDATE RESTRICT; Spring Security提供的数据库权限进行验证 1234567891011121314151617181920@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //使用用户名称查询密码 String pwdQuery = "select user_name,pwd,available from t_user where user_name = ?"; //使用用户名称查询用户角色信息 String roleUqery = "select u.user_name,r.role_name from t_user u,t_user_role ur,t_role r where u.id = ur.user_id and r.id = ur.role_id and u.user_name = ?"; //密码编码器 PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); auth.jdbcAuthentication() //密码编码器 .passwordEncoder(passwordEncoder) //数据源 .dataSource(applicationContext.getBean(DataSource.class)) //查询用户，自动判断密码是否一致 .usersByUsernameQuery(pwdQuery) //赋予权限 .authoritiesByUsernameQuery(roleUqery);&#125; usersByUserNameQuery方法，通过pwdQuery所定义的SQL返回3列，分别是用户名、密码、布尔值。这样就可以对用户名和密码进行验证了，其中布尔值是判断用户是否有效，这里返回的是available列，它存储的数据已经被约束为1和0，如果为1则表示用户是有效的，否则用户是无效的。而authoritiesByUsernameQuery方法会用roleQuery定义的SQL通过用户名称去查询角色名称，这样Spring Security就会根据查询的结果赋予权限。值得注意的是，如果这条SQL返回多条，那么就会给这个用户赋予多个角色但是上面的代码存在一个弊端，虽然通过BCrypt加密的密文很难破译，但是仍旧不能比曼用户使用类似a123456等简单的密码，如果被人连接了这些简单的密码，进行匹配，那么一些用户的密码就可能被别人破译，为了克服这些问题，在实际的企业生产中还可以通过自己的阴钥对密码进行加密处理，而阴钥存在企业服务器上，这样即使密文被别人截取，别人也无法得到阴钥破解密文，这样就能够大大的提高网站的安全性。对此Spring Security也进行了支持，只需要使用密码编码器（Pbkdf2PasswordEncoder类）对象即可。这里我们在application.properties中加入一个属性12# 密码加密阴钥system.user.password.secret=uvwxyz 这是一个阴钥，只有拿到这个阴钥才能通过加密算法对密码进行匹配，这样破解的难度就大大增加了，就能够更加安全的保护密码信息，然后对上面的代码进行改造，代码如下123456789101112131415//注入配置的阴钥@Value("$&#123;system.user.password.secret&#125;")private String secret;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //使用用户名称查询密码 String pwdQuery = "select user_name,pwd,available from t_user where user_name = ?"; //使用用户名称查询用户角色信息 String roleUqery = "select u.user_name,r.role_name from t_user u,t_user_role ur,t_role r where u.id = ur.user_id and r.id = ur.role_id and u.user_name = ?"; //密码编码器 PasswordEncoder passwordEncoder = new Pbkdf2PasswordEncoder(this.secret); .... &#125; 在这段代码中，使用了Pbkdf2PasswordEncoder创建密码编码器（PasswordEncoder）实际上，Spring Security还存在其他密码加载器，用户可以根据自己的需求去创建不同的密码编码器 (重点)使用自定义用户认证服务目前大量的企业使用NoSQL存储用户数据，如Redis，这样就能够大大的加速用户的验证速度，因此有时候需要用户进行自定义验证。 实现UserDetailsService接口定义用户服务类首先设置用户权限的当时，对于Spring Security提供了一个UserDetailsService接口，通过它可以获取用户信息，而这个接口只有一个loadUserByUsername方法需要实现，这个方法定义返回UserDetails接口对象，于是很快就可以通过类似于如下代码实现这个接口，进而获取用户信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.xyd.mc.demo.database.service.impl;import com.xyd.mc.demo.database.pojo.DatabaseRole;import com.xyd.mc.demo.database.pojo.DatabaseUser;import com.xyd.mc.demo.database.service.UserRoleService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import java.util.ArrayList;import java.util.List;/** * @project: mc * @description: * @author: zp * @create: 2019-08-31 15:59 **/ @Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserRoleService userRoleService; @Override public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException &#123; //获取数据库用户信息 DatabaseUser dbUser = userRoleService.getUserByName(userName); //获取数据库角色列表 List&lt;DatabaseRole&gt; roleList = userRoleService.findRolesByUserName(userName); //将信息转换为UserDetails对象 return changeToUser(dbUser,roleList); &#125; private UserDetails changeToUser(DatabaseUser dbUser,List&lt;DatabaseRole&gt; roleList)&#123; //权限列表 List&lt;GrantedAuthority&gt; authorityList = new ArrayList&lt;&gt;(); //赋予查询到的角色 for(DatabaseRole role : roleList)&#123; GrantedAuthority authority = new SimpleGrantedAuthority(role.getRoleName()); authorityList.add(authority); &#125; //创建UserDetails对象，设置用户名、密码和权限 UserDetails userDetails = new User(dbUser.getUserName(), dbUser.getPwd(),authorityList); return userDetails; &#125;&#125; 把这个类标注为@Service，这样Spring就会自动扫描它为Bean，然后通过自动注入了UserRoleService接口。接着覆盖接口的loadUserByUsername方法，这个方法先通过UserRoleService接口查询到用户和对应的角色信息，然后通过changeToUser方法将它转换成一个UserDetails接口帝乡，在这个changeToUser方法中，先是构建一个权限列表，然后通过User的构建方法将用户名称和密码传递，这样用户详情就拥有了这些信息然后我们需要给认证服务注册这个UserDetailsServiceImpl，因此需要改造Spring Boot 的启动文件，代码如下1234567891011121314//注入配置的阴钥@Value("$&#123;system.user.password.secret&#125;")private String secret;@Autowiredprivate UserDetailsService userDetailsService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //密码编码器 PasswordEncoder passwordEncoder = new Pbkdf2PasswordEncoder(this.secret); auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);&#125; 这里因为UserDetailsServiceImpl被标注了@Service，所以会被Spring的上下文扫描装备为Bean。configure方法首先生命了密码编码器，这样就能够对密码进行加密比较，然后通过userDetailsService方法注册用户服务实现类，同时绑定密码的编译器，这样就能够使用加密过后的密码了。 限制请求上面只是验证了用户，并且还给与用户赋予了不同的角色，但对于不同角色而言，其访问的权限是不一样的，因此还需要对不同的橘色赋予不同的权限。在上述配置用户中，集成了抽象类WebSecurityConfigurerAdapter，并覆盖了configure(AuthenticationManagerBuilder AuthenticationManagerBuilder)方法，除此之外，这个抽象类还提供了另外一个方法，那就是configure(HttpSecurity)，通过它便可以实现对不同角色赋予不同权限的功能因为WebSecurityConfigurerAdapter已经实现configure(HttpSecurity)的方法，所以先从它原有的方法进行探讨 下面是源码：12345678910111213protected void configure(HttpSecurity http) throws Exception &#123; this.logger.debug("Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity)."); ((HttpSecurity)((HttpSecurity)((AuthorizedUrl) //只需要通过验证就可以访问所有的请求 //authorizeRequests方法限定只对签名成功的用户请求 //anyRequest方法限定所有请求 //authenticated方法对所有的签名成功的用户允许方法 http.authorizeRequests().anyRequest()).authenticated() //and方法是连接词，formLogin代表使用Spring Security默认的登录界面 .and()).formLogin() //httpBasic方法说明启用HTTP基础认证 .and()).httpBasic(); &#125; 从源码可以看出，只需要通过用户认证便可以访问所有的请求地址。丫还通过formLogin方法配置使用SpringSecurity默认登录页面和httpBasic方法启用浏览器的HTTP基础认证方式。所以在默认的情况下，只要登录了用户，一些的请求就会畅通无阻，单着往往不是我们真正需要的，毕竟不同的用户有着不同的角色，有时候我们需要根据角色赋予权限，因此在很多的时候需要覆盖掉这个方法，让不同的角色有着不同的权限。 配置请求路径访问权限对于SpringSecurity，它允许使用Ant放个或者正则式的路径限定安全请求，代码如下1234567891011121314151617181920@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //限定签名后的权限 http.authorizeRequests() //限定"/user/welcome"请求赋予角色ROLE_USER或者ROLE_ADMIN .antMatchers("/user/welcome","/user/detais").hasAnyRole("USER","ADMIN") //限定“/admin”下所有请求权限赋予角色ROLE_ADMIN .antMatchers("/admin/**").hasAuthority("ROLE_ADMIN") //其他路径允许签名后访问 .anyRequest().permitAll() //对于没有配置权限的其他请求允许匿名访问 .and().anonymous() //使用Spring Security默认的登录页面 .and().formLogin() //启用http基础验证 .and().httpBasic();&#125; 关于权限的方法还有很多，如下表 方法 含义 access(String) 参数为SpEL，如果返回true则允许访问 anonymous() 允许匿名访问 authorizeRequests() 限定通过签名的请求 anyRequest() 限定任意的请求 hasAnyRole(String…) 将访问权限赋予多个角色，角色会自动加入前缀ROLE_ hasAnyRole() 将访问权限赋予一个角色，默认加入前缀ROLE permitAll() 无条件允许访问 httpBasic() 启用浏览器的HTTP基础验证 formLogin() 启用Spring Security默认的登录页面 not() 对其他方法的访问采取求反 fullyAuthenticated() 如果是完整验证（并非Remember-me）则允许访问 denyAll() 无条件不允许任何访问 hasIpAddress(String) 如果是给定的IP地址则允许访问 rememberme() 用户通过Remember-me功能验证就允许访问 hasAuthority(String) 如果是给定的橘色就允许访问不加入前缀ROLE_ hasAnyAutoirity(String…) 如果是给定的角色中的任意一个就允许访问（不加入前缀ROLE_） 使用Spring表达式配置访问权限有时候需要更加强大的验证功能，而上述功能只能是使用方法进行配置，为了更加灵活，我们还可以使用Spring EL进行配置。这样就需要使用到上表中access方法，他的参数是一个Spring的表达式，如果这个表达式返回true，则允许访问，否则不允许访问。初次之外，Spring Security还提供了一些有用的表示式语言曾倩原有的功能，注意下面的代码中的access(&quot;hasAuthority(&#39;ROLE_ADMIN&#39;)&quot;)，多个条件进行限制的时候使用access(&quot;hasRole(&#39;ADMIN&#39;) and hasRole(&#39;DBA&#39;)&quot;)12345678910111213141516171819@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //限定签名后的权限 http.authorizeRequests() //限定"/user/welcome"请求赋予角色ROLE_USER或者ROLE_ADMIN .antMatchers("/user/welcome","/user/detais").hasAnyRole("USER","ADMIN") //限定“/admin”下所有请求权限赋予角色ROLE_ADMIN .antMatchers("/admin/**").access("hasAuthority('ROLE_ADMIN')") //其他路径允许签名后访问 .anyRequest().permitAll() //对于没有配置权限的其他请求允许匿名访问 .and().anonymous() //使用Spring Security默认的登录页面 .and().formLogin() //启用http基础验证 .and().httpBasic();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第11章 构建REST风格网站]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%AC%AC11%E7%AB%A0-%E6%9E%84%E5%BB%BAREST%E9%A3%8E%E6%A0%BC%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[构建REST风格网站REST风格不是一种标准，而是一种风格，这种风格，在各个微服务之间用于交互的方式，每一个资源知识对应一个网站，而一个代表资源网站应该是一个名词，而不是动词，这代表资源的操作 REST简述REST（Representational State Transfer）名词解释 资源：他可以是系统权限用户、角色和菜单，也可以是一些媒体类型，如文本、图像，可以使用一个URI指向它，每个资源对应一个特定的URI，在REST中每一个资源都会对应一个独一无二的URI 表现层：有了资源还需要确定如何表现这个资源，例如，一个用户可以使用JSON、xml护着其他的形式表现出来 状态转换：显示中资源并不是一成不变的，是一个变化的过程，一个资源可以经历创建、访问、修改、删除的过程。对于HTTP协议，是一个没有状态的协议，这也就意味着对于资源的状态变化只能在服务端保存和修改 有了上面的描述，下面稍微总结一下REST风格架构的特点 服务器存在一系列的资源，每一个资源通过单独唯一的URI进行标识 服务端和服务器端之间相互传递资源，而资源会以魔偶中表现层得以展示 客户端通过HTTP协议所定义的动作对资源进行操作，已实现资源的状态转换HTTP的动作REST风格的URI设计123456789101112# 获取用户信息，1是用户编号GET /user/1# 查询多个用户信息GET /users/&#123;userName&#125;/&#123;note&#125;# 创建用户POST /user/&#123;userName&#125;/&#123;sex&#125;/&#123;note&#125;# 修改用户全部属性PUT /user/&#123;id&#125;/&#123;userName&#125;/&#123;sex&#125;/&#123;note&#125;# 修改用户名称PATCH /user/&#123;id&#125;/&#123;userName&#125;# 删除用户DELETE /user/&#123;id&#125; 注意，在URI中并没有出现动词，而是对应参数主要通过URI设计去获取。对于参数超过5个的可以考虑使用JSON方式来传递参数。 REST风格的一些误区在设计URI时REST风格存在一些规范，例如，一般不应该在URI中存在动词GET /user/get/1这里的get是一个动词，在REST风格是不应该存在这样的动词的另一个误区是加入版本号，例如：GET /v1/user/1其中v1代表一个版本号，而user表示用户信息，1则表示用户编号。这是一个错误的表达，因为在REST风格中资源的URI是唯一的，如果存在版本号，可以设置HTTP请求头，使用请求头的信息进行区分，例如，设置请求头的versin参数为1.0Accept:version=1.0在很多时候REST都不推荐使用类似于PUT users?userName=user_name&amp;note=note这样传递参数。这是一个更新用户的URI，按REST风格的建议是采用PUT /users/{userName}/{note}但是有时候会出现参数很多的情况，如果参数过多，考虑请求体取参数 客户观请求RestTemplate在当今的微服务中，会将一个大系统拆分为多个微服务系统。按照微服务应用的建议，每个微服务都会暴漏REST风格URI请求给别的微服务系统所调用，为了方便系统之间的相互调用，Spring给予模板类RestTemplate，通过它可以很方便的对REST请求进行系统之间的调用，完成系统之间的数据集成，在Spring Cloud中还可以声明式调用 使用RestTemplate请求后端 最简单的GET请求RestTemplate的底层是通过HttpURLConnection实现的12345678public static User getUser(Long id)&#123; //创建一个RestTemplate对象 RestTemplate restTemplate = new RestTemplate(); //消费服务，第一个参数是url，第二个是返回类型，第三个是URI路径参数 User user = restTemplate.getForObject("http://localhost8080/user&#123;id&#125;",User.class,id); System.out.println(user.getUserName()); return user;&#125; 这是进行了一次最为简单的GET请求，这里的getForObject方法是需要关注的核心方法。第一个参数是URI标明请求服务器什么资源，而{id}则代表参数。第二个参数声明为UserVo.class，表示请求将返回UserVo类的结果，实际上服务器只返回JSON类型的数据，知识RestTemplate内部会将其准变为Java对象。如果URI中有多个参数，只要按顺序写就可以了，如果参数很多，可以使用下面的方法 多参数GET请求返回List数据1234567891011121314151617181920212223/** * @Description: 多参数GET请求返回List数据 * @param: [userName, note] * @return: java.util.List&lt;com.xyd.mc.demo.database.pojo.User&gt; * @Author: zp * @Date: 2019/8/31 */@PostMapping("/findUsers")@ResponseBodypublic List&lt;User&gt; findUsers(String userName,String note)&#123; RestTemplate restTemplate = new RestTemplate(); //使用Map封装多个参数，提高可读性 Map&lt;String,Object&gt; params =new HashMap&lt;&gt;(); params.put("userName",userName); params.put("note",note); //Map中的key和URI中的参数意义对应 String url = "http://localhost:8080/user/findUsers/&#123;userName&#125;/&#123;note&#125;"; //请求后端 ResponseEntity&lt;List&gt; responseEntity = restTemplate.getForEntity(url,List.class,params); List&lt;User&gt; users = responseEntity.getBody(); return users;&#125; 这里将参数用一个Map对象封装起来，而Map的键和URI中定义的参数保持一致，这样就能够将参数一一封装到Map。这里返回的是一个List对象，所以返回类型声明为List，这样RestTemplate就会解析结果返回数据。 通过POST请求传递JSON请求体应用场景：保存/新增用户时出现字段比较多的情况，所以往往采用传递请求体的方式12345678910111213141516171819202122/** * @Description: 通过POST请求体传递JSON请求体 * @param: [user] * @return: com.xyd.mc.demo.database.pojo.User * @Author: zp * @Date: 2019/8/31 */@PostMapping("/insertUser")@ResponseBodypublic User insertUser(@RequestBody User user)&#123; //1. 请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON_UTF8); //2. 创建请求实体对象 HttpEntity&lt;User&gt; request = new HttpEntity&lt;&gt;(user,headers); RestTemplate restTemplate = new RestTemplate(); //3. 请求时传递请求尸体对象，并返回回填id的用户 User savedUser = restTemplate.postForObject("http://localhost:8080/user/insertUser",request,User.class); return savedUser;&#125; 上面的代码首先定义了HTTP头，并将请求体内容设置为JSON类型，然后将它和请求体绑定到请求实体对象中，在RestTmplate的postForObject方法中将请求尸体对象传递过去，让后台接收就可以了。 获取响应头、状态码和资源交换HTTP状态吗可以辨别请求是否成功，如果发生错误，他还可以给出信息反馈错误原因123456789ResponseEntity&lt;User&gt; userEntity = restTemplate.postForEntity(url,requestEntity,User.class);//获取响应体User user = userEntity.getBody();//获取响应头HttpHeaders respHeaders = userEntity.getHeaders();//获取相应属性List&lt;String&gt; success = respHoeaders.get("success");//响应的HTTP状态码int status = respHeaders.getStatusCodeValue(); 这里可以看到使用了RestTemplate的postForEntity方法，他将会返回一个ResopneseEntity对象，这个对象包含了服务器返回的响应体，状态码和响应头]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理出现cookie信息丢失]]></title>
    <url>%2F2019%2F08%2F15%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%87%BA%E7%8E%B0cookie%E4%BF%A1%E6%81%AF%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[熬夜到这个点，还在加班加点，欲哭无泪，被兄弟们坑的不行不行的，慢慢填坑…今天在发布的时候发现使用Nginx反向代理到前后端分离的项目（假的前后端分离还是用Cookie）上之后，出现Cookie信息丢失的情况，查来查去，最终锁定还是在Nginx上，因为Tomcat在本地已经设置了跨越，js中也设置了withCredentials，还是出现Cookie上不去的问题，今天把处理的方案记下来，供分享 Cookie个人理解机制Cookie不仅仅是在域（域名）上存在分离，也在目录上做了隔离 常规情况像下面这种配置一般是没有问题的，因为两个项目名是一样的，因此不会出现cookie丢失的情况123location /projectname&#123; proxy_pass http://127.0.0.1:8080/projectname;&#125; 特殊情况当nginx接收到的地址和要转发的地址在路径上有差异的时候，就会出现cookie的丢失问题，例如下：123location /projectnameA&#123; proxy_pass http://127.0.0.1:8080/projectnameB;&#125; location指向的地址和实际代理的地址的项目名不同，就需要添加proxy_cookie_path /projectnameB /projectnameA，一定要注意项目名前面有斜杠，后面没斜杠（在这个坑里面待了十几分钟才爬上来….），正确的配置如下：1234location /projectnameA&#123; proxy_pass http://127.0.0.1:8080/projectnameB; proxy_cookie_path /projectnameB /projectnameA;&#125; 其他设置好上面这些，还需要设置Nginx的跨域处理，可以在http、location中加入如下代码123add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Headers X-Requested-With;add_header Access-Control-Allow-Methods GET,POST,OPTIONS; 其实项目前后端分离之后是很不建议再使用Cookie携带信息到后台的这种操作，应该是使用Token设置过期时间，保证项目的正常运行，因为跨域的项目在安全测评中是过不了的，所以能改则改，千万别到时候被别人给攻击了，可以使用JWT配合Redis的方案进行处理，后期的博客中会加入这些相关的内容，敬请期待]]></content>
      <categories>
        <category>中间件</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>中间件</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB安装]]></title>
    <url>%2F2019%2F08%2F12%2FMongoDB%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux安装下载 首先打开社区Server版下载地址，具体如下图 使用命令下载并解压123[root@VM_0_12_centos download]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.12.tgz # 下载 [root@VM_0_12_centos download]# tar -zxvf mongodb-linux-x86_64-4.0.12.tgz #解压[root@VM_0_12_centos download]# mv mongodb-linux-x86_64-4.0.12 /usr/local/mongodb #迁移到/usr/local下 安装 添加环境变量将安装目录添加到环境变量$PATH当中1export PATH=/usr/local/mongodb/bin:$PATH 创建数据库目录MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程中不会自动创建，所以你需要手动创建data目录，并在目录中创建db目录1mkdir -p /data/mongodb/data/ 启动使用命令./mongod --dbpath=/data/mongodb/data启动，其中--dbpath指定数据保存的路径，如果不加默认是在/data/db下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[root@VM_0_12_centos bin]# ./mongod --dbpath=/data/mongodb/data2019-08-15T01:22:00.311+0800 I STORAGE [main] Max cache overflow file size custom option: 02019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] MongoDB starting : pid=30521 port=27017 dbpath=/data/mongodb/data 64-bit host=VM_0_12_centos2019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] db version v4.0.122019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] git version: 5776e3cbf9e7afe86e6b29e22520ffb6766e95d42019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] allocator: tcmalloc2019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] modules: none2019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] build environment:2019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] distarch: x86_642019-08-15T01:22:00.316+0800 I CONTROL [initandlisten] target_arch: x86_642019-08-15T01:22:00.317+0800 I CONTROL [initandlisten] options: &#123; storage: &#123; dbPath: "/data/mongodb/data" &#125; &#125;2019-08-15T01:22:00.317+0800 I STORAGE [initandlisten]2019-08-15T01:22:00.317+0800 I STORAGE [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine2019-08-15T01:22:00.317+0800 I STORAGE [initandlisten] ** See http://dochub.mongodb.org/core/prodnotes-filesystem2019-08-15T01:22:00.317+0800 I STORAGE [initandlisten] wiredtiger_open config: create,cache_size=407M,cache_overflow=(file_max=0M),session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),2019-08-15T01:22:02.127+0800 I STORAGE [initandlisten] WiredTiger message [1565803322:127781][30521:0x7f809d2daa40], txn-recover: Set global recovery timestamp: 02019-08-15T01:22:02.396+0800 I RECOVERY [initandlisten] WiredTiger recoveryTimestamp. Ts: Timestamp(0, 0)2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** WARNING: This server is bound to localhost.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** Remote systems will be unable to connect to this server.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** Start the server with --bind_ip &lt;address&gt; to specify which IP2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** addresses it should serve responses from, or with --bind_ip_all to2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** bind to all interfaces. If this behavior is desired, start the2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** server with --bind_ip 127.0.0.1 to disable this warning.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** We suggest setting it to 'never'2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is 'always'.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** We suggest setting it to 'never'2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten] ** WARNING: soft rlimits too low. rlimits set to 7282 processes, 100001 files. Number of processes should be at least 50000.5 : 0.5 times number of files.2019-08-15T01:22:04.382+0800 I CONTROL [initandlisten]2019-08-15T01:22:04.383+0800 I STORAGE [initandlisten] createCollection: admin.system.version with provided UUID: 5c53404c-28ee-4357-b3a2-3443e8b8b6742019-08-15T01:22:04.497+0800 I COMMAND [initandlisten] setting featureCompatibilityVersion to 4.02019-08-15T01:22:04.500+0800 I STORAGE [initandlisten] createCollection: local.startup_log with generated UUID: a95b9964-563d-447e-b678-08034f942c6b2019-08-15T01:22:04.561+0800 I FTDC [initandlisten] Initializing full-time diagnostic data capture with directory '/data/mongodb/data/diagnostic.data'2019-08-15T01:22:04.562+0800 I STORAGE [LogicalSessionCacheRefresh] createCollection: config.system.sessions with generated UUID: a161a0bc-dee2-4f7b-bc38-1a6fab780dd42019-08-15T01:22:04.563+0800 I NETWORK [initandlisten] waiting for connections on port 270172019-08-15T01:22:04.660+0800 I INDEX [LogicalSessionCacheRefresh] build index on: config.system.sessions properties: &#123; v: 2, key: &#123; lastUse: 1 &#125;, name: "lsidTTLIndex", ns: "config.system.sessions", expireAfterSeconds: 1800 &#125;2019-08-15T01:22:04.660+0800 I INDEX [LogicalSessionCacheRefresh] building index using bulk method; build may temporarily use up to 500 megabytes of RAM2019-08-15T01:22:04.668+0800 I INDEX [LogicalSessionCacheRefresh] build index done. scanned 0 total records. 0 secs2019-08-15T01:22:04.916+0800 I COMMAND [LogicalSessionCacheRefresh] command config.$cmd command: createIndexes &#123; createIndexes: "system.sessions", indexes: [ &#123; key: &#123; lastUse: 1 &#125;, name: "lsidTTLIndex", expireAfterSeconds: 1800 &#125; ], $db: "config" &#125; numYields:0 reslen:114 locks:&#123; Global: &#123; acquireCount: &#123; r: 2, w: 2 &#125; &#125;, Database: &#123; acquireCount: &#123; w: 2, W: 1 &#125; &#125;, Collection: &#123; acquireCount: &#123; w: 2 &#125; &#125; &#125; storage:&#123;&#125; protocol:op_msg 105ms]]></content>
      <categories>
        <category>软件安装</category>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中自动生成serialVersionUID]]></title>
    <url>%2F2019%2F08%2F11%2FIDEA%E4%B8%AD%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90serialVersionUID%2F</url>
    <content type="text"><![CDATA[最近项目中使用Redis，需要对象进行序列化才能进行保存，看书上提供的entity对象中都会有一个serialVersionUID，查了下这是继承Serializable之后，需要生成一个，否则在反序列化的时候会出现无法反序列化的情况 未配置情况下，在IDEA中的效果是如下的未配置的时候，Alt+Enter会不显示自动生成SerialVersionUID的功能 配置步骤在IDEA中找到Fiel-&gt;Settings-&gt;搜索框输入inspect-&gt; 点击Inspections-&gt;输入serialV，找到下图中的两个选项勾上 配置完成后效果在实体类上Alt+Enter，可以看到有了自动生成SerialVersionSID的功能，点击即可自动添加上]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>serialVersionUID</category>
      </categories>
      <tags>
        <tag>POJO</tag>
        <tag>serialVersionUID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis安装]]></title>
    <url>%2F2019%2F08%2F10%2FRedis%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Windows安装下载下载地址为Redis安装下载地址 打开页面，选择对应的版本(Linux的下载地址和这个下载地址不一样) 下载之后，解压到任意目录下，并记下这个目录环境变量配置 测试是否正常 打开一个cmd窗口，输入下面的命令启动redis(可以不输入后面的配置文件，会自动选择默认配置文件)1redis-server redis.windows.conf 另起一个cmd窗口，原来的不要关闭 连接到数据库 1redis-cli -h 127.0.0.1 -p 6379 设置key 1set myKey abc 获取键值对 1get myKey Linux安装]]></content>
      <categories>
        <category>软件安装</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat日志定时备份和Oracle数据库定时备份]]></title>
    <url>%2F2019%2F07%2F31%2Ftomcat%E6%97%A5%E5%BF%97%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E5%92%8COracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[Oracle数据库备份备份脚本123456789101112131415161718export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK#以上代码为Oracle数据库运行账号oracle的系统环境变量设置，必须添加，否则crontab任务计划不能执行。dateTime=`date +%Y%m%d` #当前系统时间days=7 #删除7天前的备份数据sorsid=sid #oralce连接信息orowner=user # 备份此用户下面的数据bakuser=user #用此用户来执行备份，必须要有备份操作的权限bakpass="password" #执行备注的用户密码bakdir=/home/oracle/databack #备份文件路径，需要提前创建好bakdata=$orowner"_"$dateTime.dmp #备份数据库名称baklog=$orowner"_"$dateTime.log #备份执行时候生成的日志文件名称ordatabak=$orowner"_"$dateTime.tar.gz #最后保存的Oracle数据库备份文件remotePath=/home/databack/ #上传到远程服务器的路径cd $bakdir #进入备份目录mkdir -p $orowner #按需要备份的Oracle用户创建目录cd $orowner #进入目录export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1exp 'user/"password"@orsid' owner=$orowner file=$bakdir/$orowner/$bakdata log=$bakdir/$orowner/$baklog direct=y #执行备份 使用crontab添加定时任务10 1 * * * . ~/.bash_profile; /home/oracle/databack/ordatabak.sh 日志备份日志备份脚本1234567891011121314#! /bin/bashlogdir="/home/MGPLAT/logs"DATE=`date "+%Y%m%d%H%M"`export DATEcd $&#123;logdir&#125;cd /home/mgplat-logbaktest -d $&#123;DATE&#125; || mkdir $&#123;DATE&#125;cp /home/MGPLAT/logs/catalina.out /home/mgplat-logbak/$&#123;DATE&#125;/catalina.outcd /home/mgplat-logbak/$&#123;DATE&#125;tar -zcvf $&#123;DATE&#125;.tar catalina.outrm -rf catalina.outsleep 2cd /home/MGPLAT/logsecho &gt; catalina.out 使用crontab添加定时任务10 0 * * * /home/mgplat-logbak/mgplatlogbackup.sh]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
        <category>数据库备份</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>数据库备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章 深入Spring MVC开发]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%AC%AC10%E7%AB%A0-%E6%B7%B1%E5%85%A5Spring-MVC%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[深入Spring MVC 开发获取控制器参数无注解下获取参数使用@RequestParam获取参数前后端可能出现命名规则不同，这时需要把前端的参数与后台的参数对应起来。Spring MVC提供注解@RequestParam来确定前后端参数名称的映射关系，代码如下1234567891011121314@GetMapping("/annotation")@ResponseBodypublic Map&lt;String,Object&gt; requestParam( @RequestParam("int_val") Integer intVal, @RequestParam("long_val") Integer longVal, @RequestParam("str_val") Integer stringVal)&#123; Map&lt;String,Object&gt; paramsMap = new HashMap&lt;&gt;(); paramsMap.put("intVal",intVal); paramsMap.put("longVal",longVal); paramsMap.put("stringVal",stringVal); return paramsMap;&#125; 在浏览器中输入http://localhost:8080/my/annotation?int_val=1&amp;long_val=2&amp;str_val=str，就能够看到请求的结果。但是如果把3个HTTP参数中去掉任意一个，就会报异常错误，因为默认的情况下@RequestParam标注的参数是不能为空的，为了它能够为空，可以配置其属性required为false，代码如下，这样就可以传空了1@RequestParam(value="int_val",required = false) Integer intVal, 传递数组在Spring MVC中，除了可以传递简单的参数外，还可以传递数组。支持用逗号隔开的数组参数123456789101112@GetMapping("/requestArray")@ResponseBodypublic Map&lt;String,Object&gt; requestArray( int[] intArr, Long[] longArr, String[] strArr)&#123; Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("intArr",intArr); paramMap.put("longArr",longArr); paramMap.put("strArr",strArr); return paramMap;&#125; 在浏览器中输入http://localhost:8080/my/requestArray?intArr=1,2,3&amp;longArr=4,5,6&amp;strArr=str1,str2,str3，可以看到需要传递数组参数时，每个参数的数组元素只需要通过逗号分隔即可 传递JSON下面演示下使用ajax传递json数据，首先是js代码123456789101112131415var params = &#123; userName:userName, note:note&#125;;$.post(&#123; url:"./insert", //此处需要告知传递参数类型为JSON，不能缺少 contentType:"application/json", //将JSON转化为字符串 data:JSON.stringify(params), success:function(res)&#123; console.log(res); &#125;&#125;) 123456@PostMapping("/insert")@ResponseBodypublic User insert(@RequestBody User user)&#123; userService.insertUser(user); return user;&#125; 上面的js代码中contentType:&quot;application/json&quot;,和data:JSON.stringify(params),必须要加上，到达后台之后可以通过@RequestBody转化成自己想要的对象 通过URL传递参数REST风格的的接口，常规是通过URL传递参数的，例如获取编号为1的用户，url就写成/user/1，这里的1代表的是用户编号（id），通过注解@PathVariable的组合获取参数URL参数，代码如下12345@GetMapping("/&#123;id&#125;")@ResponseBodypublic User get(@PathVariable("id") Long id)&#123; return userService.getUser(id);&#125; 数据验证JSR-303验证JSR-303的主要是通过注解的方式进行的，这里先定义一个需要验证的POJO，此时需要在其属性中加入相关的注解，代码如下1234567891011121314151617181920212223242526272829303132333435public class ValidtorPojo &#123; //非空判断 @NotNull(message = "id不能为空") private Long id; //只能是将来的日期 @Future(message = "需要一个将来的日期") //@Past//只能是过去的日期 //日期格式转换 @DateTimeFormat(pattern = "yyyy-MM-dd") //不能为空 @NotNull private Date date; //最小0.1元 @DecimalMin(value="0.1") @DecimalMax(value="100000.00") private Double aDouble = null; @Min(value=1,message = "最小值为1") @Max(value=99,message = "最大值为99") private Integer integer; @Range(min = 1,max = 888,message = "范围为1至888") private Long range; //邮箱验证 @Email(message = "邮箱格式错误") private String email; @Size(min=20,max = 30,message = "字符串长度要求20到30") private String size;&#125; 12345678910111213141516171819202122@RequestMapping(value="/valid/validate") @ResponseBody public Map&lt;String,Object&gt; validate(@Valid @RequestBody ValidtorPojo vp, Errors errors)&#123; Map&lt;String,Object&gt; errorMap = new HashMap&lt;&gt;(); //获取错误列表 List&lt;ObjectError&gt; oes = errors.getAllErrors(); for(ObjectError oe : oes)&#123; String key = null; String msg = null; //字段错误 if(oe instanceof FieldError)&#123; FieldError fe = (FieldError)oe; key = fe.getField();//获取错误验证字段名 &#125;else&#123; //非字段错误 key = oe.getObjectName();//获取验证对象名称 &#125; msg = oe.getDefaultMessage(); errorMap.put(key,msg); &#125; return errorMap; &#125; 代码中使用@RequetBody代表接收一个JSON参数，这样Spring就会获取页面提交过来的JSON 数据，然后@Valid注解则表示启动验证机制，这样Spring就会启动JSR-303验证机制进行验证，它会自动地将验证结果放入Errors对象中，这样就可以从中得到相关验证过后的消息。这些验证只能是简单的验证，复杂类的验证比如说总价的验证=单价*数量，这样的逻辑就不能通过JSR-303验证了，为此Spring还提供了自己的验证机制。 参数验证机制在Spring控制器中，还允许使用注解@InitBinder，这个注解的作用是允许在进入控制器方法钱修改WebDataBinder机制。下面在验证机制和日期格式绑定的场景下演示，不过在此之前，需要稍微人事下SPring MVC的验证机制。下面是自定义验证的代码12345678910111213141516171819202122232425262728public class UserValidator implements Validator &#123; //设置验证器只支持User类验证 @Override public boolean supports(Class&lt;?&gt; aClass) &#123; return aClass.equals(User.class); &#125; //验证逻辑 @Override public void validate(Object o, Errors errors) &#123; //对象如果为空 if(o == null)&#123; //直接在参数处报错，这样就不能进入控制器的方法 errors.rejectValue("",null,"用户不能为空"); return; &#125; //强制转换 User user = (User) o; //用户名非空字符串 if(StringUtils.isEmpty(user.getUserName))&#123; //增加错误，可以进入控制器方法 errors.rejectValue("userName",null,"用户名不能为空"); &#125; &#125;&#125; 有了这个验证器，Spring还不会自动启动它，因为还没有绑定给WebDataBinder机制，在Spring MVC中提供了一个注解@InitBinder，他的作用是在执行控制器方法前，处理器会限制性@InitBinder标注的方法。这时可以讲WebDataBinder对象作为参数传递到方法中，通过这层关系得到WebDatBinder对象，这个对象有一个SetValidator方法，它可以绑定自定义的验证器，这样就可以在获取参数之后，通过自定义的验证器去验证参数，知识WebDataBinder除了可以绑定验证器之外，还可以进行参数的自定义，例如，不适用@DataTimeFormat获取日期参数。假设还继续使用代码StringToUserConverter转换器，使用下面的代码验证和设置日志格式绑定验证器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xyd.mc.demo.database.controller;import com.xyd.mc.demo.database.validator.UserValidator;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.stereotype.Controller;import org.springframework.validation.Errors;import org.springframework.validation.FieldError;import org.springframework.validation.ObjectError;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.*;import javax.validation.Valid;import java.text.SimpleDateFormat;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @project: mc * @description: * @author: zp * @create: 2019-08-28 20:14 **/@Controller@RequestMapping("/user")public class TestController &#123; /** * 调用控制前先执行这个方法 * @param binder */ @InitBinder public void initBinder(WebDataBinder binder)&#123; //绑定验证器 binder.setValidator(new UserValidator()); //定义日期参数格式，参数不在徐注解@DateTimeFormat，boolean参数表示是允许为空 binder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"),false)); &#125; @GetMapping("/validator") @ResponseBody public Map&lt;String,Object&gt; validator(@Valid User user,Errors errors,Date date)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("user",user); map.put("date",date); //判断是否有错误存在 if(errors.hasErrors())&#123; //获取全部错误 List&lt;ObjectError&gt; oes = errors.getAllErrors(); for(ObjectError oe:oes)&#123; //判断是否字段错误 if(oe instanceof FieldError)&#123; //字段错误 FieldError fe = (FieldError) oe; map.put(fe.getField(),fe.getDefaultMessage()); &#125;else&#123; //对象错误 map.put(oe.getObjectName(),oe.getDefaultMessage()); &#125; &#125; &#125; return map; &#125;&#125; 这里的initBinder方法因为标注注解@InitBinder，因此会在控制器方法前执行，并且将WebDataBinder对象传递进去，这个方法里绑定了自定义的验证器UserValidator，而且设置了日期的格式，所以在控制器方法中不在需要@DateTimeFormate去定义日期格式。通过这样的自定义，在使用注解@Valid注解User参数后，Spring MVC会遍历对应的验证器，当遍历到UserValidator时，会去执行他的support方法，因为该方法会返回true，所以SPring MVC会用这个验证去验证User类的数据这里还要关注下控制器中的方法的Errors参数，他是SPring MVC通过验证器验证后得到的错误信息，由Spring MVC执行完验证规则后进行传递，这里首先是判断是否存在错误，如果存在错误，则遍历错误，然后将错误信息放入Map中返回，因为方法标注了@ResponseBody，所以最后会转换成JSON相应请求 拦截器拦截器设计首先所有的拦截器都需要实现HandlerInterceptor接口，拦截器中有三个方法，分别是preHandle、postHandle、afterCompletion，他们的执行顺序如下 执行preHandle方法，该方法会返回一个布尔值。如果为false，则结束所有的流程；如果为true则执行下一步 执行处理器逻辑，它包括控制器的功能 执行postHandle方法 执行师徒解析和视图渲染 执行afterCompletion方法因为这个接口是Java8 的接口，所以3个方法都被声明为default，并且提供了空实现。当我们需要自定义方法的时候，主需要实现HandlerInterceptor，覆盖其对应的方法即可。 开发拦截器12345678910111213141516171819202122232425262728293031323334package com.xyd.mc.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @project: mc * @description: 项目拦截器 * @author: zp * @create: 2019-08-28 21:12 **/public class ApplicationInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("处理器前方法"); //返回true，不会拦截 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("处理器后方法"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("处理器完成方法"); &#125;&#125; 这里的代码重写了3个方法，在这些方法中打印了一些信息，这样就可以定位拦截器的执行书序。有了这个拦截器，Spring MVC并不会发现他，还需要进行注册才能拦截，为此在配置文件中实现WebMvcConfigurer接口，最后覆盖其addInterceptors方法进行注册拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xyd.mc;import com.xyd.mc.interceptor.ApplicationInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.connection.MessageListener;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.listener.ChannelTopic;import org.springframework.data.redis.listener.RedisMessageListenerContainer;import org.springframework.data.redis.listener.Topic;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;import org.springframework.stereotype.Repository;import org.springframework.web.servlet.config.annotation.InterceptorRegistration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.annotation.PostConstruct;@SpringBootApplication(scanBasePackages = &#123;"com.xyd.mc"&#125;)@EntityScan(basePackages = "com.xyd.mc.*.*.pojo")@MapperScan( basePackages = "com.xyd.mc.*", sqlSessionTemplateRef = "sqlSessionTemplate", annotationClass = Repository.class)@EnableCachingpublic class McApplication implements WebMvcConfigurer &#123; /********其他代码********/ /** * 添加拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; //注册拦截器到Spring MVC机制，然后他会返回一个拦截器注册 InterceptorRegistration ir = registry.addInterceptor(new ApplicationInterceptor()); //指定拦截器的匹配模式，限制拦截器拦截请求 ir.addPathPatterns("/*/*"); &#125;&#125; 这里implements了WebMvcConfigurer接口，并重写了addInterceptors方法，将咱们写的拦截器加进去，他会拦截所有的请求只要是符合/*/*的请求 多个拦截器的顺序 对于处理器前方法采用先注册限制性，而处理器后方法和完成方法则是先注册后执行的原则。 一旦一个拦截器返回false，则后续的拦截器、处理器和所有拦截器的处理器后方法都不会被执行]]></content>
  </entry>
  <entry>
    <title><![CDATA[第9章 初识Spring MVC]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%AC%AC9%E7%AB%A0-%E5%88%9D%E8%AF%86Spring-MVC%2F</url>
    <content type="text"><![CDATA[初识SpringMVCSpring MVC流程 通过application.properties定制InternalReourceViewResolver初始化12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 通过修改这样的配置，就能在Spring Boot的机制下定制InternalResourceViewResolver这个视图解析器的初始化，也就是在返回视图名称之后，就会以前缀prefix和后缀suffix以及视图名称组成全路径定位视图。例如在控制器中返回user/detail，那么就会找到/WEB-INF/jsp/user/detail.jsp作为视图。 定制Spring MVC的初始化123456789spring.mvc.async.request-timeout= # 异步请求超时时间（单位毫秒）spring.mvc.contentnegotiation.favor-parameter=false # 是否使用请求参数spring.mvc.date-format= # 日期格式配置，如yyyy-MM-ddspring.mvc.favicon.enabled=false #Spring MVC 图标是否启用spring.mvc.formcontent.filter.enabled=true # Servlet 规范要求表格数据可用于HTTP POST而不是HTTP PUT或PATCH请求，这个选项将使得过滤器拦截HTTP PUT和PATCH，切内容类型是application/x-www-form-urlencoded的请求，并且将其转换为POST请求spring.mvc.ignore-default-model-on-redirect=true # 如果配置了default，那么她就会忽略重定向的场景spring.mvc.servlet.load-on-startup=1 # 启用Spring Web服务Servlet的有限顺序配置spring.mvc.static-path-pattern= /** # 指定静态资源路径spring.mvc.throw-exception-if-no-handler-found=false # 如果请求找不到处理器，是否抛出NoHandlerFoundException异常 Spring MVC实例]]></content>
  </entry>
  <entry>
    <title><![CDATA[第8章 文档数据库MongoDB]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%AC%AC8%E7%AB%A0-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB%2F</url>
    <content type="text"><![CDATA[文档数据库——MongoDB前面用到Redis美妙执行10万次以上操作，熟读远超数据库，可以极大提高互联网系统的性能，但是它有一些致命的缺陷，其中最为严重的是计算功能十分有限，例如，在一个10W数量的List中，我只是需要满足条件的元素在Redis中，使用集合或者列表，你只是先把元素 去除，然后才能通过条件筛选一格格得到你想要的数据，这显示存在比较大的问题。这时你可能想到通过Lua脚本去完善，当然这也是可以的，知识说这样对于开发者工作量就大大增加了。对于那些需要缓存而且经常需要统计、分析和查询的数据，对于Redis这样简单的NoSQL不是那么便捷，然而MongoDB就能满足上面的操作，可统计、按条件查询和分析的数据库，它是最接近关系数据库的NoSQLMongoDB在负载高时，可以添加更多的节点，保证服务器性能，MongoDB的目的是为了Web应用提供可扩展的高性能数据存储解决方案。MongoDB将数据存储为一个文档，数据结构由键值（key-value）对组成，这里MongoDB文档类似于JSON数据集，所以很容易转化为Java POJO对象或者JavaScript对象，这些字段值还可以包含其他文档、数组及文档数组，例如我们完全可以存储下这个JSON123456789&#123; "id":1, "note":"张三是个好同志", "user_name":"张三", "role":[ &#123;id:1,role_name:"高级工程师"&#125;, &#123;id:2,role_name:"高级项目经理"&#125; ]&#125; 这个文档很接近JSON数据集，去除这个文档可以直接映射为POJO，使用上很方便，与Redis一样，Spring Boot的配置文件也提供了许多关于MongoDB的配置，以方便我们的配置。不过这一切需要引入Spring Boot关于MongoDB的starter，领推荐引入阿里巴巴开发的fastjson的开发包，代码如下1234567891011&lt;!--MongoDB--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.59&lt;/version&gt;&lt;/dependency&gt; 配置MongoDB一旦引入关于spring-boot-starter-data-mongodb的依赖，就意味着Spring Boot已经提供了关于MongoDB的配置，也有了默认的可配置项，其默认配置清单如下12345678910spring.data.mongodb.authentication-database= # 用于签名的MongoDB数据库spring.data.mongdb.database=test # 数据库名称spring.data.mongdb.field-naming-strategy # 使用字段名策略spring.data.mongdb.grid-fs-database= # GridFs（网格文件）数据库名称spring.data.mongdb.host=localhost # MongoDB服务器，不能设置为URIspring.data.mongdb.password= # MongoDB服务器用户密码，不能设置为URIspring.data.mongdb.port= # MongoDB服务端端口，不能设置为URIspring.data.mongdb.repositories.type = auto # 是否启用MongoDB关于JPA规范的编程spring.data.mongdb.uri=mongodb://localhost/test # MongoDB默认URIspring.data.mongdb.username= # MongdoDB服务器用户名，不能设置为URI 因为有了默认的配置，在默认配置机器不存在MongoDB服务器时会出现报错，因此往往需要加入自己的配置，下面是本章开发的配置123456# MongoDBspring.data.mongodb.host=127.0.0.1spring.data.mongodb.username=springspring.data.mongodb.password=123456spring.data.mongodb.port=27017spring.data.mongodb.database=springboot 有了这些配置Spring Boot就会创建关于MongoDB的Spring Bean，如下|Bean类型|描述||:-:|:-||MongoClient|MongoDB客户端||MongoProperties|SpringBoot关于MongoDB的自动配置属性||MongoDataAutoConfiguration|Spring Boot关于MongoDB的自动配置类||SimpleMongoDBFactory|简单的MongoDB的工厂，由它生成MongoDB的绘画，可ton过属性spring.data.mongodb.grid-fs-database的配置转变为GridFsMongoDbFactory||MongoTemplate|MongoDB的操作模板，在Spring中我们主要通过它对MongoDB进行操作||MappingMongoConvert|关于MongoDB的类型转换器||MongoMapppingContext|MongoDB关于Java实体的映射内容配置||CustomConversions|自定义类型转换器||MongoRepositoriesAutoConfiguration|MongoDB关于仓库的自动配置||GeoJsonConfiguration|MongoDB关于地理位置JSON配置| 使用MongoTemplate实例搭建开发环境 首先创建一个POJO，代码如下123456789101112131415161718192021222324252627package com.xyd.mc.demo.mongodb.pojo;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import org.springframework.data.mongodb.core.mapping.Field;import java.io.Serializable;//标识为MongoDB文档@Documentpublic class MongoDB implements Serializable &#123; private static final long serialVersionUID = 4308441919235697629L; //MongoDB文档编号，主键 @Id private Long id; //MongoDB中使用user_name保存属性 @Field("user_name") private String userName; private String note; //角色列表 private List&lt;Role&gt; roles; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第7章 使用性能利器Redis]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%AC%AC7%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8Redis%2F</url>
    <content type="text"><![CDATA[使用性能利器Redis要使用Redis，需要先加入Redis依赖，代码如下12345678910111213141516&lt;!--Redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入Redis的客户端驱动jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 这样我们就引入了Spring对Redis的starter，只是在默认的情况下，spring-boot-starter-data-redis会依赖Lettuce的Redis客户端驱动，一般项目中我们会使用Jedis，所以代码中使用元素将依赖排除，然后再引入Jedis的依赖 在Spring Boot中配置和使用Redis在Spring Boot中配置Redis只需要在配置文件application.properties中加入如下代码1234567891011#Redisspring.redis.jedis.pool.min-idle=5spring.redis.jedis.pool.max-active=10spring.redis.jedis.pool.max-idle=10spring.redis.jedis.pool.max-wait=2000ms#配置Redis服务器属性spring.redis.port=6379spring.redis.host=127.0.0.1spring.redis.password=123456#Redis连接超时时间，单位毫秒spring.redis.timeout=1000ms RedisTemplate会默认使用JdkSerializationRedisSerializer进行序列化键值，这样便能够存储在Redis服务器中。如果这样Redis服务器存入的便是一个经过序列化后的特殊字符串，有时候对于我们跟踪并不是很友好。如果我们在Redis只是支持字符串，并不能支持Java对象存储。为了克服这个问题，可以通过设置RedisTemplate的序列化来处理。下面我们在Spring Boot中配置Redis的启动文件中修改RedisTemplate的序列化器，代码如下1234567891011121314151617181920212223public class McApplication &#123; //注入RedisTemplate @Autowired private RedisTemplate redisTemplate; //定义自定义后初始化方法 @PostConstruct public void init()&#123; initRedisTemplate(); &#125; //设置RedisTemplate的序列化器 private void initRedisTemplate()&#123; RedisSerializer stringSerializer = redisTemplate.getStringSerializer(); redisTemplate.setKeySerializer(stringSerializer); redisTemplate.setHashKeySerializer(stringSerializer); &#125; public static void main(String[] args) &#123; SpringApplication.run(McApplication.class, args); &#125;&#125; 首先通过@Autowired注入由Spring Boot根据配置生成的RedisTemplate对象，然后利用Spring Bean生命周期的特性使用注解@PostConstruct自定义后初始化方法。在这个方法里，把RedisTemplate的键序列化器修改为StringRedisSerializer。RedisTemplate中默认的定义了一个StringRedisSerializer对象，所以不需要创建新的，直接从中取，然后把RedisTemplate关于键和散列数据类型的field都修改为使用StringRedisSerializer进行序列化，这样我们在Redis服务器上得到的键和散列的field就都可以字符串存储了 操作Redis数据类型首先简单介绍下RedisTemplate的使用 操作字符串和hash数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.xyd.mc.demo.redis.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.BoundHashOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import redis.clients.jedis.Jedis;import java.util.HashMap;import java.util.Map;@Controller@RequestMapping("redis")public class RedisController &#123; @Autowired private RedisTemplate redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; @RequestMapping("/stringAndHash") @ResponseBody public Map&lt;String,Object&gt; stringAndHash()&#123; redisTemplate.opsForValue().set("key1","value1"); //这里使用了JDK的序列化，所以Redis保存时不是整数，不能运算 redisTemplate.opsForValue().set("int_key","1"); stringRedisTemplate.opsForValue().set("int","1"); //使用运算 stringRedisTemplate.opsForValue().increment("int",1); //对int减一（书上说的可能比较早了，现在是支持减一操作的） stringRedisTemplate.opsForValue().decrement("int"); //获取底层Hedis连接 Jedis jedis = (Jedis) stringRedisTemplate.getConnectionFactory().getConnection().getNativeConnection(); //减1操作，这个命令RedisTemplate不支持，所以我们先获取底层的连接再操作 jedis.decr("int"); Map&lt;String,String&gt; hash = new HashMap&lt;&gt;(); hash.put("field1","value1"); hash.put("field2","value2"); //存入一个散列数据类型 stringRedisTemplate.opsForHash().putAll("hash",hash); //新增一个字段 stringRedisTemplate.opsForHash().put("hash","field3","value3"); //绑定散列操作的key，这样可以连续对同一个散列数据类型进行操作 BoundHashOperations hashOps = stringRedisTemplate.boundHashOps("hash"); //输出两个字段 hashOps.delete("field1","field2"); //新增一个字段 hashOps.put("field4","value4"); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map; &#125;&#125; 这里@Autowired注入了Spring Boot为我们自动初始化的RediTemplate和StringRedisTemplate对象。看到testStringAndHash方法，首先存入一个key1的数据，然后是init_key，但是int_key存入Redis服务器中，因为采用了JDK序列化，所以Redis服务器中她不是证书，而是一个被JDK序列化器序列化后的二进制字符串，是没有办法使用Redis命令进行运算的。为了解决这个问题，这里使用StringRedisTemplate对象保存一个int的证书，这样就能够运算了，接着进行加一运算，但是因为RedisTemplate并不支持底层所有的Redis命令，所以这里现货区了原始的Redis连接的Jedis对象，用它来做减一操作。然后是操作散列数据类型，在插入多个散列的field时，可采用Map，然后为了方便对同一个数据操作，这里代码还获取了BoundHashOperations对象进行操作，这样对同一个数据操作就方便许多了。 操作列表数据列表数据也是常用的数据类型，在Redis中列表是一种链表结构，这就意味着查询性能不高，而增删节点的性能高。在Redis中存在从左到右的操作，为了方便测试，我们在上面的代码中加入如下代码1234567891011121314151617181920212223242526272829303132/** * @Description: stringRedisTemplate操作链表 * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/10 */@RequestMapping("/list")@ResponseBodypublic Map&lt;String,Object&gt; list()&#123; //插入两个列表，注意他们在链表的顺序 //链表从左到右顺序为V10,V8,V6,V4,V2 stringRedisTemplate.opsForList().leftPushAll("list1","v2","v4","v6","v8","v10"); //链表从左到右的顺序为v1,v2,v3,v4,v5,v6 stringRedisTemplate.opsForList().rightPushAll("list2","v1","v2","v3","v4","v5","v6"); //绑定list2链表操作 BoundListOperations boundListOperations = stringRedisTemplate.boundListOps("list2"); //从右边弹出一个成员 Object result1 = boundListOperations.rightPop(); //获取定位元素，Redis从0开始计算，这里值为v2 Object result2 = boundListOperations.index(1); //从左边插入链表 boundListOperations.leftPush("v0"); //求链表长度 Long size = boundListOperations.size(); //求链表下标区间成员，整个链表下标范围为0到size-1，这里不取最后一个元素 List elements = boundListOperations.range(0,size-2); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 上述操作是基于StringRedisTemplate的，所以保存到Redis服务器都是字符串类型，这里有两点需要注意。首先是列表元素的顺序问题，是从左到右还是从右到左，这是容易弄糊涂的问题，其次是下标，在Redis中是以0开始的，这与Java数组类似。 操作集合数据在Redis中是不允许成员重复的，她在数据结构上是一个散列表的结构，所以对于它而言是无序的，对于两个或者以上的集合，Redis还提供了交集、并集和差集的运算。123456789101112131415161718192021222324252627282930313233343536373839/** * @Description: stringRedisTemplate操作集合 * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/10 */@RequestMapping("/set")@ResponseBodypublic Map&lt;String,Object&gt; set()&#123; //注意：这里v1重复两次，因为集合不允许重复，所以只是插入5个成员到集合中 stringRedisTemplate.opsForSet().add("set1","v1","v1","v2","v3","v4","v5"); stringRedisTemplate.opsForSet().add("set2","v2","v4","v6","v8"); //绑定set1集合操作 BoundSetOperations boundSetOperations = stringRedisTemplate.boundSetOps("set1"); //增加两个元素 boundSetOperations.add("v6","v7"); //删除两个元素 boundSetOperations.remove("v1","v7"); //返回所有元素 Set set1 = boundSetOperations.members(); //求成员数 Long size = boundSetOperations.size(); //求set1和set2交集 Set inter = boundSetOperations.intersect("set2"); //求交集，并且用新集合inter保存 boundSetOperations.intersectAndStore("set2","inter"); //求差集 Set diff = boundSetOperations.diff("set2"); //求差集，并且用新集合diff保存 boundSetOperations.diffAndStore("set2","diff"); //求并集 Set union = boundSetOperations.union("set2"); //求并集，并且用新集合union保存 boundSetOperations.unionAndStore("set2","union"); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 这里在添加几个set1的时候，存在两个V1一样的元素，因为集合不允许重复，所以实际上再集合只算是一个元素。然后可以看到对集合各种操作，在最后还有交集、差集和并集的操作，这些是集合最常用的操作。 操作有序集合有序集合常用作网站排名，有序集合和无序集合差异往往不大，也是一种散列表存储的方式，同时它的有序性只是靠她在数据结构中增加一个属性——score（分数）得以支持，为了支持这个变化，Spring提供TypeTuple接口，定义了两个方法，并且还提供了默认的实现类DefaultTypedTuple，在TypedTupl的接口设计中，value是保存有序集合的值，score是保存分数，Redis是使用分数来完成集合的排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @Description: 操作有序集合 * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/10 */@RequestMapping("/zset")@ResponseBodypublic Map&lt;String,Object&gt; zset()&#123; Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = new HashSet&lt;&gt;(); for(int i=0; i&lt;9; i++)&#123; //分数 double score = i*0.1; //创建一个TypedTuple对象，存入值和分数 ZSetOperations.TypedTuple&lt;String&gt; typedTuple = new DefaultTypedTuple&lt;&gt;("value"+i,score); typedTuples.add(typedTuple); &#125; //往有序集合插入元素 stringRedisTemplate.opsForZSet().add("zset1",typedTuples); //绑定zset1有序集合操作 BoundZSetOperations&lt;String,String&gt; zSetOperations = stringRedisTemplate.boundZSetOps("zset1"); //增加一个元素 zSetOperations.add("value10",0.26); Set&lt;String&gt; setRange = zSetOperations.range(1,6); //按分数排序获取有序集合 Set&lt;String&gt; setScore = zSetOperations.rangeByScore(0.2,0.6); //定义值范围 RedisZSetCommands.Range range = new RedisZSetCommands.Range(); range.gt("value3");//大于value3 //range.gte("value3");//大于等于value3 //range.lt("value8");//小于value8 range.lte("value8");//小于等于value8 //按值排序，请注意这个排序是按字符串排序 Set&lt;String&gt; setLex = zSetOperations.rangeByLex(range); //删除元素 zSetOperations.remove("value9","value2"); //求分数 Double score = zSetOperations.score("value8"); //在下标区间下，按分数排序，同时返回value和score Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; rangeSet = zSetOperations.rangeWithScores(1,6); //在分数区间下，按分数排序，同时返回value和score Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; scoreSet = zSetOperations.rangeByScoreWithScores(1,6); //按从大到小排序 Set&lt;String&gt; reverseSet = zSetOperations.reverseRange(2,8); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 代码中使用TypedTuple保存有序集合的元素，在默认的情况下，有序集合是从小到大地排序的，按下表、分数和值进行排序获取有序集合的元素，或者联通分数一期返回，有时候还可以进行从大到小的排序，只是在使用值排序时，我们可以使用Spring为我们创建的Range类，他可以定义值的范围 Redis的一些特殊用法Redis支持事务、流水线、发布订阅和Lua语言等功能，这些也是Redis常用的功能。在高并发的场景下，往往我们需要保证数据的一致性，这时考虑使用Redis事务或者利用Redis执行的原子性来达到数据一致性的目的，在需要大批量执行Redis命令的时候，我们可以使用流水线来执行命令，这样可以极大的提升Redis执行速度。 使用Redis事务在Redis中使用事务，通常的命令组合是watch…multi…exec，也就是要在一个Redis连接中执行多个命令，这时我们考虑使用SessionCallback接口达到这个目的。 watch：监控Redis的一些键 multi：开始事务，开始后不会马上执行，而是放在一个队列里，所以此时调用Redis的命令，结果都是返回null exec：执行事务，只是在执行前会判断被watch监控的Redis的键的数据是否发生变化，如果他认为发生了变化，那么Redis就会取消事务，否则就会执行事务，Redis在执行事务时，要么全部执行，要么全部不执行，而且不会被其他客户端打断 下面测试这样的一个过程，只是这里需要保证RedisTemplate的键和散列结构的field使用字符串序列化器123456789101112131415161718192021222324252627282930313233343536/** * @Description: 使用Redis事务机制 * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/10 */@RequestMapping("/multi")@ResponseBodypublic Map&lt;String,Object&gt; multi()&#123; redisTemplate.opsForValue().set("key1","value1"); List list = (List) redisTemplate.execute((RedisOperations operations) -&gt; &#123; //设置要监控key1 operations.watch("key1"); //开启事务，在exec命令执行前，全部都只是进入队列 operations.multi(); operations.opsForValue().set("key2","value2"); //operations.opsForValue().increment("key",1);//① //获取值降为null，因为redis只是把命令放入到队列 Object value2 = operations.opsForValue().get("key2"); System.out.println("命令在队列，所以value为null【"+value2+"】"); operations.opsForValue().set("key3","value3"); Object value3 = operations.opsForValue().get("key3"); System.out.println("命令在队列，所以value为null【"+value3+"】"); //执行exec命令，将先判断key1是否在监控后被修改过，如果是则不执行事务，否则执行事务 return operations.exec();//② &#125;); System.out.println(list); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 为了揭示Redis事务的特性，我们对这段代码做一下两种测试 现在Redis客户端情况key2和key3两个键的数据，然后在②处设置断点，在调试的环境下让请求到断点，此时在Redis修改key1的值，然后跳过断点，在请求完成后再Redis上查询key2和key3的值，可以发现key2、key3返回的都是空（nil），因为程序中先使得Redis的watch命令监控了key1的值，而后的multi让之后的命令进入队列，而在exec方法运行前我们修改了key1，根据Redis事务的规则，她在exec方法后会探测key1是否被修改过，如果没有则会执行事务，否则就取消事务，所以key2和key3没有被保存到Redis服务器中 继续把key2和key3两个值清空，把①处的注释取消，让代码可以运行，因为key1是一个字符串，所以这里代码是对字符串加一，这显然是不能运算的。同样的，我们运行这段代码后，可以看到服务器抛出了异常，然后我们去Redis服务查询key2和key3，我们可以看到它们已经有值了。这是Redis事务和数据库事务不一样，对于Redis事务是先让命令进入队列，所以一开始他并没有检测这个加一命令是否能够成功，只是exec命令执行的时候，才发现错误，对于出错的命令Redis只是报出错误，而错误后面的命令已久被执行，所以key2和key3都存在数据。为了克服这个问题，一般我们要在执行Redis事务前，要严格地检查数据，以避免这样的情况发生。 使用Redis流水线在系统的默认情况，Redis客户端是一条条发送给Redis服务器，这样显然性能不高。早关系数据库我们可以使用批量，这也是只有需要执行SQL时，才一次性地发送所有SQL去执行，这样性能就提高了许多。对于Redis也是可以的，这边事流水线（pipeline）技术，使用流水线后就可以大幅度的在需要执行很多命令时提升Redis的性能下面我们使用Redis流水线技术测试10万次读取的功能，代码如下1234567891011121314151617181920212223242526272829/** * @Description: 使用Redis流水线测试性能 * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/10 */@RequestMapping("/pipeline")@ResponseBodypublic Map&lt;String,Object&gt; pipeline()&#123; Long start = System.currentTimeMillis(); List list = (List)redisTemplate.executePipelined((RedisOperations operations)-&gt;&#123; for(int i=1; i&lt;=100000; i++)&#123; operations.opsForValue().set("pipeline_"+i,"value_"+i); String value = (String)operations.opsForValue().get("pipeline_"+i); if(i == 100000)&#123; System.out.println("命令指示进入队列，所以值为空【"+value+"】"); &#125; &#125; return null; &#125;); Long end = System.currentTimeMillis(); System.out.println("耗时:"+(end-start)+"毫秒。"); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 这里沿用SessionCallback接口执行写入和读出各10万次Redis，只是修改为了Lamdba表达式而已。测试中，10万次读写基本保持200-600ms，速度十分快。在使用非流水线的情况下，美妙大概执行2-3万条命令，流水线可以提升10倍速度，十分适合大数据量的执行。这里需要注意的是以下两点 这里只是测试，常规情况下一定要考虑内存控件的消耗，他最终返回一个List对象，如果过多的命令执行返回结果保存在List中，显然会内存小号过大，尤其在高并发的网站中就很容易JVM移除异常，这个时候考虑使用迭代的方法执行Redis命令 与实务一样，使用流水线的过程中，所有的命令也只是进入队列而没有执行，所以执行的命令返回也是空 使用Redis发布订阅 Redis消息监听器发布订阅是消息的一种常用模式 。例如，在企业分配任务之后，可以通过邮件、短信或者微信通知到相关的责任人，这就是一种典型的发布订阅模式。首先是Redis提供一个渠道，让消息能够发送到这个渠道上，而多个系统可以监听这个渠道，如短信、微信或者邮件系统都可以监听这个渠道，当一条消息发送到渠道，渠道就会通知它的坚挺着，这样短信、微信和右键系统就能够得到这个渠道给他们的消息了，这些坚挺着会根据自己的需要去处理这个消息，于是我们就可以得到各种各样的通知了。原理如下图所示 为了接收Redis渠道发送过来的消息，我们先定义一个消息监听器（MessageListener）,代码如下1234567891011121314151617181920212223package com.xyd.mc.demo.redis.listener;import org.springframework.data.redis.connection.Message;import org.springframework.data.redis.connection.MessageListener;import org.springframework.stereotype.Component;/** * @project: mc * @description: Redis监听器 * @author: zp * @create: 2019-08-10 18:35 **/ @Componentpublic class RedisMessageListener implements MessageListener &#123; @Override public void onMessage(Message message, byte[] bytes) &#123; //消息体 String body = new String(message.getBody()); //渠道名称 String topic = new String(bytes); System.out.println(body); System.out.println(topic); &#125;&#125; 这里的onMessage方法是得到消息后的处理方法，其中message参数代表Redis发送过来的消息，pattern是渠道名称，onMessage方法是打印了他们的内容。这里因为标注了@Component注解，所以Spring Boot扫描后，会把它自动装配到IoC容器中接着我们在Spring Boot的启动文件中配置其他信息，让系统能够监听Redis的消息，代码如下 监听Redis发布的消息12345678910111213141516171819202122232425262728293031323334353637383940414243//Redis连接工厂@Autowiredprivate RedisConnectionFactory connectionFactory;//Redis消息监听器@Autowiredprivate MessageListener redisMsgListener;//任务池private ThreadPoolTaskScheduler taskScheduler;/** * 创建任务池，运行线程等待处理Redis的消息 * @return */@Beanpublic ThreadPoolTaskScheduler initTaskScheduler()&#123; if(taskScheduler != null)&#123; return taskScheduler; &#125; taskScheduler = new ThreadPoolTaskScheduler(); taskScheduler.setPoolSize(20); return taskScheduler;&#125;/** * 定义Redis的监听容器 * @return 监听容器 */@Beanpublic RedisMessageListenerContainer initRedisContainer()&#123; RedisMessageListenerContainer container = new RedisMessageListenerContainer(); //Redis 连接工厂 container.setConnectionFactory(connectionFactory); //设置运行任务池 container.setTaskExecutor(initTaskScheduler()); //定义监听渠道，名称为topic1 Topic topic = new ChannelTopic("topic1"); //使用监听器监听Redis的消息 container.addMessageListener(redisMsgListener,topic); return container;&#125; 这里RedisTemplate和RedisConnectionFactory对象都是Spring Boot自动创建的，所以这里只是把他们注入进来。然后定义了一个任务池，并设置了任务池的大小为20，这样它将可以运行线程，并进行阻塞，等待Redis消息的传入。接着定义了一个Redis消息，监听的容器RedisMessageListenerContainer，并且网容器设置了Redis连接工厂和指定运行消息的线程池，定义了接收“topic1”渠道的消息，这样系统就可以监听Redis关于topic1渠道的消息了。启动项目后，在Redis的客户端输入命令：1publish topic1 msg 在Spring中，我们也可以使用RedisTemplate来发送消息，例如：1redisTemplate.convertAndSend(channel,messgae); 使用Lua脚本Redis中Lua脚本执行的方式有两种： 直接发送Lua到Redis服务器执行 先把Lua发送给Redis，Redis对Lua脚本缓存，然后返回一个SHA1的32位编码回来，之后需要发送SHA1和相关参数给Redis便可以执行。（这是因为如果Lua脚本比较长的时候，网络会成为瓶颈，但是如果只发32位编码和参数就轻松的多） RedisScript接口定义 getSha1：方法可以得到Redis返回的32位编码 getResultType：获取Lua脚本返回的Java类型 getScriptAsString：返回脚本的字符串，便于观看脚本 执行简单的Lua 12345678910111213141516171819202122232425/** * @Description: 执行简易Lua * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/11 */@RequestMapping("/lua")@ResponseBodypublic Map&lt;String,Object&gt; lua()&#123; DefaultRedisScript&lt;String&gt; rs = new DefaultRedisScript&lt;&gt;(); //设置脚本 rs.setScriptText("return 'Hello Redis'"); //定义返回类型。注意：如果没有这个定义，Spring不会反悔结果 rs.setResultType(String.class); RedisSerializer&lt;String&gt; stringRedisSerializer = redisTemplate.getStringSerializer(); //执行Lua脚本 String str = (String)redisTemplate.execute(rs,stringRedisSerializer,stringRedisSerializer,null); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 首先Lua只是定义了一个简单的字符串，然后就返回了，而返回类型则定义为字符串。这里必须定义返回类型，否则对于Spring不会把脚本执行的结果返回。接着获取了由RedisTemplate自动创建的字符串序列化器，然后使用RedisTemplate的execute方法执行了脚本 执行复杂的Lua脚本下面考虑存在参数的情况，Lua脚本代码如下12345678redis.call('set',KEYS[1], ARGV[1])redis.call('set',KEYS[2], ARGV[2])local str1 = redis.call('get',KEYS[1])local str1 = redis.call('get',KEYS[2])if str1 == str2 thenreturn 1endreturn 0 这里的脚本中使用了两个键去保存两个参数，然后对这两个参数进行比较，如果相等返回1，否则返回0.注意脚本中KEY[1]和KEY[2]的写法，它代表客户端传递的第一个键和第二个键。而ARGV[1]和ARGV[2]则表示客户端传递的第一个和第二个参数1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Description: 执行复杂Lua * @param: [] * @return: java.util.Map&lt;java.lang.String,java.lang.Object&gt; * @Author: zp * @Date: 2019/8/11 */@RequestMapping("/luaComplexScript")@ResponseBodypublic Map&lt;String,Object&gt; luaComplexScript(String key1,String key2,String value1,String value2)&#123; //定义Lua脚本 StringBuffer luaScript = new StringBuffer(); luaScript.append(" redis.call('set',KEYS[1], ARGV[1]) "); luaScript.append(" redis.call('set',KEYS[2], ARGV[2]) "); luaScript.append(" local str1 = redis.call('get',KEYS[1]) "); luaScript.append(" local str1 = redis.call('get',KEYS[2]) "); luaScript.append(" if str1 == str2 then "); luaScript.append(" return 1 "); luaScript.append(" end "); luaScript.append(" return 0 "); System.out.println(luaScript.toString()); //结果返回Long DefaultRedisScript&lt;Long&gt; rs = new DefaultRedisScript&lt;&gt;(); rs.setScriptText(luaScript.toString()); rs.setResultType(Long.class); //采用字符串序列表 RedisSerializer&lt;String&gt; stringRedisSerializer = redisTemplate.getStringSerializer(); //定义key参数 List&lt;String&gt; keyList = new ArrayList&lt;&gt;(); keyList.add(key1); keyList.add(key2); //传递两个参数值，其中第一个序列化器是key的序列化器，第二个序列化器是参数的序列化器 Long result = (Long)redisTemplate.execute(rs,stringRedisSerializer,stringRedisSerializer,keyList,value1,value2); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("success",true); return map;&#125; 这里使用keyList保存了各个键，然后通过Redis的execute方法传递，参数则可以使用可变化的方式传递，切设置了给键和参数的序列化器都是字符串序列化器，这样便能够运行这段脚本了，我们的脚本返回一个数字，这里值得注意的是，因为Java会把证书当做长整型（Long），所以这里返回值设置为Long 使用Spring缓存注解操作Redis为了简化Redis使用，Spring提供了缓存注解，简化了编程过程 缓存管理器和缓存的启用Spring的支持多种缓存管理机制，咱们这里只需设置Redis相关的使用方式，以下列出Spring缓存的配置内容123456789101112spring.cache.cache-name=#如果由底层的缓存管理器支持创建，以逗号分割的列表来缓存名称spring.cache.caffeine.spec=#caffeine缓存配置细节spring.cache.couchbase.expiration=0ms # couchbase缓存超时时间，默认是用不超时spring.cache.ehcache.config= #配置ehcache缓存初始化文件路径spring.cache.infinispan.config=#infinispan缓存配置文件spring.cache.jcache.config= #jcache缓存配置文件spring.cache.jcache.provider= # jcache缓存提供者配置spring.cache.redis.cache-null-values=true#是否允许Redis缓存空值spring.cache.redis.key-prefix= #Redis的键前缀spring.cache.redis.time-to-live=0ms #缓存超时时间戳，配置为0则不设置超时时间spring.cache.redis.user-key-prefix=true #是否启用Redis的键前缀spring.cache,type= #缓存类型，在默认的情况下，Spring会自动根据上下文探测,多个名称可以使用逗号分割 因为知识使用Redis，所以其他的缓存不关注，只是关注和Redis相关的配置，下面在application.properties配置Redis的缓存管理器，代码如下12spring.cache.type=redisspring.cache.cache-names=redisCache 这样就完成了缓存管理器的配置，这里的spring.cache.type配置的是缓存类型为Redis，Spring Boot会自动生成RedisCacheManager对象，而spring.cache.cache-names则是配置缓存名称，为了使用缓存管理器，需要在Spring Boot的配置文件中加入驱动缓存的注解@EnableCacheig，这样就可以驱动Spring缓存机制工作了，代码如下1234567891011@SpringBootApplication(scanBasePackages = &#123;"com.xyd.mc"&#125;)@EntityScan(basePackages = "com.xyd.mc.*.*.pojo")@MapperScan( basePackages = "com.xyd.mc.*", sqlSessionTemplateRef = "sqlSessionTemplate", annotationClass = Repository.class)@EnableCachingpublic class McApplication &#123; ......&#125; 开发缓存注解 首先配置文件，主要配置数据库、MyBatis、Redis、缓存和日志信息，代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243# 数据库配置spring.datasource.url=jdbc:mysql://localhost:3306/spring_boot_chapter5?serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=zhang1989#指定数据源spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.type=org.apache.commons.dbcp2.BasicDataSource#最大等待连接中的数量，设0没有限制spring.datasource.dbcp2.max-idle=10#最大连接活动数spring.datasource.dbcp2.max-total=50#最大等待毫秒数spring.datasource.dbcp2.max-wait-millis=10000#数据库连接池初始化连接数spring.datasource.dbcp2.initial-size=5#Mybatis映射文件通配mybatis.mapper-locations=mapper/*/*/*Mapper.xml#MyBatis扫描别名包和注解Alias连用mybatis.type-aliases-package=com.xyd.mc.*.*.pojo#Redisspring.redis.jedis.pool.min-idle=5spring.redis.jedis.pool.max-active=10spring.redis.jedis.pool.max-idle=10spring.redis.jedis.pool.max-wait=2000ms#配置Redis服务器属性spring.redis.port=6379spring.redis.host=127.0.0.1spring.redis.password=123456#Redis连接超时时间，单位毫秒spring.redis.timeout=1000ms# 缓存配置spring.cache.type=redisspring.cache.cache-names=redisCache#日志配置#logging.level.root=debug#logging.level.org.springframework=debug#logging.level.org.org.mybatis=debug 2.创建一个POJO-User来对应数据库的表，代码如下123456789101112131415package com.xyd.mc.demo.database.pojo;import org.apache.ibatis.type.Alias;import java.io.Serializable;@Alias("user")public class User implements Serializable &#123; private static final long serialVersionUID = 7760614561073458247L; private Long id; private String userName; private String note; /***setter and getter*/&#125; 这个类实现了Serializable接口，说明它是可以进行序列化 为了提供操作，需要设计一个接口来实现MyBatis，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.xyd.mc.demo.database.dao;import com.xyd.mc.demo.database.pojo.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserDao &#123; /** * 获取单个用户 * @param id * @return */ User getUser(Long id); /** * 保存用户 * @param user * @return */ int insertUser(User user); /** * 修改用户 * @param user * @return */ int updateUser(User user); /** * 查询用户，执行MyBatis的参数名称 * @param userName * @param note * @return */ List&lt;User&gt; findUsers(@Param("userName") String userName, @Param("note") String note); /** * 删除用户 * @param id * @return */ int deleteUser(Long id);&#125; 为了配合这个接口一期使用，我们需要使用一个XML来定义SQL、映射关系、参数和返回等信息，代码如下 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xyd.mc.demo.database.dao.UserDao"&gt; &lt;select id="getUser" parameterType="long" resultType="user"&gt; select id, user_name as userName,note from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="user" useGeneratedKeys="true" keyProperty="id"&gt; insert into t_user(user_name,note) value(#&#123;userName&#125;,#&#123;note&#125;) &lt;/insert&gt; &lt;update id="updateUser"&gt; update t_user &lt;set&gt; &lt;if test="userName != null"&gt; user_name = #&#123;userName&#125;,&lt;/if&gt; &lt;if test="note != null"&gt; note = #&#123;note&#125;,&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;select id="findUsers" resultType="user"&gt; select id, user_name as UserName,note from t_user &lt;where&gt; &lt;if test="userName != null"&gt; and user_name = #&#123;userName&#125; &lt;/if&gt; &lt;if test="note != null"&gt; and note = #&#123;note&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;delete id="deleteUser" parameterType="long"&gt; delete from t_user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 为了整合它，我们还需要使用Spring的机制，为此定义一个Spring的服务接口UserService，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xyd.mc.demo.database.service;import com.xyd.mc.demo.database.pojo.User;import java.util.List;public interface UserService &#123; /** * 获取单个用户 * @param id * @return */ public User getUser(Long id); /** * 保存用户 * @param user * @return */ public User insertUser(User user); /** * 修改用户，指定MyBatis的参数名称 * @param id * @param userName * @return */ User updateUserName(Long id,String userName); /** * 查询用户 * @param userName * @param note * @return */ List&lt;User&gt; findUsers(String userName, String note); /** * 删除用户 * @param id * @return */ int deleteUser(Long id);&#125; 这样就定义了Spring服务接口的方法，接着需要实现这个接口，这里我们使用缓存注解，因为UserService的实现类是本节的重要代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.xyd.mc.demo.database.service.impl;import com.xyd.mc.demo.database.dao.UserDao;import com.xyd.mc.demo.database.pojo.User;import com.xyd.mc.demo.database.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; /** * 获取id，取参数id缓存用户 * @param id * @return */ @Override @Transactional(isolation = Isolation.READ_COMMITTED,timeout = 1) //如果能在缓存中通过定义键查询到，直接将缓存中查询到的数据返回，否则执行方法，并将结果保存到缓存 @Cacheable(value="redisCache", key = "'redis_user_'+#id") public User getUser(Long id) &#123; return userDao.getUser(id); &#125; /** * 插入用户，最后MyBatis会回填id，取结果id缓存用户 * @param user * @return */ @Override @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class) @CachePut(value="redisCache", key = "'redis_user_'+#user.id") public User insertUser(User user) &#123; userDao.insertUser(user); return user; &#125; /** * 更新数据后，更新缓存，如果condition配置项使结果返回nul，不缓存 * @param id * @param userName * @return */ @Override @Transactional @CachePut(value="redisCache",condition = "#result != 'null'",key = "'redis_user_'+#id") public User updateUserName(Long id, String userName) &#123; //此处调用getUser方法，该方法缓存注解失效 //所以这里还会执行SQL，将查询到数据库最新数据 User user = this.getUser(id); if(user == null)&#123; return null; &#125; user.setUserName(userName); userDao.updateUser(user); return user; &#125; /** * 命中率低，所以不采用缓存机制 * @param userName * @param note * @return */ @Override @Transactional public List&lt;User&gt; findUsers(String userName, String note) &#123; return userDao.findUsers(userName,note); &#125; /** * 移除缓存 * @param id * @return */ @Override @Transactional @CacheEvict(value = "redisCache",key = "'redis_user_'+#id",beforeInvocation = false) public int deleteUser(Long id) &#123; return userDao.deleteUser(id); &#125;&#125; 注解@CachePut、@Cacheable、@CacheEvict CachePut：将方法结果返回存放到缓存中 Cacheable：从缓存中通过定义的键查询，如果可以查询到数据，则返回，否则执行该方法，返回数据，并且将结果保存到缓存中 CacheEvict：通过定义的键移除缓存，她有一个Boolean类型的配置项beforeInvocation，表示在方法之前或者之后移除缓存，因为默认值为false，所以默认为方法之后将缓存移除其次，读者可以看到三个缓存中都配置了value=”redisCache”，因为在Spring Boot中配置了对应的缓存名称为redisCache，这样它能够引用到对应的缓存，而配置项则是一个Spring EL，很多时候可以看到配置为’redis_user_’+#id，其中#id代表参数，他是通过参数名称来匹配，所以这样配置要求方法存在一个参数且名称为id；在updateUser方法里面我们先调用了getUser方法，因为是更新数据，所以需要慎重。一般我们不轻易相信缓存，因为缓存存在脏读的可能性，这是需要注意得，在需要更新数据时我们往往考虑先从数据库查询出来新数据，然后再进行操作，因此，这里会存在一个误区，认为geUser方法因为存在了注解Cacheable，所以惠存缓存中读取数据，耳聪缓存中读取去更新数据，是一个比较危险的行为，因为、、然后这里的事实是@Cacheable失效了，也就是说updateUserName方法调用getUser方法的逻辑，并不存在读取缓存的可能，每次都会执行SQL查询数据。最后，我们看到findUser，这个方法并没有使用缓存，因为查询结果随着用户给出的查询条件变化而变化，导致命中率很低。对于命中很低的场景，使用缓存并不能有效的提高系统的性能，所以不推荐缓存机制，此外，对于数据量很小号的数据，使用缓存也应该慎重。 接下来创建一个Controller，进行缓存注解的测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.xyd.mc.demo.database.controller;import com.xyd.mc.demo.database.pojo.User;import com.xyd.mc.demo.database.service.UserBatchService;import com.xyd.mc.demo.database.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; @Autowired private UserBatchService userBatchService; @RequestMapping("/getUser") @ResponseBody public User getUser(Long id)&#123; return userService.getUser(id); &#125; @RequestMapping("/insertUser") @ResponseBody public User insertUser(String userName,String note)&#123; User user = new User(); user.setUserName(userName); user.setNote(note); //结果回填主键，返回插入条数 userService.insertUser(user); return user; &#125; @RequestMapping("/findUsers") @ResponseBody public List&lt;User&gt; findUsers(String userName,String note)&#123; return userService.findUsers(userName,note); &#125; @RequestMapping("/updateUserName") @ResponseBody public Map&lt;String,Object&gt; updateUserName(Long id, String userName)&#123; User user = userService.updateUserName(id,userName); boolean flag = user != null; String msg = flag?"更新成功":"更新失败"; return resultMap(flag,msg); &#125; @RequestMapping("/deleteUser") @ResponseBody public Map&lt;String,Object&gt; deleteUser(Long id)&#123; int result = userService.deleteUser(id); boolean flag = result == 1; String msg = flag?"删除成功":"删除失败"; return resultMap(flag,msg); &#125; @RequestMapping("/insertUsers") @ResponseBody public Map&lt;String,Object&gt; insertUsers(String userName1,String note1,String userName2,String note2)&#123; User user1 = new User(); user1.setUserName(userName1); user1.setNote(note1); User user2 = new User(); user2.setUserName(userName2); user2.setNote(note2); List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(user1); users.add(user2); int insertCount = userBatchService.insertUsers(users); Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("success",insertCount&gt;0); result.put("user",users); return result; &#125; private Map&lt;String,Object&gt; resultMap(boolean success,String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("success",success); result.put("msg",msg); return result; &#125;&#125; 接下来需要修改Spring Boot的启动文件驱动缓存机制的运行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.xyd.mc;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.connection.MessageListener;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.listener.ChannelTopic;import org.springframework.data.redis.listener.RedisMessageListenerContainer;import org.springframework.data.redis.listener.Topic;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;import org.springframework.stereotype.Repository;import javax.annotation.PostConstruct;@SpringBootApplication(scanBasePackages = &#123;"com.xyd.mc"&#125;)@EntityScan(basePackages = "com.xyd.mc.*.*.pojo")@MapperScan( basePackages = "com.xyd.mc.*", sqlSessionTemplateRef = "sqlSessionTemplate", annotationClass = Repository.class)@EnableCachingpublic class McApplication &#123; //注入RedisTemplate @Autowired private RedisTemplate redisTemplate; //Redis连接工厂 @Autowired private RedisConnectionFactory connectionFactory; //Redis消息监听器 @Autowired private MessageListener redisMsgListener; //任务池 private ThreadPoolTaskScheduler taskScheduler; /** * 创建任务池，运行线程等待处理Redis的消息 * @return */ @Bean public ThreadPoolTaskScheduler initTaskScheduler()&#123; if(taskScheduler != null)&#123; return taskScheduler; &#125; taskScheduler = new ThreadPoolTaskScheduler(); taskScheduler.setPoolSize(20); return taskScheduler; &#125; /** * 定义Redis的监听容器 * @return 监听容器 */ @Bean public RedisMessageListenerContainer initRedisContainer()&#123; RedisMessageListenerContainer container = new RedisMessageListenerContainer(); //Redis 连接工厂 container.setConnectionFactory(connectionFactory); //设置运行任务池 container.setTaskExecutor(initTaskScheduler()); //定义监听渠道，名称为topic1 Topic topic = new ChannelTopic("topic1"); //使用监听器监听Redis的消息 container.addMessageListener(redisMsgListener,topic); return container; &#125; //定义自定义后初始化方法 @PostConstruct public void init()&#123; initRedisTemplate(); &#125; //设置RedisTemplate的序列化器 private void initRedisTemplate()&#123; RedisSerializer stringSerializer = redisTemplate.getStringSerializer(); redisTemplate.setKeySerializer(stringSerializer); redisTemplate.setHashKeySerializer(stringSerializer); &#125; public static void main(String[] args) &#123; SpringApplication.run(McApplication.class, args); &#125;&#125; 这里定义了MyBatis Mapper的扫描包，并限定了在标注有@Repository的接口才会被扫描，同时使用@EnableCaching驱动Spring的缓存机制运行，并且通过@PostConstruct定义自定义初始化方法去定义RedisTemplate的一些特性运行Spring Boot的启动文件后，通过球球COntroller中的方法，就能够测试缓存注解了。在使用编号1作为参数测试getUser方法后，打开Redis客户端，然后可以查看到对应的缓存信息。Redis机制会使用#{cacheName}:#{key}的形式作为键保存数据，其次对于这个缓存是永远不超时的，这样会带来缓存不会被刷新的问题，这在某些时候会存在刷新不及时的问题，未来我们需要克服这些问题。 缓存注解自调用失效问题Redis注解自调用的时候跟数据库的事务自调用基本一致，都会失效，是因为Spring中AOP是通过动态代理技术实现的 缓存脏数据说明缓存可以使得系统性能大幅度提高，但是也引发了很多问题，其中最为严重的问题时脏数据问题 时刻 动作1 动作2 备注 T1 修改id为1的用户 T2 更新数据库数据 T3 使用key_1为键保存数据 T4 修改id为1的用户 与动作1操作同一数据 T5 更新数据库数据 此时修改数据库数据 T6 使用key_2为键保存数据 这样key1位键的缓存就已经是脏数据 从上表中可以看到T6时刻，因为使用了key_2为键缓存数据，所以会致使动作1以key_1为键的缓存数据为脏数据。这样使用key_1为键读取时，就只能获取脏数据，这只是存在脏数据的可能性之一，还可能存在别的可能，如Redis事务问题，或者其他系统操作而没有刷新Redis缓存等诸多问题。对于数据的读操作，一般而言是允许不是实时数据，如电商网站还存在一些排名榜单，而这个排名往往都不是实时的，会存在延迟，其实对于查询是可以存在延迟的，也就是存在脏数据是允许的。但是如果一个脏数据失踪存在就说不通了，这样会造成数据失真比较痰中。一般对于查询而言，我们可以规定一个时间，让缓存失效，在Redis中可以设置超时时间，当缓存超过超时时间后，则应用不在能够从缓存中获取数据，而只是从数据库中重新获取最新数据，以保证数据失真不至于太大。对于那些要求实时性比较高的数据，我们可以把缓存时间设置的更好一些，这样就会更加频繁的刷新缓存，而不利就是会增加数据的压力，对于那些要求不是很高，则可以使超市时间长一些，这样就可以降低数据库的压力。对于数据的写操作，往往采取的策略就完全不一样，需要谨慎，一般会认为缓存不可信，所以考虑从数据库中先读取最新数据，然后再更新数据，避免将缓存中的脏数据写入数据库，导致出现业务问题。 自定义缓存管理器我们不希望Spring Boot机制带来的键命名方式，也不希望缓存永不超时，这时我们可以自定义缓存管理器。在Spring中，我们有两种方法定制缓存管理器，一种是通过配置消除缓存键的前缀和自定义超时时间的属性来定制生成RedisCacheManager；另一种方法是不采用Spring Boot为我们生成的方式，而是通过自己的代码创建缓存管理器，尤其是当需要比较多自定义的时候，更加推荐采用自定义的代码]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 数据库事务处理]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[首先配置数据库连接配置信息12345678910111213141516spring.datasource.url:jdbc:mysql://localhost:3306/spring_boot_chapter6spring.datasource.username=rootspring.datasource.password=zhang1989# 最大等待连接中的数量，设0位没有限制spring.datasource.tomcat.max-idle=10# 最大连接活动数spring.datasource.tomcat.max-active=50# 最大等待毫秒数，单位为ms，超过时间会处错误信息spring.datasource.tomcat.max-wait=10000# 数据库连接池初始化连接数spring.datasource.tomcat.initial-size=5# 日志配置logging.level.root=DEBUGlogging.level.org.springframework=DEBUGlogging.level.org.mybatis=DEBUG 在编程过程中，会使用编程式事务和声明式事务，大部分情况下会使用声明式事务。 JDBC的数据库事务为了更直观，先从JDBC的代码入手。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.chapter6.service.impl;import com.example.chapter6.service.JdbcService;import org.apache.ibatis.session.TransactionIsolationLevel;import org.springframework.beans.factory.annotation.Autowired;import javax.sql.DataSource;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class JdbcServiceImpl implements JdbcService &#123; @Autowired private DataSource dataSource; @Override public int insertUser(String userName,String note)&#123; Connection conn = null; int result = 0; try &#123; conn = dataSource.getConnection(); conn.setAutoCommit(false); //设置隔离级别 conn.setTransactionIsolation(TransactionIsolationLevel.READ_COMMITTED.getLevel()); //执行SQL PreparedStatement ps = conn.prepareStatement("insert into t_user (user_name,note) values (?,?)"); ps.setString(1,userName); ps.setString(2,note); result = ps.executeUpdate(); //提交事务 conn.commit(); &#125; catch (SQLException e) &#123; //回滚事务 if(conn != null)&#123; try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;finally &#123; //关闭数据库连接 try &#123; if(conn != null &amp;&amp; !conn.isClosed())&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125;&#125; Spring 声明式事务的使用第4章中看到Spring AOP约定，它会把我们的代码织入约定的流程中。同样的，使用AOP思维，执行SQL的代码就可以织入Spring约定的数据库事务的流程中。 Spring声明式数据库事务约定声明事务是使用@Transactional进行标注。这个注解可以标注在类（类中所有非静态方法都将开启事务）或者方法上。在@Transactional中，还允许配置事务的隔离等级和传播行为。如异常类型，从而确定方法发生什么异常下回滚或者发生什么异常下不回滚等。这些配置内容，是在Spring IoC容器在加载时就会将这些配置信息解析出来，然后把这些信息存储到事务订一起中，并且记录哪些类或者方法需要启动事务功能，采取什么策略去执行事务。事务的处理流程如下：12345678910public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override @Transactional public int insertUser(User user)&#123; return userDao.insertUser(user); &#125;&#125; @Transactional注解，标识insertUser方法需要启动事务机制，那么Spring就会织入约定的流程中，这样对于数据库连接关闭事务提交都不需要编写任何代码。 @Transactional的配置项 value和transactionManager：配置一个Spring的事务管理器 timeout：事务允许存在的时间戳，单位为秒 readOnly：事务是否是只读事务； rollbackFor：方法在发生指定异常时回滚，默认是所有异常都回滚 rollbackForClassName：方法在发生指定异常名称时回滚，默认是所有异常都回滚 noRollBackFor：方法在发生指定异常时不回滚，默认是所有异常都回滚 noRollbackForClassName：方法在发生指定异常名称不回滚，默认是所有异常都回滚 propagation：传播行为 isolation：隔离级别Spring事务管理器MyBatis中最常用的事务管理器是DataSourceTransactionManager，在SpringBoot中如果依赖了mybatis-spring-boot-starter之后会自动创建一个DataSourceTransactionManager对象，作为事务管理器，如果依赖于spring-boot-starter-data-jpa，则会自动创建JpaTransactionManager对象作为事务管理器，所以不需要自己创建事务管理器。测试数据库事务首先创建一张表，SQL如下1234567CREATE TABLE `t_user` ( `id` int(12) NOT NULL AUTO_INCREMENT, `user_name` varchar(60) NOT NULL, `sex` int(3) NOT NULL DEFAULT '1', `note` varchar(256) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4; 为了与它映射，需要一个POJO，代码如下12345678910111213package com.example.chapter6.pojo;import org.apache.ibatis.type.Alias;@Alias("user")public class User &#123; private long id; private String userName; private String note;/*****setter and getter*****/&#125; 实现一个MyBatis接口，代码如下123456package com.example.chapter6.dao;import com.example.chapter6.pojo.User;public interface UserDao &#123; User getUser(Long id); int insertUser(User user);&#125; 接着是与这个MyBatis接口文件对应的一个映射文件，代码如下：12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.chapter6.dao.UserDao"&gt; &lt;select id="getUser" parameterType="long" resultType="user"&gt; select id, user_name as userName,note from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt; insert into t_user (user_name,note) value(#&#123;userName&#125;,#&#123;note&#125;) &lt;/insert&gt;&lt;/mapper&gt; 创建UserService和它的实现类UserServiceImpl，然后通过@Transactional启用Spring数据库事务机制接口类123456package com.example.chapter6.service;import com.example.chapter6.pojo.User;public interface UserService &#123; public User getUser(Long id); public int insertUser(User user);&#125; 实现类12345678910111213141516171819202122232425262728package com.example.chapter6.service.impl;import com.example.chapter6.dao.UserDao;import com.example.chapter6.pojo.User;import com.example.chapter6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Transactional;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override @Transactional(isolation = Isolation.READ_COMMITTED,timeout = 1) public User getUser(Long id) &#123; return null; &#125; @Override @Transactional(isolation = Isolation.READ_COMMITTED,timeout = 1) public int insertUser(User user)&#123; return userDao.insertUser(user); &#125;&#125; 测试控制类123456789101112131415161718192021222324252627282930313233343536373839package com.example.chapter6.controller;import com.example.chapter6.pojo.User;import com.example.chapter6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.HashMap;import java.util.Map;@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; //测试获取用户 @RequestMapping(value="/getUser") @ResponseBody public User getUser(Long id)&#123; return userService.getUser(id); &#125; //测试插入用户 @RequestMapping("/insertUser") @ResponseBody public Map&lt;String,Object&gt; insertUser(String userName,String note)&#123; User user = new User(); user.setUserName(userName); user.setNote(note); //结果会回填主键到user中 int update = userService.insertUser(user); Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("success",update == 1); result.put("user",user); return result; &#125;&#125; 下面还需要给SpringBoot配置MyBatis框架的内容，修改application.properties中加入如下代码：12mybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.example.chapter6.pojo 配置完成。最后在SpringBoot启动器中加入如下代码，查看自动创建的事务管理器、SqlsessionFactory和SqlSessionTemplate信息12345678910111213141516171819202122232425262728package com.example.chapter6;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.stereotype.Repository;import javax.annotation.PostConstruct;@MapperScan(basePackages = "com.example.chapter6",annotationClass = Repository.class)@SpringBootApplication(scanBasePackages = "com.example.chapter6")public class Chapter6Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Chapter6Application.class, args); &#125; //注入事务管理器，自动生成的 @Autowired PlatformTransactionManager transactionManager; //使用后初始化方法，观察自动生成的事务管理器 @PostConstruct public void viewTransactionManager()&#123; //启动后加入断点观测 System.out.println(transactionManager.getClass().getName()); &#125;&#125; 隔离级别数据库事务的知识数据库事务具有以下4个基本特征，也是著名的ACID Atomic（原子性）：事务中的操作被视为一个整体的业务单元，这个业务单元中的操作要么全成功，要么全部失败，不会出现部分成功部分是失败的情况 Consistency（一致性）：事务在完成时，必须使所有的数据保持一致状态，在数据库中所有的修改都基于事务，保证了数据的完整性 Isolation（隔离性）：多个线程同时访问同一数据时，会产生丢失更新，通过定义隔离的概念，可以在不同程度上压制丢失更新的发生，这个是重点 Durability（持久性）：事务结束后，所有的数据会固化到一个地方，如保存到磁盘当中详解隔离级别 未提交读未提交读（read uncommited）允许一个事务读取另一个事务未提交的数据，是一种危险的隔离级别，有点并发高，适合对数据一致性无要求但并发量高的场景，最大坏处出现脏读 读写提交读写提交（read commited）隔离级别，一个事务只能读取另一个事务已经提交的数据，不能读取未提交的数据 时刻 事务1 事务2 备注 T0 - - 商品库存初始化为2 T1 读取库存为2 T2 扣减库存 库存为1 T3 扣减库存 库存为1，读取不到事务1未提交的库存数据 T4 提交事务 库存保存为1 T5 回滚事务 因为第一类丢失更新已经克服，所以不会回滚为2 库存为1，结果正确 可重复读可重复读是客服读写提交中出现的不可重复读的现象，因为在读写提交的时候，可能会出现一些值的变化，影响当前事务的执行 串行化（Serializable）是数据库最高的隔离级别，所有的SQL会顺序执行，能够保证数据的一致性 使用合理的隔离级别 项目类型 脏读 不可重复读 幻读 未提交读 √ √ √ 读写提交 × √ √ 可重复读 × × √ 串行化 × × × 配置方法 使用注解的形式进行配置12345@Override@Transactional(isolation = Isolation.SERIALIZABLE,timeout = 1)public int insertUser(User user) &#123; return userDao.insertUser(user);&#125; 上面的代码使用了序列化的隔离来保证数据的一致性，这将阻塞其他的事务进行并发，所以只能运用在地并发又需要数据一致性的场景下，对于高并发下又要保证数据一致性的场景，还需要进行处理 在springboot的配置文件中配置12# dbcp2数据库连接池默认隔离级别spring.datasource.dbcp2.default-transaction-isolation=2 传播行为绝大部分的情况下，数据库事务要么全程共，要么全失败。但实际情况中允许一个批量程序中会处理很多交易，绝大部分交易是可以顺利完成的，但是极少数的交易因为特殊情况不能完成发生异常，这时不能全部回滚，使得那些本完成的交易编程了不能完成，这种情况下当一些交易发生异常，知识回滚那些出现异常的交易，而不是整批量任务在Spring中，当一个方法调用另一个方法时，可以让事务猜去不同的策略工作，如新建事务或者挂起当前事务等，这边是事务的传播行为，上图中批量任务称之为当前事务，当调用单个交易时，称为单个交易的字方法，当前方法调用子方法的时候，让每一个子方法不在当前事务中执行，创建一个新的事务去执行子方法，我们就说当前方法调用子方法的传播行为为新建事务，此外，还可以让子方法在无事务、独立事务中执行，这些取决于业务需求 传播行为定义在Spring事务机制中对数据存在7种传播行为，它是通过枚举类Propagation定义的，下面加粗的是常用的几种传播行为 REQUIRED:需要事务，默认传播行为，如果当前存在事务，就沿用当前事务，否则新建一个事务运行子方法 SUPPORT：支持事务，如果当前存在事务，沿用当前事务，不存在，则继续采用无事务的方法执行子方法 MANDATORY：必须使用事务，如果当前没有事务，则会抛出异常，如果当前存在事务，沿用当前事务 REQUIRES_NEW：无论当前是否存在，都创建新事务运行方法，这样事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立 NOT_SUPPORTED：不支持事务，当前存在事务时，挂起事务，运行方法 NEVER：不支持事务，如果当前方法存在事务，则抛出异常，否则继续使用无事务机制运行 NESTED：在当前方法方法调用子方法时，如果子方法发生异常，只回滚子方法执行过的SQL，而不回滚当前方法的事务 测试传播行为下面针对REQUIRED,REQUIRES_NEW,NESTED3种最常用的传播行为进行测试。 REQUIRED创建一个接口UserBatchService和他的实现类UserBatchServiceImpl，代码如下 12345678package com.xyd.mc.demo.database.service;import com.xyd.mc.demo.database.pojo.User;import java.util.List;public interface UserBatchService &#123; public int insertUsers(List&lt;User&gt; users);&#125; 12345678910111213141516171819package com.xyd.mc.demo.database.service.impl;/****imports****/@Servicepublic class UserBatchServiceBatchImpl implements UserBatchService &#123; @Autowired private UserService userService; @Override @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public int insertUsers(List&lt;User&gt; users)&#123; int count = 0; for(User user: users)&#123; //调用子方法，使用@Transactional定义的传播行为 count += userService.insertUser(user); &#125; return count; &#125;&#125; 这里使用insertUser方法，只是insertUser方法中没有定义传播行为。按照之前的论述，会采用REQUIRED，也就是沿用当前的事务，所以它将与insertUsers方法使用同一事务，下面是Controller中的方法12345678910111213141516171819202122@RequestMapping("/insertUsers")@ResponseBodypublic Map&lt;String,Object&gt; insertUsers(String userName1,String note1,String userName2,String note2)&#123; User user1 = new User(); user1.setUserName(userName1); user1.setNote(note1); User user2 = new User(); user2.setUserName(userName2); user2.setNote(note2); List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(user1); users.add(user2); int insertCount = userBatchService.insertUsers(users); Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("success",insertCount&gt;0); result.put("user",users); return result;&#125; 这样我们就可以通过请求这个方法来测试用户的批量插入，在浏览器中输入http://localhost:8080/user/insertUsers?userName1=username_1&amp;note1=note_1&amp;userName2=username_2&amp;note2=note_2，可观察后台日志log123Participating in existing transaction.....Participating in existing transaction 通过上面我们可以看到是沿用了当前事务 REQUIRES_NEW修改子方法的，添加事务回滚，并声明为传播行为为REQUIRED_NEW，代码如下 12345@Override@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRES_NEW)public int insertUser(User user) &#123; return userDao.insertUser(user);&#125; 在浏览器中再输入http://localhost:8080/user/insertUsers?userName1=username_1&amp;note1=note_1&amp;userName2=username_2&amp;note2=note_2进行测试 @Transactional自调用失效问题@Transactional在某些场景下会失效，在上面的测试中，使用了一个UserBatchServiceImpl去调用UserServiceImpl类的方法，那么如果我们不创建UserBatchServiceImpl类，而只是使用UserServiceImpl，在子方法是REQUIRE_NEW的时候，子方法是不会创建新的事务的，也就是会失效这是因为AOP原理是动态代理，在自调用的过程中，是类自身的调用，而不是代理去调用，那么就不会产生AOP，这样就没法将你的代码织入到约定流程中，就失败了，如果非要使用这种方法，可以从Spring IoC容器中获取代理去启用AOP123public class UserServiceimpl implements UserService,ApplicationContextAwareUserService userService = applicationContext.getBean(UserService.class) ;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle导入导出命令及字符集]]></title>
    <url>%2F2019%2F05%2F22%2FOracle%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[概念NLS_LANG参数影响Oracle数据库字符集最重要的NLS_LANG参数，他的格式如下：1NLS_LANG = language_territory.charset 说明： language:指定服务器消息的语言，影响提示信息是中文还是英文 territory:指定服务器的日期和数字格式 charset:指定字符集 操作实例前提两台Linux服务器，数据库版本分别是11g和10g，需要从11g上导出数据库，然后在10g上导入 操作步骤 进入11g导出数据库，命令如下 1exp username/password@serverip:port/instanceid file=home/oracle/instanceid.dmp log=home/oracle/instanceid.log owner=username 说明： username:数据库用户名 password:密码 serverip:服务器IP地址 port:数据库端口号常规是1521 instanceid:数据库实例，常规是orcl或者说自己创建的数据库实例 home/oracle/:导出路径即导出到那里 instanceid.dmp:导出的文件名 log:同理导出文件 owner:导出的用户 导出的时候不需要设置字符集，只需要在导入的时候设置和导出的字符集保持一致即可 确定导出文件的字符集的两种方法 如果能够连接导出的数据库在导出的服务器上执行如下命令select userenv(&#39;language&#39;) from dual;，即可查看导出时的字符集，如下所示，可以看出字符集是ZHS16GBK 12345SQL&gt;select userenv(&apos;language&apos;) from dual;userenv(&apos;language&apos;)-------------------------------------SIMPLIFIED CHINESE_CHINA.ZHS16GBK 只有导出的dmp文件的前提下： 1cat exp.dmp |od -x|head -1|awk &apos;&#123;print $2 $3&#125;&apos;|cut -c 3-6 修改导出文件的数据库版本因为导入的数据库的版本比导出的要低，因此需要修改导出的dmp文件的版本，下载一个AlxcTools软件，操作很简单，自行体验 临时修改字符集Linux修改临时字符集的，只要是退出终端后字符集还会恢复成系统默认的字符集，因此不需要害怕，操作命令如下： 12su - oracleexport NLS_LANG=CHINESE_CHINA.ZHS16GBK 导入数据库文件 1imp username/password@serverip:port/instanceid file=home/oracle/instanceid.dmp log=home/oracle/instanceid.log full=y 至此导入成功 报错处理EXP-00091: Exporting questionable statistics错误问题原因：引起此问题的原因是数据库字符集和操作系统的NLS_LANG不一致导致处理方法： 查询数据库的字符集信息 1SQL&gt; select userenv('language') from dual; 设置字符集 1export NLS_LANG=AMERICAN_AMERICA.WE8ISO8859P1 EXP-00026: conflicting modes specified EXP-00000: Export terminated unsuccessfully这个问题主要是 exp的时候 里面参数发生了冲突。 同时指定了 owner 和 tables 同时指定了 FULL 和tables 同时指定了多个owner和fullowner 表示导出整个用户或者多个用户 而tables表示只导出其中的表 。要么只导出其中的表 要么导出整个用户。不然就会冲突了、 EXP-00000: Message 0 not found; No message file for product=RDBMS, facility=EXP出现这种问题的情况一般是设置的ORACLE_HOME失效了12export ORACLE_HOME="D:\ProgramFiles\Oracle\product\11.2.0\dbhome_1"export ORACLE_SID=orcl]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 访问数据库]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%AC%AC5%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[MyBatis是一个不屏蔽SQL且提供动态SQL，接口式编程和简易SQL绑定POJO的半自动化框架 配置数据源在依赖于Spring Boot的spring-boot-starter-data-jpa后，她就会默认为你配置数据源，这些默认的数据源主要是内存数据库，如h2，hqldb和Derby等 配置自定义数据源以MySQL作为自定义数据源。代码如下：123456789101112131415&lt;!--数据库基础依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql 数据库依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--jdbc依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 下面还需要配置数据库相关信息才能连接到数据库，这里可以配置application.properties配置文件打到配置数据源的效果，代码如下：123456789101112131415spring.datasource.url=jdbc:mysql://localhost:3306/chatper5spring.datasource.username=rootspring.datasource.password=zhang1989# spring.datasource.driver-class-name=com.mysql.jdbc.Driver# 最大等待连接中的数量，设0表示没有限制spring.datasource.tomcat.max-idle=10# 最大连接活动数spring.datasource.tomcat.max-active=50# 最大等待毫秒数，单位为ms，超过时间会处错误信息spring.datasource.tomcat.max-wait=10000# 数据库连接池初始化连接数spring.datasource.tomcat.initial-size=5 这样我们就完成了Spring Boot的数据源配置，虽然上面注释掉了驱动类配置，但是他还是能连接数据源的，这是因为Spring Boot会尽可能去判断数据源是什么类型，然后根据其默认的情况去匹配驱动类。在他不能匹配的情况下，你可以明确的配置它。接着可以根据需要配置数据源的属性，因为上面使用Tomcat自带的数据库连接池上面只是匹配Spring Boot绑定的Tomcat的数据源，有时候我们希望使用的第三方的数据源，例如，我们要使用DBCP数据源，只需要加入DBCP的数据源Maven依赖即可，代码如下：12345&lt;!--DBCP2--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;&lt;/dependency&gt; 这样工程就会把DBCP2对应的jar包加进来，我们只要将application.properties配置文件修改如下即可：1234567891011121314151617spring.datasource.url=jdbc:mysql://localhost:3306/spring_boot_chapter5?serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=zhang1989# spring.datasource.driver-class-name=com.mysql.jdbc.Driver# 指定数据库连接池的类型spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource# 最大等待连接中的数量，设0表示没有限制spring.datasource.dbcp2.max-idle=10# 最大连接活动数spring.datasource.dbcp2.max-total=50# 最大等待毫秒数，单位为ms，超过时间会处错误信息spring.datasource.dbcp2.max-wait-millis=10000# 数据库连接池初始化连接数spring.datasource.dbcp2.initial-size=5 上述代码，我们首先通过spring.datasource.type属性制定了数据库连接池类型，然后再使用spring.datasource.dbcp2.* 去配置数据库连接池的属性，这样Spring Boot就会根据这些属性去配置对应的数据库连接池，从而知道使用的是DBCP数据源。为了验证这个结果，我们新建一个Bean，代码如下：123456789101112131415161718192021222324package com.example.chapter5.db;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import javax.sql.DataSource;//实现Spring Bean生命周期接口ApplicationContextAware@Componentpublic class DataSourceShow implements ApplicationContextAware &#123; ApplicationContext applicationContext = null; //Spring容器会自动调用这个方法，注入Spring IoC容器 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; DataSource dataSource = applicationContext.getBean(DataSource.class); System.out.println("------------------------------"); System.out.println(dataSource.getClass().getName()); System.out.println("------------------------------"); &#125;&#125; 上述代码中实现了接口ApplicationContextAware的方法setApplicationContext()，依照Spring Bean生命周期的规则，在其初始化的时候该方法会被调用，从而获取Spring IoC容器的上下文，这时初始化的时候方法就会被调用，从而Spring IoC容器的上下文，这时通过getBean方法就可以获取到连接池，然后打印出数据连接池的全部限定名，这样就可以知道使用的是那种数据库连接池了。启动Spring Boot程序，就可以发现类似下面的日志。123-------------------------------org.apache.commons.dbcp2.BasicDataSource------------------------------- 显然这里是使用了DBCP2的数据库连接池服务，我们可以使用类似的方法配置第三方数据源，首先创建一个表，代码如下：1234567CREATE TABLE T_USER ( ID INT (12) NOT NULL AUTO_INCREMENT, USER_NAME VARCHAR (60) NOT NULL, SEX INT (3) NOT NULL DEFAULT 1 CHECK (SEX IN(1, 2)), NOTE VARCHAR (256) NULL, PRIMARY KEY (ID)); 接下来创建POJO用户来与这张表进行对应，代码如下1234567891011121314151617181920212223242526272829303132package com.example.chapter5.pojo;import com.example.chapter5.enumeration.SexEnum;public class User &#123; private long id; private String userName; private SexEnum sex;//枚举 private String note; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public SexEnum getSex() &#123; return sex; &#125; public void setSex(SexEnum sex) &#123; this.sex = sex; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125;&#125; SexEnum.java12345678910111213141516171819202122232425262728293031323334package com.example.chapter5.enumeration;public enum SexEnum &#123; MALE(1, "男"), FEMALE(2,"女"); private int id; private String name; SexEnum(int id, String name) &#123; this.id = id; this.name = name; &#125; public static SexEnum getEnumById(int id)&#123; for(SexEnum sex : SexEnum.values())&#123; if(sex.getId() == id)&#123; return sex; &#125; &#125; return null; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 使用JdbcTemplete操作数据库在配置数据源欧，Spring Boot通过其自动配置机制配置好了JdbcTemplete，模板是Spring框架提供的。下面创建一个Service接口，定义一些方法，这样通过它的实现类就可以注入Spring Boot已经为我们配置好的JdbcTemplete，直接就可以使用了。体现了Spring Boot的理念，尽量减少程序员的配置。接口代码如下1234567891011121314151617package com.example.chapter5.service;import com.example.chapter5.pojo.User;import java.util.List;public interface JdbcTmpUserService &#123; public User getUser(Long id); public List&lt;User&gt; findUsers(String userName, String note); public int insertUser(User user); public int updateUser(User user); public int deleteUser(User user);&#125; 实现类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.example.chapter5.service.impl;import com.example.chapter5.enumeration.SexEnum;import com.example.chapter5.pojo.User;import com.example.chapter5.service.JdbcTmpUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Service;import java.sql.ResultSet;import java.util.List;@Servicepublic class JdbcTmpUserServiceImpl implements JdbcTmpUserService &#123; @Autowired private JdbcTemplate jdbcTemplate; //获取映射关系 private RowMapper&lt;User&gt; getUserMapper()&#123; //使用Lambda表达式创建用户映射关系 RowMapper&lt;User&gt; userRowMapper = (ResultSet rs,int rownum) -&gt;&#123; User user = new User(); user.setId(rs.getLong("id")); user.setUserName(rs.getString("user_name")); int sexId = rs.getInt("sex"); SexEnum sex = SexEnum.getEnumById(sexId); user.setSex(sex); user.setNote(rs.getString("note")); return user; &#125;; return userRowMapper; &#125; //获取对象 @Override public User getUser(Long id) &#123; String sql = "select id, user_name, sex, note from t_user where id = ?"; Object[] params = &#123;id&#125;; User user = jdbcTemplate.queryForObject(sql,params,getUserMapper()); return user; &#125; @Override public List&lt;User&gt; findUsers(String userName, String note) &#123; String sql = "select id, user_name, sex, note from t_user where" +" user_name like concat('%',?,'%') and note like concat('%',?,'%')"; Object[] params = &#123;userName,note&#125;; List&lt;User&gt; userList = jdbcTemplate.query(sql,params,getUserMapper()); return userList; &#125; @Override public int insertUser(User user) &#123; String sql = "insert into t_user(user_name,sex,note) values(?,?,?)"; return jdbcTemplate.update(sql,user.getUserName(),user.getSex().getId(),user.getNote()); &#125; @Override public int updateUser(User user) &#123; String sql = "update t_user set user_name = ?, sex=?,note=? where id = ?"; return jdbcTemplate.update(sql,user.getUserName(),user.getSex(),user.getNote(),user.getId()); &#125; @Override public int deleteUser(Long id) &#123; String sql = "delete from t_user where id = ?"; return jdbcTemplate.update(sql,id); &#125;&#125; 对JdbcTemplete的映射关系是需要开发者自己实现RowMapper的接口，这样就可以完成数据库数据到POJO对象的映射了，上面都是比较简单的只执行一条SQL，有时候我们需要执行多条SQL，只是JdbcTemplete是没调用一次便会生成一个数据库连接，例如：12List list = this.jdbcTemplete.query(sql1,rowMapper);this.jdbcTemplete.update(sql2); 从表面上看，这两个SQL都是同一个逻辑完成，二十几从底层的角度看，他们是使用不同的数据库连接完成。当JdbcTemplete执行query方法时，会从数据库连接池分配一条数据库连接资源。当其执行完后，会关闭数据库连接；当执行update时，它又从数据库连接池分配一条新的连接去执行sql。所以这种方式不被推荐。有时候我们希望一个连接里面执行多条SQL，对此我们也可以使用StatementCallback或者ConnectionCallback接口实现回调，代码如下 整合MyBatis框架MyBatis简介官方定义：支持定制化SQL，存储过程以及高级映射的优秀的持久层框架。MyBatis可以对配置和原生Map使用简单的xml或者注解，将接口和Java的POJO映射成数据库中的记录。MyBatis是基于一种SQL到POJO的模型，他需要我们提供SQL映射关系和POJO，对于SQL和POJO的映射关系，他提供自动映射和驼峰映射等，是开发者的开发工作大大减少；它还支持动态SQL，以适应需求的变化。MyBatis的配置文件包括两部分，意识基础配置文件，一个是映射文件。在MyBatis中也可以使用注解来实现映射，只是由于功能和可读性的限制，在实际的企业中使用的比较少。首先在Maven中添加依赖包，代码如下：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; MyBatis的配置MyBatis是一个基于SqlSessionFactory构建的框架，作用是生成SqlSession接口对象，这个接口对象是MyBatis操作的核心。对于mybatis-spring-boot-starter，它会给予我们的配置文件application.properties进行Configuration配置的相关内容。下面是COnfiguration可以配置的内容 properties（属性）：属性文件在实际应用中一般采用Spring进行配置，而不是MyBatis settings（设置）：它的配置将改变MyBatis的底层行为，可以配置映射规则，如自动映射和驼峰映射、执行器类型、缓存等内容 typeAliases：因为使用类全限定名会比较长，所以MyBatis会对常用的类提供默认的别名，此外还允许我们通过typeAliases配置自定义的别名 typeHandlers：这个接口对象是MyBatis操作的核心的重要配置之一，在MyBatis写入和读取数据库的过程中对于不同类型的数据进行自定义转换 objectFactory（对象工厂）：这是一个在MyBatis生成返回POJO时会调用的工厂类。一般我们使用MyBatis默认提供的对象工厂。 plugins（插件）：有时候也叫拦截器，是MyBatis最强大也是最危险的组件，可以修改MyBatis底层实现功能。 enviroments（数据库环境）：可以配置数据库链接内容和事务。一般交由Spring托管 databaseIdProvider（数据库厂商标识）：允许MyBatis配置多类型的数据库支持 mappers（映射器）：Mybatis核心组件，提供SQL和POJO映射关系下面是一个简单的例子，为了使用MyBatis的别名，先修改User类1234567891011121314151617181920package com.example.chapter5.pojo;import com.example.chapter5.enumeration.SexEnum;import org.apache.ibatis.type.Alias;@Alias(value = "user")//MyBatis指定别名public class User &#123; private long id; private String userName; //性别枚举，这里需要使用typeHandler进行转换 private SexEnum sex; private String note; public User() &#123; &#125;/****setter and getter****/&#125; 这里添加的注解@Alias，并且指定的别名为user。同时注意，这里的属性中枚举，在MyBatis体系中，枚举是可以通过typeHander进行转换的，为此开发typeHandler，代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.chapter5.typehandler;import com.example.chapter5.enumeration.SexEnum;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedJdbcTypes;import org.apache.ibatis.type.MappedTypes;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;//声明JdbcType为整形@MappedJdbcTypes(JdbcType.INTEGER)//声明JavaType为SexEnum@MappedTypes(value=SexEnum.class)public class SexTypeHandler extends BaseTypeHandler&lt;SexEnum&gt; &#123; //通过列名读取性别 @Override public SexEnum getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; int sex = resultSet.getInt(s); if(sex != 1 &amp;&amp; sex != 2)&#123; return null; &#125; return SexEnum.getEnumById(sex); &#125; //通过下表读取性别 @Override public SexEnum getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; if(i != 1 &amp;&amp; i != 2)&#123; return null; &#125; return SexEnum.getEnumById(i); &#125; //通过存储过程读取性别 @Override public SexEnum getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; if(i!=1 &amp;&amp; i !=2)&#123; return null; &#125; return SexEnum.getEnumById(i); &#125; //设置非空性别参数 @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, SexEnum sexEnum, JdbcType jdbcType) throws SQLException &#123; preparedStatement.setInt(i,sexEnum.getId()); &#125;&#125; 在MyBatis中对于typeHandler的要求是实现TypeHandler接口，而它自身为了更加方便也通过抽象类BaseTypeHandler实现了TypeHandler接口，所以这里直接集成抽象类BaseTypeHandler就可以了。注解@MappedJdbcTypes生命JdbcType为数据库的整型，@MappedTypes声明JavaType为SexEnum，这样MyBatis即可根据此对对应的数据库进行转换了。为了使这个POJO能够与数据库的数据对应，还需要提供一个映射文件，代码如下123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.chapter5.dao.MyBatisUserDao"&gt; &lt;select id="getUser" parameterType="long" resultType="user"&gt; select id, user_name as userName,sex,note from t_user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 这里先看到元素的namespace属性，它指定一个接口，后文会提供这个接口；接着定义一个元素，它代表一个查询语句，而id属性指代这条SQL，paramterType属性配置为long，则表示是一个长整型参数，resultType指定返回值类型，这里使用user，这是一个别名，在User实体类中有别名，所以这里可以使用，也可以使用全限定名com.example.chapter5.pojo.User；再就是一个SQL语句，这里的列名和POJO的属性是保持一致的。数据库中的字段名是user_name，而POJO的属性名为userName，这里的SQL是通过字段的别名来让他们保持一致的。在默认的情况下，MyBatis会启动自动映射，将SQL中的列映射到POJO上，有时候你也可以启动驼峰映射，这样就可以不用启用别名了，为了启用这个映射，我们还需要一个接口，仅需要一个接口，并不需要任何实现类，他就是元素的namespace属性定义的MyBatisUserDao，代码如下123456789package com.example.chapter5.dao;import com.example.chapter5.pojo.User;import org.springframework.stereotype.Repository;@Repositorypublic interface MyBatisUserDao &#123; public User getUser(Long id);&#125; 注意，这里加了一个注解@Repository。这个注解在将来讨论扫描加载MyBatis接口Bean时是十分有用的，而它的方法getUser和映射文件中定义的查询SQL的id是保持一致的，参数也是如此，这样就能够顶一个查询方法。下面开始配置MyBatis。这里需要对映射文件、POJO的别名和typeHandler进行配置，这样就可以在配置文件application.properties中加入代码如下：1234567891011# Mybatis 映射文件通配mybatis.mapper-locations=classpath:com/example/chapter5/mapper/*.xml# MyBatis扫描别明报，和注解@Alias联动mybatis.type-aliases-package=com.example.chapter5.pojo# 配置typeHandler的扫描宝mybatis.type-handlers-package=com.example.chapter5.typehandler# 日志配置logging.level.root=DEBUGElogging.level.org.springframework=DEBUGElogging.level.org.mybatis=DEBUGE 这里配置了映射文件、别名文件和typeHandler，这样就可以让MyBatis扫描他们了。日志配置为DEBUG，更好地观察测试结果 Spring Boot 整合Mybatis为了方便使用，MyBatis社区在与Spring整合的包中提供了两个类，他们是MapperFactoryBean和MapperScannerConfigurer。他们的区别是MapperFactoryBean是针对一个接口配置，而MapperScannerConfigurer则是扫描装配，也就是提供扫描装配到Spring IOC中。实际上，MyBatis还提供了注解@MapperScan，能够将MyBatis所需要的对应接口扫描装配到Spring IOC容器中，而且MapperScan更简单，常规情况下都是使用MapperScan。先用MapperFactoryBean配置MyBatisUserDao接口，在Spring Boot的启动配置文件中加入如下代码1234567891011@AutowiredSqlSessionFactory sqlSessionFactory = null;//定义一个MyBatis的Mapper接口@Beanpublic MapperFactoryBean&lt;MyBatisUserDao&gt; initMyBatisUserDao()&#123; MapperFactoryBean&lt;MyBatisUserDao&gt; bean = new MapperFactoryBean&lt;&gt;(); bean.setMapperInterface(MyBatisUserDao.class); bean.setSqlSessionFactory(sqlSessionFactory); return bean;&#125; 这里的SqlSessionFactory是Spring Boot自动为我们生成的，可以直接拿来用，然后直接使用MapperFactory来定义Mapper接口，下面开发服务层来装配他，服务接口和实现类如下– 服务接口12345package com.example.chapter5.service;import com.example.chapter5.pojo.User;public interface MyBatisUserService &#123; public User getUser(Long id);&#125; – 实现类12345678910111213141516package com.example.chapter5.service.impl;import com.example.chapter5.dao.MyBatisUserDao;import com.example.chapter5.pojo.User;import com.example.chapter5.service.MyBatisUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class MyBatisUserServiceImpl implements MyBatisUserService &#123; @Autowired private MyBatisUserDao myBatisUserDao; @Override public User getUser(Long id) &#123; return myBatisUserDao.getUser(id); &#125;&#125; 因为在启动配置文件中装配了对应的接口，所以可以@Autowired注入应用。接着实现getUser方法，下面开发控制器，完成接口的测试，代码如下123456789101112131415161718192021package com.example.chapter5.controller;import com.example.chapter5.pojo.User;import com.example.chapter5.service.MyBatisUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/mybatis")public class MyBatisController &#123; @Autowired private MyBatisUserService myBatisUserService; @RequestMapping("/getUser") @ResponseBody public User getUser(Long id)&#123; return myBatisUserService.getUser(id); &#125;&#125; 这样，在浏览器中输入http://localhost:8080/mybatis/getUser?id=1，就可以看到下面的结果显然到这里已经整合了MyBatis，并且成功打印出JSON数据集。然而上面只是一个Dao接口，如果有很多Dao接口，一个一个的定义肯定会比较麻烦，这个时候，就可以使用MapperScannerConfigurer类来定义扫描了，他可以配置包和注解类型进行装配，首先把Spring Boot启动配置文件中的关于Dao注入的代码删掉，然后在其中加入如下代码123456789101112131415161718/** * 配置MyBatis接口扫描 * @return 返回扫描器 */@Beanpublic MapperScannerConfigurer mapperScannerConfig()&#123; //定义扫描实例 MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //加载SqlSessionFactory，SpringBoot会自动生产，SqlSessionFactory实例 mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); //定义扫描的包 mapperScannerConfigurer.setBasePackage("com.example.chapter5.*"); //限定被表位@Repository的接口才被扫描 mapperScannerConfigurer.setAnnotationClass(Repository.class); //通过集成某个接口限制扫描，一般用不多 //mapperScannerConfigurer.setMarkerInterface(......); return mapperScannerConfigurer;&#125; 上述代码中使用MapperScannerConfigurer定义扫描包，这样程序就会去自动扫描对应的恶报，然后还使用了注解限制，限制为@Repository，这就是为什么在上面代码中为什么使用这个注解的原因，这样就可以防止扫描中被错误装配。但是上述还是需要编写代码，而实际上还有更为简单的方式，那就是注解@MapperScan，例如我们可以删除上述关于MapperFactoryBean和MapperScannerConfigurer的相关代码，单独使用@MapperScan，例如可以Spring Boot启动代码可以修改为如下格式1234567891011121314151617181920//定义SpringBoot扫描包路径@SpringBootApplication(scanBasePackages = &#123;"com.example.chapter5"&#125;)//定义JPA接口扫描路径@EnableJpaRepositories(basePackages = "com.example.chapter5.dao")//定义实体Bean扫描包路径@EntityScan(basePackages = "com.example.chapter5.pojo")//定义MyBatis的扫描@MapperScan( //指定扫描包 basePackages = "com.example.chapter5.*", //指定SqlSessionFactory，如果sqlSessionTemplate被指定，则作废 sqlSessionFactoryRef = "sqlSessionFactory", //指定sqlSessionTemplate，将忽略sqlSessionFactory的配置 sqlSessionTemplateRef = "sqlSessionTemplate", //markerInterface = Class.class //限制扫描接口，不常用 annotationClass = Repository.class)public class Chapter5Application &#123; ······&#125; @MapperScan允许我们通过扫描加载MyBatis的Mapper，如果你的Spring Boot项目中不存在多个SqlSessionFactory，那么你可以不用配置sqlSessionFactoryRef，上述代码关于他们的配置是可有可无的，但是如果存在多个时，就需要我们指定了，而且有一点需要注意的：sqlSessionTemplateRef的优先权是大于sqlSessionFactoryRef的，也就是当我们将两者都配置之后，系统会优先选择sqlSessionTemplateRef，而把sqlSessionFactoryRef作废。与我们代码开发一样，指定扫描的包和注解限定，当然也可以选择接口限定，只是这并不常用。这里我们选择使用注解@Repository作为限定，这是一个Spirng对持久层的注解，而事实上MyBatis也提供了一个队Mapper的注解@Mapper，工作中可以二选其一 MyBatis的其他配置下面是我们常用的配置项，代码如下1234567891011121314# Mybatis映射文件通配mybatis.mapper-locations=classpath:com/example/chapter5/mapper/*.xml# Mybatis扫描别名包和注解@Alias连用mybatis.type-aliases-package=com.example.chapter5.pojo#MyBatis配置文件比较复杂的时候，可以使用下面这个mybatis.config-location=.....# 配置MyBatis插件（拦截器）mybatis.configuration.interceptors=...# 配置typeHandler的扫描包mybatis.type-handlers-package=com.example.chapter5.typehandler# 级联延迟加在属性配置mybatis.configuration.aggressive-lazy-loading=...# 执行器，可以配置SIMPLE，REUSE，BATCH，默认SIMPLEmybatis.executor-type=... 上述在Spring Boot中比较常用的Mybatis的配置选项。如果你遇到比较复杂的配置可以通过mybatis.config-location去指定MyBatis本身的配置文件，去完成你需要的复杂配置项；当你的项目不是很复杂的时候，使用Spring Boot提供给你的配置就可以了。下面我们再来讲解Spring Boot集成MyBatis插件的例子。现在存在一个Mybatis的插件MyPlugin，其内容代码清单如下1234567891011121314151617181920212223242526272829303132333435363738package com.example.chapter5.plugin;import java.sql.Connection;import java.util.Properties;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.plugin.Interceptor;import org.apache.ibatis.plugin.Intercepts;import org.apache.ibatis.plugin.Invocation;import org.apache.ibatis.plugin.Plugin;import org.apache.ibatis.plugin.Signature;/**** imports ****/// 定义拦截签名@Intercepts(&#123; @Signature(type = StatementHandler.class, method = "prepare", args = &#123; Connection.class, Integer.class &#125;) &#125;)public class MyPlugin implements Interceptor &#123; Properties properties = null; // 拦截方法逻辑 @Override public Object intercept(Invocation invocation) throws Throwable &#123; System.out.println("插件拦截方法......"); return invocation.proceed(); &#125; // 生成MyBatis拦截器代理对象 @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; // 设置插件属性 @Override public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125; 这样一个MyBatis插件就创建出来了，但是我们没有把它配置到MyBatis配置中，这个时候，我们完全可以通过application.properties文件增加下面的配置12# 配置MyBatis配置文件mybatis.config-location=classpath:mybatis/mybatis-config.xml 这样就制定了MyBatis的配置文件路径。然后我们在对应的位置上创建这个配置文件，其内容如下所述12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;plugins&gt; &lt;plugin interceptor="com.example.chapter5.plugin.MyPlugin"&gt; &lt;property name="key1" value="value1"/&gt; &lt;property name="key2" value="value2"/&gt; &lt;property name="key3" value="value3"/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 这个文件只是配置了MyBatis部分组件，开发者按照自己所需的部分进行自定义即可，因为MyBatis其他的组件Spring Boot已经默认地生产了。当然，如果不希望使用配置文件，也可以使用编码的形式进行处理。如果项目依赖了mybatis-spring-boot-starter后，Spring Boot就会自动地在IoC容器中创建名称为sqlSessionFactory和sqlSessionTemplate的两个Bean。有时候如果配置比较少，也可以使用他们来配置MyBatis的相关内容，这样也是比较方便的，但是需要开发者对MyBatis底层的内容有足够的认知才行。例如我们现在删掉关于MyBatis文件mybatis-config.xml的配置和内容，仅仅使用代码处理，这时我们修改一下Spring Boot的启动文件，代码如下：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 Spring AOP]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%AC%AC4%E7%AB%A0-Spring-AOP%2F</url>
    <content type="text"><![CDATA[约定编程为了便于理解AOP的概念，先来看一个约定编程实例，如果这个实例能弄明白，Spring AOP的概念也很容易理解 约定首先创建一个简单的接口，代码如下：1234package com.example.chapter4.service;public interface HelloService &#123; public void sayHello(String name);&#125; 接口很简单，定义了一个sayHello方法，然后一个变量name，接着创建接口实现类，代码如下1234567891011package com.example.chapter4.service.impl;import com.example.chapter4.service.HelloService;public class HelloServiceImpl implements HelloService &#123; @Override public void sayHello(String name) &#123; if(name == null || "".equals(name.trim()))&#123; throw new RuntimeException("paramter is null!!"); &#125; System.out.println("hello"+name); &#125;&#125; 下面创建一个拦截器，十分简单，只存在几个方法，代码如下：1234567891011121314151617181920212223package com.example.chapter4.intercept;import com.example.chapter4.invoke.Invocation;import java.lang.reflect.InvocationTargetException;public interface Interceptor &#123; //事前方法 boolean before(); //事后方法 void after(); /** * 取代原有的事件方法 * @param invocation * @return 原有事件返回对象 * @throws InvocationTargetException * @throws IllegalAccessException */ Object around(Invocation invocation) throws InvocationTargetException,IllegalAccessException; //是否返回方法。事件没有发生异常执行 void afterReturning(); //事后异常方法，当事件发生异常后执行 void afterThrowing(); //是否使用around方法取代原有方法 boolean userAround();&#125; 下面给出约定，将这些方法织入到流程中。这里首先给出around方法中的参数Invocation对象源码1234567891011121314151617181920212223242526272829303132333435package com.example.chapter4.invoke;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Invocation &#123; private Object[] params; private Method method; private Object target; public Invocation(Object target, Method method,Object[] params)&#123; this.target = target; this.method = method; this.params = params; &#125; //反射方法 public Object proceed() throws InvocationTargetException,IllegalAccessException&#123; return method.invoke(target,params); &#125; public Object[] getParams() &#123; return params; &#125; public void setParams(Object[] params) &#123; this.params = params; &#125; public Method getMethod() &#123; return method; &#125; public void setMethod(Method method) &#123; this.method = method; &#125; public Object getTarget() &#123; return target; &#125; public void setTarget(Object target) &#123; this.target = target; &#125;&#125; 其中的proceed方法，它会以反射的形式去调用原有的方法。接着，你可以根据拦截器（Interceptor）接口的定义开发一个属于自己的拦截器MyInterceptor，代码如下123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.chapter4.intercept;import com.example.chapter4.invoke.Invocation;import java.lang.reflect.InvocationTargetException;public class MyInterceptor implements Interceptor&#123; @Override public boolean before() &#123; System.out.println("before....."); return true; &#125; @Override public void after() &#123; System.out.println("after....."); &#125; @Override public Object around(Invocation invocation) throws InvocationTargetException, IllegalAccessException &#123; System.out.println("around before....."); Object object = invocation.proceed(); System.out.println("around after....."); return object; &#125; @Override public void afterReturning() &#123; System.out.println("afterReturning....."); &#125; @Override public void afterThrowing() &#123; System.out.println("afterThrowing....."); &#125; @Override public boolean userAround() &#123; return true; &#125;&#125; 约定是本节的核心，也是Spring AOP的本质，接下来时ProxyBean的实现代码，该类的作用是实现将服务类和拦截方法织入对应的流程。首先需要理解动态代理模式。其实代理很简单，例如，当你需要采访一个儿童时，首先需要经过他父母的统一，在一些问题上父母也许会替他回答，而对于另一些问题，也许父母觉得不太适合小孩会拒绝掉，显然这时父母就是这名儿童的代理（proxy）。通过代理可以增强或者控制对儿童这个真实对象（target）的访问也就是需要一个代理对象，在JDK中，提供了类Proxy的静态方法newProxyInstance，其内容具体如下1public static Object newProxyInstance(ClassLoader classLoader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler) throws IllegaArgumentException 给与我们来生成一个代理对象（proxy）的方法，她有三个参数 classLoader：类加载器 interfaces：绑定的接口，也就是把代理对象绑定到哪些接口下，可以使多个 invocationHandler：绑定代理对象逻辑实现这里的invocationHandler是一个接口InvocationHandler对象，他定义了一个invoke方法然后通过目标对象（target）、方法（method）和参数（args）就能够你反射方法运行了，于是我们就可以实现ProxyBean的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.example.chapter4.proxy;import com.example.chapter4.intercept.Interceptor;import com.example.chapter4.invoke.Invocation;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyBean implements InvocationHandler &#123; private Object target = null; private Interceptor interceptor = null; /** * 绑定代理对象 * @param target 被代理的对象 * @param interceptor 拦截器 * @return 代理对象 */ public static Object getProxyBean(Object target,Interceptor interceptor)&#123; ProxyBean proxyBean = new ProxyBean(); //保存被代理对象 proxyBean.target = target; //保存拦截器 proxyBean.interceptor = interceptor; //生成代理对象 Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),proxyBean); return proxy; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //异常标识 boolean exceptFlag = false; Invocation invocation = new Invocation(target,method,args); Object retObj = null; try &#123; if(this.interceptor.before())&#123; retObj = this.interceptor.around(invocation); &#125;else&#123; retObj = method.invoke(target,args); &#125; &#125; catch (Exception e) &#123; exceptFlag = true; &#125; this.interceptor.after(); if(exceptFlag)&#123; this.interceptor.afterThrowing(); &#125;else&#123; this.interceptor.afterReturning();; return retObj; &#125; return null; &#125;&#125; 首先，这个ProxyBean实现了InvocationHandler，因此可以定义invoke方法。其中在getBean方法中，我让其生成一个代理对象，并且创建了一个ProxyBean实例保存目标对象（target）和拦截器，为后面调用做好准备。其次，生成一个代理对象，而这个代理对象挂在target实现的接口之下，所以你可以用target对象实现的接口对这个代理对象实现强制转换，并且将这个代理对象的逻辑挂在ProxyBean实例下，这样就完成了目标对象（target）和代理对象（proxy）的绑定。最后，将代理对象返回给调用者。于是测试代码如下12345678910111213141516171819202122232425262728293031package com.example.chapter4;import com.example.chapter4.intercept.MyInterceptor;import com.example.chapter4.proxy.ProxyBean;import com.example.chapter4.service.HelloService;import com.example.chapter4.service.impl.HelloServiceImpl;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class Chapter4ApplicationTests &#123; @Test public void contextLoads() &#123; &#125; @Test public void textProxy()&#123; HelloService helloService = new HelloServiceImpl(); //按照约定获取proxy HelloService proxy = (HelloService) ProxyBean.getProxyBean(helloService,new MyInterceptor()); proxy.sayHello("zhangsan"); System.out.println("\n###############name is null###############"); proxy.sayHello(null); &#125;&#125; 测试代码直接执行，会打印如下：123456789101112before......around before......hellozhangsanaround after......after......afterReturning......###############name is null###############before......around before......after......afterThrowing...... AOP概念通过上面约定编程的例子，可以看到，只要按照一定的规则，就可以将代码织入到事先约定的流程中。实际上Spring AOP也是一种约定流程的编程。在Spring中可以使用多种方式配置AOP，因为Spring Boot采用注解方式，所以为了保持一致，这里就只介绍使用@AspectJ注解的方式 为什么使用AOPAOP最为典型的应用实际就是数据库事务的管控。例如，当我们需要保存一个用户时，可能要连同它的角色信息一并保存到数据库中。于是流程图如下：这里的用户信息和用户角色信息，我们都可以使用面向对象编程（OOP）进行设计，但是它们在数据库事务中的要求是，要么一起成功，要么一起失败，这样OOP就无能为力了。数据库事务毫无疑问是企业级应用关注的核心问题之一，而是用AOP可以很好的解决这些问题。AOP还可以减少大量重复的工作。在Spring流星之前，我们可以使用JDBC代码实现很多的数据库操作，例如，插入一个用户的信息，我们可以用JDBC代码来实现，代码如下UserService.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.chapter4.jdbc;import com.example.chapter4.pojo.User;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class UserService &#123; public int insertUser()&#123; UserDao userDao = new UserDao(); User user = new User(); user.setUsername("user_name_1"); user.setNote("note_1"); Connection conn = null; int result = 0; try &#123; //获取数据库事务连接 Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/chapter3","root","123456"); //非自动提交事务 conn.setAutoCommit(false); result = userDao.insertUser(conn,user); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; try &#123; //回滚事务 conn.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; //释放数据连接资源 if(conn != null)&#123; try&#123; conn.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return result; &#125;&#125; UserDao.java1234567891011121314151617181920package com.example.chapter4.jdbc;import com.example.chapter4.pojo.User;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class UserDao &#123; public int insertUser(Connection conn, User user) throws SQLException&#123; PreparedStatement ps = null; try&#123; ps = conn.prepareStatement("insert into t_user(user_name,note) values(?,?)"); ps.setString(1,user.getUsername()); ps.setString(2,user.getNote()); return ps.executeUpdate(); &#125;finally &#123; ps.close(); &#125; &#125;&#125; 这里可以注意到，我们获取数据库事务连接、事务操作和关闭数据库连接的过程，都需要使用大量的try…catch…finally…语句去操作，这显然存在大量重复的工作。是否可以替换这些没有必要的重复工作呢，答案是肯定的，因为这里存在这一个默认的流程，流程的顺序如下 打开数据库连接，然后对其属性进行设置 执行SQL语句 如果没有异常，则提交事务 如果发生异常，则回滚事务 关闭数据库事务连接如果上面的流程通过约定流程编程设计成如下，会更加方便操作 从上图可以看出，关于数据库的打开和关闭以及事务的提交和回滚都有流程默认给实现，换句话说，你都不需要完成他们，你需要完成的任务是编写SQL这一步而已，然后织入流程中。于是你就可以看到大量在工作中类似基于Spring开发的代码12345678@Autowiredprivate UserDao = null;······@Transactionalpublic int insertUser(User user)&#123; return userDao.insertUser(user);&#125; 当然，这里只是为了让读者知道约定编程的好处，AOP也是一种约定编程，这里可以看到仅仅使用了一个注解@Transactional，表明该方法需要事务运行，没有任何数据库打开和关闭的代码，也没有事务回滚和提交的代码，却实现了数据库资源的打开和关闭、事务回滚和提交。那么Spring是怎么做到的，大志的流程是：Spring帮你把insertUser方法织入到上面图中的流程中，而数据库连接的打开和关闭以及事务管理都由它给你默认实现，也就是它可以大量重复的流程通过约定的方式抽取出来，然后给与默认实现。例如，这里的数据连接失败的打开和释放、事务的处理。 AOP术语和流程Spring AOP是一种基于方法的AOP，他只能应用于方法上。下面是AOP的术语： 连接点（join point）：对应的是具体被拦截的对象，因为Spring只支持方法，所以被拦截的对象往往是指特定的方法，例如上面HelloServiceImpl的sayHello方法就是一个连接点，AOP将通过动态代理技术把它植入对应的流程中。 切点（point cut）：切面不单单应用于单个方法，也可能是多个类的不同方法，这时，可以通过正则式和指示器的规则去定义，从而适配连接点。 通知（advice）：按照约定的刘成霞的方法，分为前置通知（before）、后置通知（after）、环绕通知（around）、事后返回通知（afterReturning）和异常通知（afterThrowing），他会根据约定植入流程 目标对象（traget）：被代理对象，例如约定编程中的HelloServiceImpl实例就是一个目标对象 引入：是指引入新的类和其方法，增强现有Bean的功能 织入：动态的代理技术，为原有服务对象生成代理对象，然后将与切点定义匹配的连接点拦截，并按照约定将各类通知织入约定流程的过程 切面（aspect）：是一个可以定义切点、各类通知和引入的内容，Spring AOP将通过它的信息来增强Bean的功能或者将对应的方法织入流程。上面的描述还是相对抽象，具体见下图： AOP开发详解这里我们采用@AspectJ的注解方式讨论AOP的开发。首先需要确定拦截什么方法，让它织入约定的流程中。 确定连接点设计一个UserService接口，她有一个printUser方法，代码如下：12345package com.example.chapter4.aspect.service;import com.example.chapter4.pojo.User;public interface UserService &#123; public void printUser(User user);&#125; 接着实现一个实现类，代码如下12345678910111213141516package com.example.chapter4.aspect.service.impl;import com.example.chapter4.aspect.service.UserService;import com.example.chapter4.pojo.User;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Override public void printUser(User user) &#123; if(user == null)&#123; throw new RuntimeException("检查用户参数是否为空!"); &#125; System.out.println("id="+user.getId()); System.out.println("username="+user.getUsername()); System.out.println("note="+user.getNote()); &#125;&#125; 这样一个普通的服务的接口和实现类就是先了。下面我们将以printUser方法作为连接点，进行AOP编程 开发切面有了连接点，我们还需要一个切面，通过它可以描述AOP其他的信息，用以描述流程的织入，下面创建一个切面类，代码如下12345678910111213141516171819202122232425package com.example.chapter4.aspect;import org.aspectj.lang.annotation.*;@Aspectpublic class MyAspect &#123; @Before("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.printUser(..))") public void before()&#123; System.out.println("before......"); &#125; @After("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.printUser(..))") public void after()&#123; System.out.println("after......"); &#125; @AfterReturning("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.printUser(..))") public void afterReturning()&#123; System.out.println("afterReturning......"); &#125; @AfterThrowing("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.printUser(..))") public void afterThrowing()&#123; System.out.println("afterThrowing......"); &#125;&#125; 这里需要注意@Aspect作为切面声明，当以@Aspect作为注解时，Spring就会知道这是一个切面，然后我们就可以通过各类注解来定义各类的通知了。折辱代码当中的@Before、@After、@AfterReturning等，通过之前的介绍，应该知道他们就是定义流程中的方法，然后即将由AOP将其织入约定的流程中 切点定义在上面切面的定义中，我们看到了@Before、@After等注解，这个正则表达式的作用是定义什么时候启动AOP，毕竟不是所有功能都需要启用AOP的，也就是SPring会通过正则去匹配，确定对应的连接点开启切面编程，但是上面的代码重复写了同一个正则式，这显然比较冗余，为了克服这个问题，Spring定义了切点（PointCut）的概念，切点的作用就是向Spring描述哪些类的那些方法需要开启AOP编程，上面的代码可以修改为：1234567891011121314151617181920212223242526272829303132package com.example.chapter4.aspect;import org.aspectj.lang.annotation.*;@Aspectpublic class MyAspect &#123; @Pointcut("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.printUser(..))") public void pointCut()&#123; &#125; @Before("pointCut()") public void before()&#123; System.out.println("before......"); &#125; @After("pointCut()") public void after()&#123; System.out.println("after......"); &#125; @AfterReturning("pointCut()") public void afterReturning()&#123; System.out.println("afterReturning......"); &#125; @AfterThrowing("pointCut()") public void afterThrowing()&#123; System.out.println("afterThrowing......"); &#125;&#125; 代码中，使用注解@Point来定义切点，他标注在方法pointCut上，则在后面的通知注解中就可以使用方法名称来定义。下面我们对正则进行分析，首先看下正则式：1execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.printUser(..)) 其中： execution：表示在执行的时候，拦截里面正则匹配的方法； *：表示任意返回类型的方法 com.example.chapter4.aspect.service.impl.UserServiceImpl：制定目标对象的全限定名称 printUser：指定目标对象的方法 (..)：表示任意参数进行匹配 这样Spring就可以通过正则表达式知道你需要对类UserServiceImpl的printUser方法进行AOP增强，她就会将匹配的方法织入到约定流程中，完成AOP编程。对于这个正则表达式而言，他还可以使用AspectJ的指示器，下面是AspectJ关于Spring AOP切点的指示器 项目类型 描述 arg() 限定连接点方法参数 @args() 通过连接点方法参数上的注解进行限定 execution() 用于匹配是连接点的执行方法 this() 限定连接点匹配AOP代理Bean引用为指定的类型 target 目标对象（即被代理对象） @target() 限定目标对象的配置了指定的注解 within 限制连接点匹配指定的类型 @within() 限定连接点带有匹配注解类型 @annotation() 限定带有指定注解的连接点 例如上述服务类对象在Spring IoC容器的名称为userServiceImpl，而我们只想让这个类的pringUser方法织入AOP流程，那么久可以做如下限定： 1execution(* com.example.chapter4.*.*.*.*.printUser(..) &amp;&amp; bean('UserServiceImpl')) 表达式中&amp;&amp;代表并且的意思，而bean中定义的字符串代表对SpringBean名称的限定，这样就限定了具体的类 测试AOP上面完成了连接点、切面和切点的定义，下面要测试AOP，为此需要先搭建一个Web开发环境，开发一个用户控制器（UserController），代码如下 1234567891011121314151617181920212223242526package com.example.chapter4.aspect.controller;import com.example.chapter4.aspect.service.UserService;import com.example.chapter4.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; @RequestMapping("/print") @ResponseBody public User printUser(Long id, String userName, String note)&#123; User user = new User(); user.setId(id); user.setUsername(userName); user.setNote(note); userService.printUser(user); return user; &#125;&#125; 这里通过自动注入UserService服务接口，然后使用它进行用户信息打印，这个方法满足了切点的定义，因此Spring AOP会将其织入到对应的流程中，然后下面配置Spring Boot的配置文件，使其能够运行，代码如下123456789101112131415161718package com.example.chapter4;import com.example.chapter4.aspect.MyAspect;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class Chapter4Application &#123; //定义切面 @Bean(name="myAspect") public MyAspect initMyAspect()&#123; return new MyAspect(); &#125; //启动切面 public static void main(String[] args) &#123; SpringApplication.run(Chapter4Application.class, args); &#125;&#125; 调试运行这段代码，打开浏览器，等待服务启动完成后，输入地址http://localhost:8080/user/print?id=1&amp;userName=user_name_1&amp;note=2323，查看后台的日志，显示的内容如下如果将Controller中的user设置为null，然后传递进去之后，控制台会打印如下内容： 可以看到，无论是否发生异常，后置通知after都会被运行 环绕通知环绕通知（Around）是所有通知中最为强大的通知，强大也意味着难以控制。一般而言，使用它的场景是在你需要大幅度修改原有目标对象的服务逻辑时，否则都尽量使用其他的通知。环绕通知是一个取代原有目标对象方法的通知。当然它也提供了回调原有目标对象方法的能力，我们现在MyAspect中加入环绕通知1234567@Around("pointCut()")public void around(ProceedingJoinPoint jp) throws Throwable&#123; System.out.println("around before......"); //回调目标对象的原有方法 jp.proceed(); System.out.println("around after......");&#125; 这样我们就加入了一个环绕通知，并且在它之前和之后都加入了打印内容，而它拥有一个ProceedingJoinPoint类型的参数。这个参数的对象有一个proceed方法，通过这个方法可以回调原有目标对象的方法，在jp.proceed();上添加断点调试，发现他是一个被Spring封装过的对象，但是我们可以明显看出他是包含原有目标对象的信息，这样就可以通过它的proceed方法回调原有目标对象的方法，测试发现，打印的顺序是不一样的，所以推荐尽量使用其他同志的方式，避免使用环绕通知 引入在测试AOP的时候，我们打印了用户信息，如果用户信息为空，则会抛出异常。事实上，我们可以检测用户信息是否为空，如果为空，不再打印，这样就不会产生异常了。但现有UserService接口没有提供这样的功能，这里假定UserService这个服务并不是自己提供的，而是别人提供的，我们不能修改他，这是Spring还允许增强这个接口的功能，我们可以为这个接口引入新的接口，例如，要引入一个用户检测的接口UserValidator，其定义代码如下：123456package com.example.chapter4.aspect.validator;import com.example.chapter4.pojo.User;public interface UserValidator &#123; //检测用户对象是否为空 public boolean validate(User user);&#125; 接着编写下实现类UserValidatorImpl12345678910package com.example.chapter4.aspect.validator.impl;import com.example.chapter4.aspect.validator.UserValidator;import com.example.chapter4.pojo.User;public class UserValidatorImpl implements UserValidator &#123; @Override public boolean validate(User user) &#123; System.out.println("引入新的接口："+UserValidator.class.getSimpleName()); return user!=null; &#125;&#125; 这样我们通过Spring AOP引入的定义就能够增强UserService接口的功能，这个时候在代码MyAspect中添加如下代码12@DeclareParents(value="com.example.chapter4.aspect.service.impl.UserServiceImpl+",defaultImpl = UserValidatorImpl.class)public UserValidator userValidator; 这里我们看到了一个注解@DeclareParents，他的作用是引入新的类来增强服务，它有两个必须配置的属性value和defaultImpl value:指向你要增强功能的目标对象，这里是要增强UserServiceImpl对象，因此可以看到配置为com.example.chapter4.aspect.service.impl.UserServiceImpl+ defaultImpl:引入增强功能的类，这里配置为UserValidatorImpl，用来提供校验用户是否为空的功能。为了验证它，我们在Controller中加入一个新的方法，代码如下123456789101112131415@RequestMapping("/vp")@ResponseBodypublic User validateAndPring(Long id, String userName, String note)&#123; User user = new User(); user.setId(id); user.setUsername(userName); user.setNote(note); //强制转换 UserValidator userValidator = (UserValidator)userService; //验证用户是否为空 if(userValidator.validate(user))&#123; userService.printUser(user); &#125; return user;&#125; 先把原来的userService对象强制转换成了UserValidator对象，然后就可以使用验证方法去验证用户对象是否为空。使用浏览器打开http://localhost:8080/user/vp?id=1&amp;userName=user_name_1&amp;note=2323，打印日志如下： 通知获取参数在上述通知中，大部分我们没有给通知传递参数。有时候我们希望能够传递参数给通知，我们只需要在切点出加入对应的正则就可以了。当然对于非环绕通知我们还可以使用一个连接点（JoinPoint）类型的参数，通过它也可以获取参数。在MyAspect中加入如下代码12345@Before("pointCut() &amp;&amp; args(user)")public void beforeParam(JoinPoint point,User user)&#123; Object[] args = point.getArgs(); System.out.println("before......");&#125; 正则pointCut()&amp;&amp;args(user)中，在pointCut()表示启用原来定义切点的规则，并且约定将连接点（目标对象方法）名称为user的参数传递进来。这里要注意，JoinPoint类型的参数对于非环绕通知而言，Spring AOP会自动把它传递到通知中；对于环绕通知而言，可以使用ProceedingJoinPoint类型的参数。之前我们讨论过它的结构，使用它将允许目标对象的回调，这里不妨在这个方法上加入断电来看看获取的参数是什么12345@Before("pointCut() &amp;&amp; args(user)")public void beforeParam(JoinPoint point,User user)&#123; Object[] args = point.getArgs(); System.out.println("before......");&#125; 从监控中，我们看到参数user的信息传递成功了。通过连接点参数的getArgs方法获取所有参数，而对于连接点参数还可以获取目标对象的信息，从而完成需要的工作。 织入织入是一个生成工台代理对象并且将切面和目标对象方法编织成为约定流程的过程，对于流程上的通知，上面已经有了比较完善的说明，而上面我们都是采用接口+实现类的模式，这是Spring推荐的方式。但是对于是否拥有接口则不是Spring AOP的强制要求，对于动态代理也有很多实现方式，我们之前谈到的JDK知识其中一种。Spring采用了JDK和CGLIB，当你需要使用AOP的类拥有接口时，它会自动JDK动态代理运行，否则以CGLIB运行。123456789101112131415package com.example.chapter4.aspect.service.impl;import com.example.chapter4.pojo.User;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl&#123; public void printUser(User user) &#123; if(user == null)&#123; throw new RuntimeException("检查用户参数是否为空!"); &#125; System.out.println("id="+user.getId()); System.out.println("username="+user.getUsername()); System.out.println("note="+user.getNote()); &#125;&#125; 然后修改控制器的依赖注入，直接依赖于不存在的接口的实现类，代码如下12345678910111213@Autowiredprivate UserServiceImpl userService;@RequestMapping("/print")@ResponseBodypublic User printUser(Long id, String userName, String note)&#123; User user = new User(); user.setId(id); user.setUsername(userName); user.setNote(note); userService.printUser(user); return user;&#125; 然后我们在注释的地方加入断点，可以看到如下信息，此时已经说明Spring已经使用了CGLIB为我们生成代理对象，从而将切面内容织入对应的流程 多个切面之前是一个切面的运行，而实际上Spring还可以支持多个切面的运行。在组织多个切面时，我们需要知道其运行的吮吸，首先创建3个切面类，代码如下MyAspect112345678910111213141516171819202122232425package com.example.chapter4.aspect;import org.aspectj.lang.annotation.*;@Aspectpublic class MyAspect1 &#123; @Pointcut("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.manyAspects(..))") public void manayAspects()&#123; &#125; @Before("manayAspects()") public void before()&#123; System.out.println("MyAspect1 before......"); &#125; @After("manayAspects()") public void after()&#123; System.out.println("MyAspect1 after......"); &#125; @AfterReturning("manayAspects()") public void afterReturning()&#123; System.out.println("MyAspect1 afterReturning......"); &#125;&#125; MyAspect212345678910111213141516171819202122232425package com.example.chapter4.aspect;import org.aspectj.lang.annotation.*;@Aspectpublic class MyAspect2 &#123; @Pointcut("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.manyAspects(..))") public void manayAspects()&#123; &#125; @Before("manayAspects()") public void before()&#123; System.out.println("MyAspect2 before......"); &#125; @After("manayAspects()") public void after()&#123; System.out.println("MyAspect2 after......"); &#125; @AfterReturning("manayAspects()") public void afterReturning()&#123; System.out.println("MyAspect2 afterReturning......"); &#125;&#125; MyAspect312345678910111213141516171819202122232425package com.example.chapter4.aspect;import org.aspectj.lang.annotation.*;@Aspectpublic class MyAspect3 &#123; @Pointcut("execution(* com.example.chapter4.aspect.service.impl.UserServiceImpl.manyAspects(..))") public void manayAspects()&#123; &#125; @Before("manayAspects()") public void before()&#123; System.out.println("MyAspect3 before......"); &#125; @After("manayAspects()") public void after()&#123; System.out.println("MyAspect3 after......"); &#125; @AfterReturning("manayAspects()") public void afterReturning()&#123; System.out.println("MyAspect3 afterReturning......"); &#125;&#125; 这样就存在了3个切面，他们同事拦截UserServiceImpl的manyAspects方法，所以我们来实现这个新的方法，代码如下1234567891011121314package com.example.chapter4.aspect.service.impl;import com.example.chapter4.aspect.service.UserService;import com.example.chapter4.pojo.User;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123;······ @Override public void manyAspects() &#123; System.out.println("测试多个切面的顺序!"); &#125;&#125; 同事需要改造UserService接口提供manayAspects方法。这个过程比较简单，不再展示。接着我们在UserController这个控制器中加入新的方法，对多个切面进行测试，代码如下12345@RequestMapping("/manyAspects")public String manyAspects()&#123; userService.manyAspects(); return "manayAspects";&#125; 这样我们就调用了UserServiceImpl的manyAspects方法，然后在配置文件中加入这3个切面的Bean，代码如下123456789101112131415161718192021222324252627282930313233package com.example.chapter4;import com.example.chapter4.aspect.MyAspect1;import com.example.chapter4.aspect.MyAspect2;import com.example.chapter4.aspect.MyAspect3;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;//指定扫描包@SpringBootApplication(scanBasePackages = &#123;"com.example.chapter4.aspect"&#125;)public class Chapter4Application &#123; //定义切面 @Bean(name="myAspect1") public MyAspect1 initMyAspect1()&#123; return new MyAspect1(); &#125; //定义切面2 @Bean(name="myAspect2") public MyAspect2 initMyAspect2()&#123; return new MyAspect2(); &#125; //定义切面3 @Bean(name="myAspect3") public MyAspect3 initMyAspect3()&#123; return new MyAspect3(); &#125; //启动切面 public static void main(String[] args) &#123; SpringApplication.run(Chapter4Application.class, args); &#125;&#125; 运行这个文件，就可以看到Tomcat的运行日志，待启动好之后，浏览器中输入http://localhost:8080/user/manyAspects，在日志中可以看到：12345678910MyAspect1 before......MyAspect2 before......MyAspect3 before......测试多个切面的顺序!MyAspect3 after......MyAspect3 afterReturning......MyAspect2 after......MyAspect2 afterReturning......MyAspect1 after......MyAspect1 afterReturning...... 从日志中可以看出，切面的执行顺序是混乱的，而在我做的测试中没有找到多个切面执行的顺序规律。但是在很多时候，开发者需要确定切面的执行顺序，来决定哪些切面先执行，哪些切面后执行。为此，Spring提供了@Order，例如，我们指定MyAspect1的执行顺序为1，代码如下123456//定义切面@Bean(name="myAspect1")@Order(1)public MyAspect1 initMyAspect1()&#123; return new MyAspect1();&#125; 打印的日志内容如下12345678910MyAspect1 before......MyAspect2 before......MyAspect3 before......测试多个切面的顺序!MyAspect3 after......MyAspect3 afterReturning......MyAspect2 after......MyAspect2 afterReturning......MyAspect1 after......MyAspect1 afterReturning...... 我们可以看到，对于前置通知before都是从小到大执行的，而对于后置通知和返回通知都是从大到小运行的，这就是一个典型的责任链模式的顺序。同样的使用Ordered接口也可以指定顺序，例如12345678@Aspectpublic class MyAspect1 implements Ordered &#123; @Override public int getOrder() &#123; return 1; &#125;&#125; 同样的，MyAspect2和MyAspect3都可以做类似的操作，这样就可以指定切面的顺序，这样不如使用@Order注解方便。 -]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 全注解下的Spring IoC]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%AC%AC3%E7%AB%A0-%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84Spring-IoC%2F</url>
    <content type="text"><![CDATA[Spring最成功的是提出的理念，依赖两个核心理念，一个是控制反转（IoC），另一个是面向切面编程（AOP）。IoC容器是Spring的核心，可以说Spring是一种基于IoC容器编程的框架IoC是一种通过描述来生成或者获取对象的技术，Java初学者来说所熟悉的是使用new关键字创建对象，而在Spring中则不是，他是通过描述来创建对象。Spring Boot通过注解的描述生成对象。一个系统可以生成各种对象，并且这些对象都需要进行管理。还值得一提的是，对象之间并不是孤立的，他们之间还可能存在依赖关系。例如一个班级是由多个老师和同学组成，那么班级就依赖于多个老师和学生。为此Spring还提供了依赖注入的功能，是的我们能够通过描述来管理各个对象之间的关系为了描述上述的班级、同学和老师的这3个对象关系，我们需要一个容器。在Spring中把一个需要管理的对象成为Spring Bean（简称Bean），而Spring管理这些Bean的容器，本我们成为Spring IoC容器，其需要具备两个基本功能： 通过描述管理Bean，包括发布和获取Bean 通过描述完成Bean之间的依赖关系 IoC容器简介Spring的定义中，要求IoC容器都需要实现接口BeanFactory，他是一个顶级容器接口，BeanFactory的源码中有多个getBean方法，这是IoC容器的最重要的方法，它的意义是从IoC容器中获取Bean。而从多个getBean中可以看到有按照类型（by type）获取Bean的，也有按照名称（by name）获取Bean的，这就意味着Spring IoC容器中，允许我们按照类型或者名称获取Bean，这对理解后面讲到的Spring的依赖注入是十分重要的isSingleton方法则判断Bean是否在Spring IoC中为单例。这里需要记住的是Spring IoC容器中，默认情况下，Bean都是单例存在的，也就是getBean方法返回的都是同一个对象。与isSingleton方法相反的是isPrototype方法，如果它返回的是true，那么当我们使用getBean方法获取Bean的时候，Spring IoC容器会创建一个新的Bean返回给调用者，这些与后面讨论的Bean的作用域相关。由于BeanFactory的功能还不够强大，因此Spring的BeanFactory的基础上，还设计了一个更为高级的接口ApplicationContext。他是BeanFactory的子接口之一，在Spring的体系中BeanFactory和ApplicationContext是最为重要的接口设计ApplicationContext接口通过集成商机接口，进而集成BeanFactory，扩展了消息国际化接口，环境可配置接口，应用事件发布接口和资源模式解析接口，所以功能会更强大。在Spring Boot当中我们主要是通过注解来装配Bean到Spring IoC容器中，下面开始一个简单的例子，1. 首先创建一个Java简单对象User.java，代码如下：12345678910111213141516171819202122232425package com.example.chapter3.pojo;public class User &#123; private Long id; private String userName; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125;&#125;2. 然后再定义一个Java配置文件AppConfig.java，代码如下1234567891011121314151617package com.example.chapter3.config;import com.example.chapter3.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AppConfig &#123; @Bean(name = "user") public User initUser()&#123; User user = new User(); user.setId(1L); user.setUserName("user_name_1"); user.setNote("note_1"); return user; &#125;&#125;这里需要注意@Configuration代表这是一个Java配置文件，Spring的容器会根据它来生成IoC容器中装配Bean；@Bean代表将initUser方法返回的POJO装配到IoC容器中，而其属性name定义这个Bean的名称，如果没有配置他，浙江方法名称initUser作为Bean的名称保存到Spring IoC中。3. 使用AnnotationConfigApplicationContext来勾践自己的IoC容器，代码如下所示12345678910111213package com.example.chapter3.config;import com.example.chapter3.pojo.User;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class IoCTest &#123; public static void main(String[] args)&#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); User user = ctx.getBean(User.class); System.out.println(user.getUserName()); System.out.println(user.getId()); System.out.println(user.getNote()); &#125;&#125;代码中将Java配置文件AppConfig传递给AnnotationConfigApplicationContext的构造方法，这样它就能够读取配置了。然后将配置里面的Bean装配到IoC容器中，于是可以使用getBean方法获取对应的POJO，下面为打印的日志显然，配置在配置文件中的名称为user的Bean已经被装配到IoC容器中，并且可以通过getBean方法获取对应的Bean，并将Bean的属性信息传输出来。## 装配你的Bean### 通过扫描装配你的Bean如果有很多Bean都是用注解@Bean注入Spring IoC容器中，那将是一件很麻烦的事情。所以Spring允许进行扫描配置Bean到IoC容器中，对于扫描装配而言是用的注解是@Component和@ComponentScan。@Component是标明哪个类被扫描进入Spring IoC容器，而@ComponentScan则是标明采用何种策略去扫描装配Bean。1. 首先我们把User.java移动到包com.example.chapter3.config内，然后对其进行修改，代码如下所示1234567891011121314151617package com.example.chapter3.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component("user")public class User &#123; @Value("1") private Long id; @Value("user_name_1") private String userName; @Value("note_1") private String note;getter&amp;&amp;setter这里的注解@Component表明这个类将被Spring IoC容器扫描装配，其中配置的user则是作为Bean的名称，当然你也可以不配置这个字符串，那么IoC容器就会把类名第一个字母作为小写，其他不变作为Bean名称放入IoC容器中；注解@Value则是指定具体的值，是的Spring IoC给予对应属性注入对应的值。为了让Spring IoC容器装配这个类，需要改造AppConfig，代码如下：1234567package com.example.chapter3.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@ComponentScan@Configurationpublic class AppConfig &#123;&#125;这里加入了@ComponentScan，意味着他会进行扫描，但是只会扫描类Appconfig所在的当前包和自爆，之前把User.java移动到config就是这个远远，这样就可以删除掉之前使用@Bean标注的创建对象方法，然后进行测试，测试代码和前面的IoCTest的代码一样，不需要修改。虽然这样能够运行了，但是User类迁移到了本不该防止它的配置包中，为了更加合理，@ComponentScan还允许我们自定义扫描的包，下面讲解一下@ComponentSacen- 配置项basePackages定义扫描的包名，在没有定义的情况下，他会扫描当钱包和其子包下的路径- 配置项basePackageClasses定义扫描的类- includeFilters定义满足过滤器（Filter）条件的Bean才去扫描- excludeFilters则是排除过滤条件的Bean，他俩都需要通过一个注解@Filter去定义，type定义类型，这里可以定义为注解或者正则式等类型1. 把AppConfig中的注解修改为12345@ComponentScan("com.example.chapter3.pojo")或@ComponentScan(basePackages = &#123;"com.example.chapter3.pojo"&#125;)或@ComponentScan(basePackageClasses = &#123;User.class&#125;)无论采用何种方式都能够使得IoC容器去扫描User类，而包名可以采用正则表达式去匹配。但是有时候我们需要的是想扫描一些包，将一些Bean装配到Spring IoC容器中，而不是像加载这个包里面的某些Bean。比方式，现在我们有一个UserService类，味蕾标注他为服务类，将类标注@Service（该标准注入了@Component，所以默认的情况下它会被Spring扫描到IoC容器中），这里再假设采用了策略1@ComponentSacn("com.example.chapter3.*")这样对于com.example.chapter3.service和com.example.chapter3.pojo，这两个包都会被扫描到，此时我们定义UserServcice类代码如下1234567891011121314package com.example.chapter3.service;import com.example.chapter3.pojo.User;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; public void pringUser(User user)&#123; System.out.println(user.getId()); System.out.println(user.getUserName()); System.out.println(user.getNote()); &#125;&#125;按以上的装配策略，他将会被扫描到Spring IoC容器中，为了不被装配，需要修改扫描的策略为：1@Component(basePackages="com.example.chapter3.*",excludeFilters=&#123;@Filter(classes=&#123;Service.class&#125;)&#125;)这样，由于加入了excludeFilters的配置，使标注了@Service的类将不被IoC容器扫描注入，这样就可以吧UserService类排除到SPring IoC容器中了。事实上，之前在SpringBoot上述实例中看到注解@SpringBootApplication也注入了@ComponentScan### 自定义第三方BeanJava的应用往往需要引入许多来自第三方的包，还需要放入到Spring IoC容器中，这时@Bean注解就可以发挥作用了例如，要引入一个DBCP数据源，我们现在pom.xml文件上加入项目所需要DBCP包和MySQL数据库驱动相关依赖，代码如下12345678&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;这样DBCP和数据库驱动就被加入到项目中了，接着使用它提供的机制来生成数据源，修改AppConfig.java，如下所示123456789101112131415161718192021222324252627282930package com.example.chapter3.config;import org.apache.commons.dbcp2.BasicDataSourceFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import javax.xml.ws.Service;import java.util.Properties;@ComponentScan(basePackages = &#123;"com.example.chapter3.*"&#125;,excludeFilters = &#123;@ComponentScan.Filter(classes = &#123;Service.class&#125;)&#125;)@Configurationpublic class AppConfig &#123; @Bean(name="dataSource") public DataSource getDataSource()&#123; Properties props = new Properties(); props.setProperty("driver","com.mysql.jdbc.Driver"); props.setProperty("url","jdbc:mysql://localhost:3306/chapter3"); props.setProperty("username","root"); props.setProperty("password","zhang1989"); DataSource dataSource = null; try &#123; dataSource = BasicDataSourceFactory.createDataSource(props); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return dataSource; &#125;&#125;这里通过@Bean定义了其配置项name作为dataSource，那么Spring就会把她返回的对象用名称dataSource保存在IoC容器中，通过这样，就可以将第三方包的类装配到SPring IoC容器中了。## 依赖注入Spring IoC中的Bean之间的依赖，类似于人类（Person）有时候利用一些动物（Animal）去完成一些事情，比方狗（Dog）看大门，猫（Cat）抓老鼠等等于是做一些事情就依赖于那些可爱的动物为了更好地展现这个过程，首先定义两个接口，一个是人类，另外一个是动物，人类通过动物去提供一些特殊的服务12345678//人类接口package com.example.chapter3.definition;public interface Person &#123; //使用动物服务 void service(); //设置动物 void setAnimal(Animal animal);&#125;123456//动物接口package com.example.chapter3.definition;public interface Animal &#123; public void use();&#125;接下来两个实现类是人和狗的，代码如下12345678910111213141516171819202122package com.example.chapter3.pojo;import com.example.chapter3.definition.Animal;import com.example.chapter3.definition.Person;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class BusinessPerson implements Person &#123; @Autowired private Animal animal = null; @Override public void service() &#123; this.animal.use(); &#125; @Override public void setAnimal(Animal animal) &#123; this.animal = animal; &#125;&#125;1234567891011package com.example.chapter3.pojo;import com.example.chapter3.definition.Animal;@Componentpublic class Dog implements Animal &#123; @Override public void use() &#123; System.out.println("狗【"+Dog.class.getSimpleName()+"】是看门用的"); &#125;&#125;这里应注意@Autowired，是Spring中最常用的注解之一，他会根据属性的类型（by type）找到对应的Bean进行诸如。这里的Dog是动物的一种，所以Spring IoC容器会把Dog实例诸如到BussinessPerson中。这样通过Spring IoC容器获取BussinessPerson实例的时候就能够使用Dog实例来提供服务了，下面是测试代码：123AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Appconfig.class);Person person = ctx.getBean(BusinessPerson.class);person.service();测试结果如下：12测试成功，这个时候Spring IoC容器已经通过注解@AutoWired成功的将Dog注入到了BussinessPerson实例中。### 注解@Autowired它注入的基本已调试根据类型（by type），BeanFactory同时还支持按照名称（by name），回到上面的例子，我们只是创建了一个动物-狗，二十几上动物还可以有猫（Cat），猫可以用来抓老鼠，于是新建一个猫的类，代码如下：123456789package com.example.chapter3.pojo;import com.example.chapter3.definition.Animal;@Componentpublic class Cat implements Animal &#123; @Override public void use() &#123; System.out.println("猫【"+Cat.class.getSimpleName()+"】是抓老鼠的"); &#125;&#125;现在测试下，会出现一个问题，定义了一个动物属性（Animal），而我们却有两个动物，一个狗，一个猫，Spring IoC如何注入呢，如果你还进行测试，很快就会抛出下面的异常1234Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &apos;com.example.chapter3.definition.Animal&apos; available: expected single matching bean but found 2: cat,dog at org.springframework.beans.factory.config.DependencyDescriptor.resolveNotUnique(DependencyDescriptor.java:221) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1225) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1167)从日志可以看出，Spring IoC容器并不能知道你需要注入什么动物（是狗？是猫）给BusinessPerson类对象，从而引起错误的发生。那么使用@AutoWired能处理这个问题。假设我们目前需要狗提供服务，那么可以把属性名称改为dog，也就是原来的12@Autowiredprivate Animal animal = null;修改为123456789101112@Autowiredprivate Animal dog = null;@Overridepublic void service() &#123; this.dog.use();&#125;@Overridepublic void setAnimal(Animal animal) &#123; this.dog = animal;&#125;这里只是将属性的名称从animal修改为了dog，那么我们再测试的时候，你可以看到采用狗来提供服务了。那是因为@Autowired提供这样的规则，首先会根据类型找到对应的Bean，如果对应类型的Bean不是唯一的，那么他会根据其属性名称和Bean的名称进行匹配。如果匹配的上，就会使用该Bean；如果还是无法匹配，就会抛出异常 消除歧义性-@Primary和@Quelifier在上面我们发现有猫和狗的时候，为了使@Autowired能够继续使用，我们做了一个决定，将BusinessPerson的属性名称从animal修改为dog。显然这种方法并不能很好的解决问题，下面讲解两种解决方案。首先是一个注解@Primary，他是一个修改优先权的注解，当我们有猫和狗的时候，假设这次需要使用猫，那么只需要在猫类的定义上加入@Primary就可以了，类似于下面的代码123456······@Component@Primarypublic class Cat implements Animal &#123;······&#125; 这里的@Primary的含义告诉Spring IoC容器，发现有多个同样类型的Bean时，请优先使用我进行注入，然后，有时候@Primary也可以使用在多个类上，也许无论是猫还是狗可能带上@Primary，其结果是IoC容器还是无法区分采用哪个Bean的实例进行注入，又或者说我们需要更加灵活机制来实现注入，那么@Quelifier可以满足。他的配置项value需要一个字符串去定义，它将于@Autowired组合在一起，通过类型和名称一起找到bean。我们知道Bean名称在Spring IoC容器中是唯一的标识，通过这个就可以小区歧义性123@Autowired@Qualifier(value="dog")Animal animal; 一旦这样生命，Spring IoC将会以类型和名称去寻找对应的Bean进行注入。 带有参数的构造方法类的装配在上面，我们都基于一个默认的情况，那就是不带参数的构造方法下实现依赖注入。但是实际上，有些类是带有参数的构造方法，于是上述的方法就不能再使用了。为了满足这个功能，我们可以使用@Autowired注解对构造方法的参数进行注入，例如BusinessPerson来满足这个功能，代码如下：1234567891011121314151617package com.example.chapter3.pojo;······@Componentpublic class BusinessPerson implements Person &#123; private Animal animal; public BusinessPerson(@Autowired @Qualifier(value="dog") Animal animal) &#123; this.animal = animal; &#125; @Override public void service() &#123; this.animal.use(); &#125; @Override public void setAnimal(Animal animal) &#123; this.animal = animal; &#125;&#125; 可以看到，代码中取消了@Autowired对属性和方法的标注。通过在参数上加入@Autowired和@Qualifier注解，使得它能够注入进来。这里使用@Qualifier为了避免歧义性。 生命周期上面我们只是关心如何正确的将Bean装配到IoC容器中，而没有关心IoC容器如何装配和销毁Bean的过程。有时候我们也需要自定义初始化或者销毁Bean的过程，来满足一些Bean特殊初始化和销毁的要求，例如在上线数据库注入中，我们希望在其关闭的时候调用其close方法，以释放数据库的连接资源，这是在项目使用过程中很常见的要求。Bean的生命周期大概分为Bean定义、Bean初始化、Bean生存期和Bean的销毁4个部分，其中Bean定义过程大致如下： Spring通过我们的配置，如@ComponentScan定义的扫描路径去找到带有@Component的类，这个过程就是一个资源定位的过程。 一旦找到资源，那么就开始解析，并且将定义的信息保存起来，此时还没有初始化Bean，也就是没有Bean的实例，仅仅是Bean的定义 然后把Bean定义发布到Spring IoC容器中。此时IoC容器也只有Bean的定义，还是没有Bean的实例生成 完成上面3步知识一个资源定位并将Bean的定位发布到IoC容器的过程，还没有Bean实例生成，更没有完成依赖注入。在默认情况下，Spring会继续去完成Bean的实例化和依赖注入，这样从IoC容器中就可以得到一个依赖注入完成的Bean。但是，有些Bean会受到变化因素的影响，这是我们到希望是取出Bean的时候完成初始化和依赖注入，换句话说就是让那些Bean知识将定义发布到IoC容器中而不进行实例化和依赖注入ComponentScan中海油一个配置项lazyInit，只可以配置Boolean值，而且默认是false，也就是默认不进行延迟初始化，因此在默认的情况下Spring会对Bean进行实例化和依赖注入对应的属性值。为了进行测试，线改造下BusinessPerson，代码如下1234567891011121314151617package com.example.chapter3.pojo;······@Componentpublic class BusinessPerson implements Person &#123; private Animal animal; @Override public void service() &#123; this.animal.use(); &#125; @Override @Autowired @Qualifier("dog") public void setAnimal(Animal animal) &#123; System.out.println("延迟依赖注入"); this.animal = animal; &#125;&#125; 然后我们在没有配置lazyInit的情况下进行断点测试，在断点出，我们并没有获取Bean的实例，而日志已经打印出来了，课件在Spring IoC容器初始化就执行了实例化和依赖注入，为了改变这种情况，我们在配置类AppConfig的@CopmonentScan中加入lazyInit配置，代码如下123456package com.example.chapter3.config;······@ComponentScan(basePackages = &#123;"com.example.chapter3.pojo"&#125;,lazyInit = true)@Configurationpublic class AppConfig &#123;&#125; 然后进行测试，发现在断电出是不会打印“延迟依赖注入”的，只有运行过断点之后才会出现日志。如果仅仅是实现利华和依赖注入还是比较简单的，还不能够完成自定义的要求。为了完成依赖注入的功能，Spring在完成依赖注入之后，还提供了一系列的接口和配置来完成Bean初始化的过程，具体的流程如下图所示，除此之外，还应该注意以下两点： 这些接口和方法时针对什么而言的，在没有注释的情况下的流程节点都是针对单个Bean而言的，但是BeanPostProcessor是针对所有Bean而言的 及时你定义了ApplicationContextAware接口，但是有时候并不会调用，这样根据你IoC容器来决定。我们知道，Spring IoC容器最低的要求是实现BeanFactory接口，而不是实现ApplicationContext接口。对于那些没有实现ApplicationContext的接口容器，在生命周期对应的ApplicationContextAware定义的方法也是不会被调用的，只有实现了ApplicationContext接口的容器，才会在生命周期调用ApplicationContextAware十一度包工头的setApplicationContext方法 下面开始测试生命周期，先来改造下类BussinessPerson，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.chapter3.pojo;······@Componentpublic class BusinessPerson implements Person,BeanNameAware,BeanFactoryAware,ApplicationContextAware,InitializingBean,DisposableBean &#123; private Animal animal; @Override public void service() &#123; this.animal.use(); &#125; @Override @Autowired @Qualifier("dog") public void setAnimal(Animal animal) &#123; System.out.println("延迟依赖注入"); this.animal = animal; &#125; @Override public void setBeanName(String s) &#123; System.out.println("【"+this.getClass().getSimpleName()+"】调用了BeanNameAware的setBeanName"); &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println("【"+this.getClass().getSimpleName()+"】调用了BeanFactoryAware的setBeanFactory"); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println("【"+this.getClass().getSimpleName()+"】调用了ApplicationContextAware的setApplicationContext"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("【"+this.getClass().getSimpleName()+"】调用了InitializingBean的afterPropertiesSet"); &#125; @PostConstruct public void init()&#123; System.out.println("【"+this.getClass().getSimpleName()+"】注解@PostConstruct定义的自定义初始化方法"); &#125; @PreDestroy public void destory1()&#123; System.out.println("【"+this.getClass().getSimpleName()+"】注解@PreDestroy定义的自定义销毁方法"); &#125; @Override public void destroy() throws Exception &#123; System.out.println("【"+this.getClass().getSimpleName()+"】DisposableBean方法"); &#125;&#125; 这个Bean就实现了生命周期中单个Bean可以实现的所有接口，并且通过注解@PostConstruct定义了初始化方法，通过注解@PreDestory定义了销毁方法。为了测试Bean的后置处理器，这里创建一个类BeanPostProcessorExample，代码如下123456789101112131415161718192021package com.example.chapter3.life;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.stereotype.Component;@Componentpublic class BeanPostProcessorExample implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeanPostProcessor调用"+"postProcessBeforeInitialization方法，参数【"+bean.getClass().getSimpleName()+"】【"+beanName+"]"); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("BeanPostProcessor调用"+"postProcessBeforeInitialization方法，参数【"+bean.getClass().getSimpleName()+"】【"+beanName+"]"); return bean; &#125;&#125; 注意，这个Bean后置处理器将对所有的Bean有效，然后我们使用下面的测试代码进行测试。12AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);ctx.close(); 日志如下：1234567891011121314151617181920212223BeanPostProcessor调用postProcessBeforeInitialization方法，参数【AppConfig$$EnhancerBySpringCGLIB$$375c39d2】【appConfig]BeanPostProcessor调用postProcessAfterInitialization方法，参数【AppConfig$$EnhancerBySpringCGLIB$$375c39d2】【appConfig]22:48:12.697 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;businessPerson&apos;22:48:12.799 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;dog&apos;BeanPostProcessor调用postProcessBeforeInitialization方法，参数【Dog】【dog]BeanPostProcessor调用postProcessAfterInitialization方法，参数【Dog】【dog]延迟依赖注入【BusinessPerson】调用了BeanNameAware的setBeanName【BusinessPerson】调用了BeanFactoryAware的setBeanFactory【BusinessPerson】调用了ApplicationContextAware的setApplicationContextBeanPostProcessor调用postProcessBeforeInitialization方法，参数【BusinessPerson】【businessPerson]【BusinessPerson】注解@PostConstruct定义的自定义初始化方法【BusinessPerson】调用了InitializingBean的afterPropertiesSetBeanPostProcessor调用postProcessAfterInitialization方法，参数【BusinessPerson】【businessPerson]22:48:12.804 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;cat&apos;BeanPostProcessor调用postProcessBeforeInitialization方法，参数【Cat】【cat]BeanPostProcessor调用postProcessAfterInitialization方法，参数【Cat】【cat]22:48:12.805 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user&apos;BeanPostProcessor调用postProcessBeforeInitialization方法，参数【User】【user]BeanPostProcessor调用postProcessAfterInitialization方法，参数【User】【user]22:48:12.848 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@707f7052, started on Tue Apr 30 22:48:11 CST 2019【BusinessPerson】注解@PreDestroy定义的自定义销毁方法【BusinessPerson】DisposableBean方法 从日志看出，对于Bean后置处理器（BeanPostProcessor）而言，他对所有的Bean都是起作用的，而其他的接口则是对单个Bean起作用。我们还可以注意到BussinessPerson执行的流程。有时候Bean的定义可能使用的是第三方的类，此时可以使用注解@Bean来配置自定义初始化和销毁方法，如下所示：1@Bean(initMethod="init",destoryMethod="destory") 使用属性文件Spring Boot中可以使用默认的application.properties，也可以自定义的配置文件。应该说读取配置文件的方法很多，这里介绍最常用的方法。在Spring Boot中我们现在Maven配置文件中加载依赖，代码如下12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 有了依赖，就可以直接使用application.properties文件为你工作了，例如，现在为他新增代码清单所示的属性如下1234database.driverName=com.mysql.jdbc.Driverdatabase.url=jdbc:mysql://localhost:3306/chapter3database.username=rootdatabase.password=zhang1989 这是Spring Boot的默认文件，他会通过其机制读取到上下文中，这样可以引用它了。对于他的引用，有两种方法，首先是Spring表达式。本节仅限于读取属性而不涉及运算，创建一个新的类DataBaseProperties，代码如下：1234567891011121314151617181920212223242526272829303132333435363738package com.example.chapter3.pojo;···import···@Componentpublic class DataBaseProperties &#123; @Value("$&#123;database.driverName&#125;") private String driverName = null; @Value("$&#123;database.url&#125;") private String url = null; private String username = null; private String password = null; public void setDriverName(String driverName) &#123; System.out.println(driverName); this.driverName = driverName; &#125; public void setUrl(String url) &#123; System.out.println(url); this.url = url; &#125; @Value("$&#123;database.username&#125;") public void setUsername(String username) &#123; System.out.println(username); this.username = username; &#125; @Value("$&#123;database.password&#125;") public void setPassword(String password) &#123; System.out.println(password); this.password = password; &#125; ···getter···&#125; 这样我们就可以通过@Value注解，使用${……}这样的占位符读取配置在属性文件的内容。这里的@Value注解，既可以加在属性，也可以加在方法上，启动Spring Boot就可以看到下面的日志了，注意这里是启动Spring Boot而不是测试类了1234BeanPostProcessor调用postProcessAfterInitialization方法，参数【Cat】【cat]rootzhang1989BeanPostProcessor调用postProcessBeforeInitialization方法，参数【DataBaseProperties】【dataBaseProperties] 可见读取属性成功了。有时候我们也可以使用注解@ConfigurationProperties，通过它是得配置上有所减少，例如，下面我们修改DataBaseProperties的代码，如下1234567891011121314151617181920212223242526272829303132package com.example.chapter3.pojo;···import···@Component@ConfigurationProperties("database")public class DataBaseProperties &#123; private String driverName = null; private String url = null; private String username = null; private String password = null; public void setDriverName(String driverName) &#123; System.out.println(driverName); this.driverName = driverName; &#125; public void setUrl(String url) &#123; System.out.println(url); this.url = url; &#125; public void setUsername(String username) &#123; System.out.println(username); this.username = username; &#125; public void setPassword(String password) &#123; System.out.println(password); this.password = password; &#125;···getter···&#125; 这里在注解@ConfigurationProperties中配置的字符串database，将于POJO的属性名称组成属性的全限定名去配置文件里查找，这样就能够将对应的属性读入到POJO当中。但是有时候我们会觉得如果所有的内容都配置到application.properties，显然这个文件将有很多内容。为了更好的配置，我们可以选择使用心得属性文件。例如，数据库属性可以配置在jdbc.properties文件中，于是把application.properties文件中的数据库信息迁移到jdbc.properties中，然后使用@PropertySource去定义对应的属性文件，把它加载到Spring的上下文中，代码如下：1234567891011121314151617package com.example.chapter3;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.PropertySource;@SpringBootApplication@ComponentScan(basePackages = &#123;"com.example.chapter3"&#125;)@PropertySource(value = &#123;"classpath:jdbc.properties"&#125;,ignoreResourceNotFound = true)public class Chapter3Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Chapter3Application.class, args); &#125;&#125; value可以配置多个配置文件。使用classpath前缀，意味着去类文件路径下找到属性文件ignoreResourceNotFound则是是否忽略配置文件找不到的问题，默认为false，也就是找不到会报错，这里配置为true，也就是找不到不会报错 Bean的作用域 作用域类型 使用范围 作用域描述 singleton 所有Spring应用 默认值，IoC容器只存在单例 prototype 所有Spring应用 每当从IoC容器中去除一个Bean，则创建一个新的Bean session Spring Web应用 HTTP会话 application Spring Web应用 Web工程生命周期 下面我们探讨下单例（Singleton）和原型（Prototype）的区别，首先定义一个类，代码如下1234567891011package com.example.chapter3.scope.pojo;import org.springframework.beans.factory.config.ConfigurableBeanFactory;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component//@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class ScopeBean &#123;&#125; 这是一个简单的类，实际就是单例，测试代码如下：12345678910package com.example.chapter3.config;···import···public class IoCTest &#123; public static void main(String[] args)&#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); ScopeBean scopeBean1 = ctx.getBean(ScopeBean.class); ScopeBean scopeBean2 = ctx.getBean(ScopeBean.class); System.out.println(scopeBean1 == scopeBean2); &#125;&#125; 测试打印结果如下：，说明了两个实例是同一个12300:05:06.521 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;scopeBean&apos;trueDisconnected from the target VM, address: &apos;127.0.0.1:5697&apos;, transport: &apos;socket&apos; 然后取消代码清单中的注释@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)，进行相同的测试，结果如下：12300:07:23.687 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'Disconnected from the target VM, address: '127.0.0.1:5733', transport: 'socket'false 打印出来是false，说明不是同一个Bean了。这里的ConfigurableBeanFactory只提供单例（SCOPE_SINGLETON）和原型（SCOPE_PROTOTYPE）两种作用域供选择，如果是在Spring MVC环境中，还可以使用WebApplicationContext去定义其他作用域，如请求（SCOPE_REQUEST）、会话（SCOPE_SESSION）和应用（SCOPE_APPLICATION）。例如下面的代码就是定义请求作用域123456package com.example.chapter3.scope.pojo;···import···@Component@Scope(WebApplicationContext.SCOPE_REQUEST)public class ScopeBean &#123;&#125; 这样同一个请求范围内去获取这个Bean的时候，智慧共用同一个Bean，第二次请求就会产生新的Bean。因此两个不同的请求将会获得不同的实例Bean 使用@Profile在企业开发的过程中，项目往往面临开发环境、测试环境、准生产环境（用于模拟真实生产环境部署所用）和生产环境的切换，这样在一个互联网企业中往往需要四套环境，而每一套环境的上下文是不一样的。例如，他们回有个字的数据库资源，这样就要求我们在不同的数据库之间切换，为了方便，Spring还提供了Profile机制，使我们可以很方便的实现各个环境之间的切换。假设存在dev_spring_boot和text_spring_boot两个数据库，这样可以使用注解@Profile定义两个Bean，代码如下：123456789101112131415161718192021222324252627282930313233@Bean(name="dataSource",destroyMethod = "close")@Profile("dev")public DataSource getDevDataSource()&#123; Properties props = new Properties(); props.setProperty("driver","com.mysql.jdbc.Driver"); props.setProperty("url","jdbc:mysql://localhost:3306/dev_spring_boot"); props.setProperty("username","root"); props.setProperty("password","123456"); DataSource dataSource = null; try &#123; dataSource = BasicDataSourceFactory.createDataSource(props); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return dataSource;&#125;@Bean(name="dataSource",destroyMethod = "close")@Profile("test")public DataSource getTestDataSource()&#123; Properties props = new Properties(); props.setProperty("driver","com.mysql.jdbc.Driver"); props.setProperty("url","jdbc:mysql://localhost:3306/test_spring_boot"); props.setProperty("username","root"); props.setProperty("password","123456"); DataSource dataSource = null; try &#123; dataSource = BasicDataSourceFactory.createDataSource(props); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return dataSource;&#125; 在Spring中存在两个参数可以提供给我们配置，已修改启动Profiel机制，一个是spring.profiles.active，另一个是spring.profiles.default。这两个属性都没有配置的情况下，Spring将不会启动Profile机制，这就意味着被@Profile标注的Bean将不会被Spring装配到IoC容器中。Spring是先判定是否存在spring.profile.active配置后，再去查找spring.profiles.default配置的。所以spring.profiles.active的优先级要大于spring.profiles.default在Java启动项目中，我们只需要加入下入配置就能启动Profile机制：1JAVA_OPTS=&quot;-Dspring.profiles.active=dev&quot; 当然在IDE中切换环境，也可以配置这个参数，对于属性配置文件而言，在Spring Boot中还存在一个约定，即允许比较方便的切换配置环境。例如，现实开发环境和测试环境的数据库是两个库，开发人员测试可能比较随意的增删改查，而测试人员则不是，测试人员需要搭建数据库的测试数据往往也需要比较多的时间和精力，因此在很多情况下，他们希望有独立的数据库，这样配置数据库连接的文件就需要分开了，而Spring Boot可以很好的支持切换配置文件的功能。首先我们在配置文件目录新增application-dev.properties文件，然后将日志配置为DEBUG级别，这样启动Spring Boot就会有很详细的日志显示。配置内容如下：12logging.level.root=DEBUGlogging.level.org.springframework=DEBUG 这个时候请注意，按照Spring Boot的规则，假设把选项-Dspring.profiles.active配置为{profile}，则会使用application-{profile}.properties文件去替换原来默认的application.properties文件，然后启动Spring Boot程序 使用Spring EL在上述代码中，我们是没有任何运算规则的情况下装配Bean的。为了跟家灵活，Spring还提供了表达式语言Spring EL。通过EL表达式进行计算装配Bean例如12@Value("#&#123;T(System).currentTimeMillis()&#125;")private Long initTime = null; 注意，这里采用#{……}代表占位符，它将具有运算的功能；T(……)代表的是引入类；System是java.lang.*包的类，这是Java的默认加载的包，因此可以不必写全，如果是其他的包，则需要写出全限定名才能引入类，currentTimeMillis是静态方法，也就是给属性赋值当前时间戳，此外还有直接给属性赋值12345678910@Value("#&#123;'使用EL表单时赋值字符串'&#125;")private String str = null；//科学计数法赋值@Value("#&#123;9.3E3&#125;")private double d;//赋值浮点数@Value("#&#123;3.14&#125;")private float pi; 显然这比较灵活，有时候我们还可以获取其他Spring Bean的属性来给当前Bean属性赋值12@Value("#&#123;beanName.str&#125;")private String otherBeanProp = null; 注意，这里的beanName是Spring IoC容器Bean的名称，str是其属性，代表引用对应的Bean的属性给当前属性赋值。有时候，我们还希望这个属性的字母全部变为大写，这个时候就可以写成12@Value("#&#123;beanName.str?.toUpperCase()&#125;")private String otherBeanProp = null; 再次注意这里的Spring EL。这里应用str属性后跟着一个?，这个符号的含义是判断这个属性是否为空，如果不为空才会执行toUpperCase方法，进而把引用到的属性转换为大写，赋值给当前属性，除此之外，还可以使用Spring EL进行一定的运算，代码如下：12345678910111213141516171819## 数学运算@Value("#&#123;1+2&#125;")private int sum;# 浮点数比较运算@Value("#&#123;beanName.pi== 3.14f&#125;")private boolean piFlag;# 字符串比较运算@Value("#&#123;beanName.str eq 'Spring Boot'&#125;")private boolean strFlag;# 字符串连接@Value("#&#123;beanName.str + '连接的字符串'&#125;")private String strApp = byll;# 三元运算@Value("#&#123;beanName.d &gt; 10000?'大于':'小于'&#125;")private String resultDesc =null; 从上面的代码可以看出，EL表达式支持的运算还是蛮多的]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 开发环境搭建和基本开发]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[搭建Spring Boot开发环境 启动IDEA，选择“Creat New Project”，弹出新的窗口选择“Spring Initializr”，切换到你想要的JDK版本，如下图： 点击Next，弹出两一个配置窗口，如下所示 点击上图的Next会弹出选择starter的窗口，如下图所示,这里需要选择自己需要的依赖 创建完成后看到一个建好的类Chapter2Application和Maven的pom.xml文件。运行Chapter2Application就可以启动Spring Boot工程，而pom.xml配置好了你选中的starter依赖，这样就能够基础IDEA开发Spring Boot工程了 Spring Boot的依赖和自动配置 spring-boot-starter-web加入了它spring-boot-starter-web之后，他会通过Maven将对应的资源加载到我们工程中 spring-boot-autoconfigure其中的DispatcherServletAutoConfiguration是DispatcherServlet进行自动配置的类。 使用自定义配置按照前面的步骤创建完工程chapter2之后，会在resources下面出现一个application.properties文件，，他是一个默认的配置文件，通过它可以根据自己的需要实现自定义。例如修改中间件的端口号，只需要在文件中添加一行1server.port=8090 开发自己的SPring Boot项目修改Spring MVC的视图解析器ViewResolver。视图解析器的作用主要是定位师徒，也就是当控制器只是返回一个逻辑名称的时候，是没法直接找到师徒的，是需要视图解析器进行解析的。实际开发过程中最常用的视图之一是JSP，例如返回一个字符串index，那么我们虚妄它对应的开发项目的/WEB-INF/jsp/index.jsp文件。 修改pom文件，加入JSP和JSTL的依赖包 123456789101112&lt;!--JSP依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--JSTL--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 修改application.properties文件，添加解析器配置 12345server.port=8090# 这个是前缀spring.mvc.view.prefix=/WEB-INF/jsp/# 这个是后缀spring.mvc.view.suffix=.jsp 创建index.jsp文件，这里是使用的idea，因此需要先进行一些简单的设置，配置方法见下图，配置完成后，会在项目路径的webapp上有一个蓝色的小点，下面还有index.jsp的代码 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;测试视图解析器&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 访问地址http://localhost:8090/index，打开查看效果 注意:Chapter2Application类中的@SpringBootApplication标志着这是一个Spring Boot入门文件1SpringApplication.run(Chapter2Application.class, args); 上面的这行代码是以Chapter2Application类作为配置类来运行Spring Boot项目，于是Spring Boot就会根据你在Maven加载的依赖完成运行。]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 Spring Boot来临]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%AC%AC1%E7%AB%A0-Spring-Boot%E6%9D%A5%E4%B8%B4%2F</url>
    <content type="text"><![CDATA[1.1 Srping的历史1.2 注解还是XMLSpring早起的1.x版本，JDK不支持注解，JDK5加入注解 XML配置文件：过于繁复 注解：会使得注解分部的导出都是，难于控制，需要了解很多框架的内部实现才能准确适用注解开发所需的功能 不成文共识：业务类适用注解，例如，对于MVC开发控制适用@Controller,业务层适用@Service，持久层适用@Repository；对于一些共用的Bean，例如数据库、第三方资源等适用XML进行配置 1.3 Spring Boot的优点优点如下： 创建独立的Spring应用程序 嵌入Tomcat、Jetty或者Undertow，无需部署war文件 允许通过Maven来根据需要获取starter 尽可能的自动配置Spring 提供生产就绪功能，如指标、健康检查和外部配置 绝对没有代码生成，对XML没有要求配置 spring-boot-starter-web捆绑了Spring MVC所以来的包，spring-boot-starter-tomcat绑定了内嵌的Tomcat，这样使得开发者能够尽可能快的搭建开发环境，快速进行开发和部署，这就是Spring Boot的特色 1.4 传统Spring MVC和Spring Boot的对比 传统Spring MVC项目开发：需要配置DispatcherServlet，还需要配置Spring IoC的容器 使用Spring Boot开发后，只需要创建一个Maven工程，并把其名字定义为chapter1，然后这样就可以看到一个Maven的pom.xml，将其内容修改为如下代码清单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;chapter1&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;chapter1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Starter依赖引入 --&gt; &lt;!-- AOP包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Web开发包，将载入Spring MVC所需要的包，且内嵌tomcat --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 加载测试依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--引入插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 这里我们只需要开发一个类就可以运行Spring Boot的应用了，为此新建类-Chapter1Main，代码如下 12345678910111213141516171819202122232425262728package com.example.chapter1;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.HashMap;import java.util.Map;@SpringBootApplication@Controller@EnableAutoConfigurationpublic class Chapter1Application &#123; @RequestMapping("/test") @ResponseBody public Map&lt;String,Object&gt; test()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("key","value"); return map; &#125; public static void main(String[] args) &#123; SpringApplication.run(Chapter1Application.class, args); &#125;&#125;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HSSFWorkBook操作导出Excel]]></title>
    <url>%2F2019%2F04%2F16%2FHSSFWorkBook%E6%93%8D%E4%BD%9C%E5%AF%BC%E5%87%BAExcel%2F</url>
    <content type="text"><![CDATA[官方文档http://poi.apache.org/apidocs/dev/org/apache/poi/hssf/usermodel/HSSFWorkbook.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215public ActionResult excelPrint() &#123; HSSFWorkbook workbook = new HSSFWorkbook();// 创建一个Excel文件 HSSFSheet sheet = workbook.createSheet();// 创建一个Excel的Sheet sheet.createFreezePane(1, 3);// 冻结 // 设置列宽 sheet.setColumnWidth(0, 1000); sheet.setColumnWidth(1, 3500); sheet.setColumnWidth(2, 3500); sheet.setColumnWidth(3, 6500); sheet.setColumnWidth(4, 6500); sheet.setColumnWidth(5, 6500); sheet.setColumnWidth(6, 6500); sheet.setColumnWidth(7, 2500); // Sheet样式 HSSFCellStyle sheetStyle = workbook.createCellStyle(); // 背景色的设定 sheetStyle.setFillBackgroundColor(HSSFColor.GREY_25_PERCENT.index); // 前景色的设定 sheetStyle.setFillForegroundColor(HSSFColor.GREY_25_PERCENT.index); // 填充模式 sheetStyle.setFillPattern(HSSFCellStyle.FINE_DOTS); // 设置列的样式 for (int i = 0; i &lt;= 14; i++) &#123; sheet.setDefaultColumnStyle((short) i, sheetStyle); &#125; // 设置字体 HSSFFont headfont = workbook.createFont(); headfont.setFontName("黑体"); headfont.setFontHeightInPoints((short) 22);// 字体大小 headfont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);// 加粗 // 另一个样式 HSSFCellStyle headstyle = workbook.createCellStyle(); headstyle.setFont(headfont); headstyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);// 左右居中 headstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);// 上下居中 headstyle.setLocked(true); headstyle.setWrapText(true);// 自动换行 // 另一个字体样式 HSSFFont columnHeadFont = workbook.createFont(); columnHeadFont.setFontName("宋体"); columnHeadFont.setFontHeightInPoints((short) 10); columnHeadFont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); // 列头的样式 HSSFCellStyle columnHeadStyle = workbook.createCellStyle(); columnHeadStyle.setFont(columnHeadFont); columnHeadStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);// 左右居中 columnHeadStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);// 上下居中 columnHeadStyle.setLocked(true); columnHeadStyle.setWrapText(true); columnHeadStyle.setLeftBorderColor(HSSFColor.BLACK.index);// 左边框的颜色 columnHeadStyle.setBorderLeft((short) 1);// 边框的大小 columnHeadStyle.setRightBorderColor(HSSFColor.BLACK.index);// 右边框的颜色 columnHeadStyle.setBorderRight((short) 1);// 边框的大小 columnHeadStyle.setBorderBottom(HSSFCellStyle.BORDER_THIN); // 设置单元格的边框为粗体 columnHeadStyle.setBottomBorderColor(HSSFColor.BLACK.index); // 设置单元格的边框颜色 // 设置单元格的背景颜色（单元格的样式会覆盖列或行的样式） columnHeadStyle.setFillForegroundColor(HSSFColor.WHITE.index); HSSFFont font = workbook.createFont(); font.setFontName("宋体"); font.setFontHeightInPoints((short) 10); // 普通单元格样式 HSSFCellStyle style = workbook.createCellStyle(); style.setFont(font); style.setAlignment(HSSFCellStyle.ALIGN_LEFT);// 左右居中 style.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);// 上下居中 style.setWrapText(true); style.setLeftBorderColor(HSSFColor.BLACK.index); style.setBorderLeft((short) 1); style.setRightBorderColor(HSSFColor.BLACK.index); style.setBorderRight((short) 1); style.setBorderBottom(HSSFCellStyle.BORDER_THIN); // 设置单元格的边框为粗体 style.setBottomBorderColor(HSSFColor.BLACK.index); // 设置单元格的边框颜色． style.setFillForegroundColor(HSSFColor.WHITE.index);// 设置单元格的背景颜色． // 另一个样式 HSSFCellStyle centerstyle = workbook.createCellStyle(); centerstyle.setFont(font); centerstyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);// 左右居中 centerstyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);// 上下居中 centerstyle.setWrapText(true); centerstyle.setLeftBorderColor(HSSFColor.BLACK.index); centerstyle.setBorderLeft((short) 1); centerstyle.setRightBorderColor(HSSFColor.BLACK.index); centerstyle.setBorderRight((short) 1); centerstyle.setBorderBottom(HSSFCellStyle.BORDER_THIN); // 设置单元格的边框为粗体 centerstyle.setBottomBorderColor(HSSFColor.BLACK.index); // 设置单元格的边框颜色． centerstyle.setFillForegroundColor(HSSFColor.WHITE.index);// 设置单元格的背景颜色． try &#123; // 创建第一行 HSSFRow row0 = sheet.createRow(0); // 设置行高 row0.setHeight((short) 900); // 创建第一列 HSSFCell cell0 = row0.createCell(0); cell0.setCellValue(new HSSFRichTextString("中非发展基金投资项目调度会工作落实情况对照表")); cell0.setCellStyle(headstyle); /** * 合并单元格 * 第一个参数：第一个单元格的行数（从0开始） * 第二个参数：第二个单元格的行数（从0开始） * 第三个参数：第一个单元格的列数（从0开始） * 第四个参数：第二个单元格的列数（从0开始） */ CellRangeAddress range = new CellRangeAddress(0, 0, 0, 7); sheet.addMergedRegion(range); // 创建第二行 HSSFRow row1 = sheet.createRow(1); HSSFCell cell1 = row1.createCell(0); cell1.setCellValue(new HSSFRichTextString("本次会议时间：2009年8月31日 前次会议时间：2009年8月24日")); cell1.setCellStyle(centerstyle); // 合并单元格 range = new CellRangeAddress(1, 2, 0, 7); sheet.addMergedRegion(range); // 第三行 HSSFRow row2 = sheet.createRow(3); row2.setHeight((short) 750); HSSFCell cell = row2.createCell(0); cell.setCellValue(new HSSFRichTextString("责任者")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(1); cell.setCellValue(new HSSFRichTextString("成熟度排序")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(2); cell.setCellValue(new HSSFRichTextString("事项")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(3); cell.setCellValue(new HSSFRichTextString("前次会议要求/n/新项目的项目概要")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(4); cell.setCellValue(new HSSFRichTextString("上周工作进展")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(5); cell.setCellValue(new HSSFRichTextString("本周工作计划")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(6); cell.setCellValue(new HSSFRichTextString("问题和建议")); cell.setCellStyle(columnHeadStyle); cell = row2.createCell(7); cell.setCellValue(new HSSFRichTextString("备 注")); cell.setCellStyle(columnHeadStyle); // 访问数据库，得到数据集 List&lt;DeitelVO&gt; deitelVOList = getEntityManager().queryDeitelVOList(); int m = 4; int k = 4; for (int i = 0; i &lt; deitelVOList.size(); i++) &#123; DeitelVO vo = deitelVOList.get(i); String dname = vo.getDname(); List&lt;Workinfo&gt; workList = vo.getWorkInfoList(); HSSFRow row = sheet.createRow(m); cell = row.createCell(0); cell.setCellValue(new HSSFRichTextString(dname)); cell.setCellStyle(centerstyle); // 合并单元格 range = new CellRangeAddress(m, m + workList.size() - 1, 0, 0); sheet.addMergedRegion(range); m = m + workList.size(); for (int j = 0; j &lt; workList.size(); j++) &#123; Workinfo w = workList.get(j); // 遍历数据集创建Excel的行 row = sheet.getRow(k + j); if (null == row) &#123; row = sheet.createRow(k + j); &#125; cell = row.createCell(1); cell.setCellValue(w.getWnumber()); cell.setCellStyle(centerstyle); cell = row.createCell(2); cell.setCellValue(new HSSFRichTextString(w.getWitem())); cell.setCellStyle(style); cell = row.createCell(3); cell.setCellValue(new HSSFRichTextString(w.getWmeting())); cell.setCellStyle(style); cell = row.createCell(4); cell.setCellValue(new HSSFRichTextString(w.getWbweek())); cell.setCellStyle(style); cell = row.createCell(5); cell.setCellValue(new HSSFRichTextString(w.getWtweek())); cell.setCellStyle(style); cell = row.createCell(6); cell.setCellValue(new HSSFRichTextString(w.getWproblem())); cell.setCellStyle(style); cell = row.createCell(7); cell.setCellValue(new HSSFRichTextString(w.getWremark())); cell.setCellStyle(style); &#125; k = k + workList.size(); &#125; // 列尾 int footRownumber = sheet.getLastRowNum(); HSSFRow footRow = sheet.createRow(footRownumber + 1); HSSFCell footRowcell = footRow.createCell(0); footRowcell.setCellValue(new HSSFRichTextString(" 审 定：XXX 审 核：XXX 汇 总：XX")); footRowcell.setCellStyle(centerstyle); range = new CellRangeAddress(footRownumber + 1, footRownumber + 1, 0, 7); sheet.addMergedRegion(range); HttpServletResponse response = getResponse(); HttpServletRequest request = getRequest(); String filename = "未命名.xls";//设置下载时客户端Excel的名称 // 请见：http://zmx.javaeye.com/blog/622529 filename = Util.encodeFilename(filename, request); response.setContentType("application/vnd.ms-excel"); response.setHeader("Content-disposition", "attachment;filename=" + filename); OutputStream ouputStream = response.getOutputStream(); workbook.write(ouputStream); ouputStream.flush(); ouputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;]]></content>
      <categories>
        <category>后端插件</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel导出</tag>
        <tag>HSSFWorkBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据泵导出impdp/expdp]]></title>
    <url>%2F2019%2F03%2F07%2FOracle%E6%95%B0%E6%8D%AE%E6%B3%B5%E5%AF%BC%E5%87%BAimpdp-expdp%2F</url>
    <content type="text"><![CDATA[最近项目上用测试数据库，需要从生产上导出数据，然后本地数据库导入操作，使用exp/imp一直报错，显示文件头无法识别，因此改换成数据泵导入导出，因此进行记录。从中也发现数据泵导入导出比常规imp/exp导入导出要快很多 数据泵是服务器提供的功能，因此从客户机不能使用数据泵导入导出操作，不知道这个观点对不对，没有尝试过 逻辑目录 常规查看逻辑路径的方式常规情况下，一般数据库会有默认的，可以打开PLSQL，在左侧Objects栏中可以看到默认的数据泵导入导出路径目录，具体如下图所示 命令方式查看逻辑路径方式123456789101112131415161718192021[oracle@MCDB ~]$ sqlplus /nologSQL*Plus: Release 11.2.0.4.0 Production on Thu Mar 7 14:59:54 2019Copyright (c) 1982, 2013, Oracle. All rights reserved.SQL&gt; conn jnmcbusi/123456;Connected.SQL&gt; select * from dba_directories;OWNER DIRECTORY_NAME DIRECTORY_PATH------------------------------ ------------------------------SYS DUMP_DIR /home/mgplat_bak/dump_dirSYS XMLDIR /home/oracle/app/oracle/product/11.2.0/dbhome_1/rdbms/xmlSYS ORACLE_OCM_CONFIG_DIR /home/oracle/app/oracle/product/11.2.0/dbhome_1/ccr/hosts/MCDB/stateSYS DATA_PUMP_DIR /home/oracle/app/admin/jnmcdb/dpdump/SYS ORACLE_OCM_CONFIG_DIR2 /home/oracle/app/oracle/product/11.2.0/dbhome_1/ccr/state 创建逻辑目录如果没有逻辑目录，可以进行创建，创建目前知道的有两种方法，创建的时候一定要记得，保证服务器上有这个目录，如果没有，先手动创建，因为Oracle不会创建物理路径 在PLSQL中右键Directories目录，然后点击New...，打开创建界面，然后填写Name和Path这里要注意，填写的Path是服务器上的路径地址，如果是Linux，也要填写服务器上的地址 使用命令创建逻辑目录使用命令创建的时候最好是sysdba，如果没有，也可以使用普通用户尝试一下，我的是成功 12345678[oracle@MCDB ~]$ sqlplus /nologsql&gt; conn username/password@orcl;sql&gt; create directory dump_dir as '/home/mgplat_bak/dump_dir'## `expdp`导出数据- 导出用户及对象```sqlexpdp username/password@orcl dumpfile=daba_back.dmp directory=dump_dir schemas=jnmcbusi 导出指定表 1expdp username/password@orcl dumpfile=daba_back.dmp directory=dump_dir tables=table1,table2 按条件查询导出 1expdp username/password@orcl dumpfile=daba_back.dmp directory=dump_dir tables=table1 query='where deptno=20' 按表空间导出 1expdp username/password@orcl dumpfile=tablespace.dmp directory=dump_dir tablespaces=temp,example 导出整个数据库 1expdp system/manager@orcl directory=dump_dir dumpfile=full.dmp full=y impdp导入数据导入之前确认用户已经创建，如果没有创建，使用下面的命令创建用户 创建表空间 1create tablespace tb_name datafile 'D:\tablespace\tb_name.dbf' size 1024m AUTOEXTEND ON; 创建用户 1create user user_name identified by A123456a default tablespace tb_name temporary tablespace TEMP; 用户授权 123sql&gt;grant read,write on directory dump_dir to user_name;sql&gt;grant dba,resource,unlimited tablespace to user_name; 导入用户 1impdp scott/tiger@orcl directory=dump_dir dumpfile=expdp.dmp schemas=scott; 导入表 1impdp system/manager@orcl directory=dump_dir dumpfile=expdp.dmptables=scott.dept,scott.emp remap_schema=scott:system; 导入表空间 1impdp system/manager@orcl directory=dump_dir dumpfile=tablespace.dmp tablespaces=example; 导入数据库 1impdb system/manager@orcl directory=dump_dir dumpfile=full.dmp full=y; 追加数据 1impdp system/manager@orcl directory=dump_dir dumpfile=expdp.dmp schemas=systemtable_exists_action]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>导入导出</tag>
        <tag>数据泵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库异常解决]]></title>
    <url>%2F2019%2F03%2F07%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[本篇文章是对Oralce遇到的各种问题的一个收集整理，用作后续的排查问题使用 ORA-31655：尚未为作业选择数据或元数据对象 【场景】数据泵导入数据，执行下面的数据导入时123456789101112131415D:\app&gt;impdp jnmcbusi/123456@orcl directory=data_pump_dir dumpfile=MKM_ORGUSER_MAP.dmp tablespaces=jnmcdb_dataImport: Release 11.2.0.1.0 - Production on 星期四 3月 7 11:20:46 2019Copyright (c) 1982, 2009, Oracle and/or its affiliates. All rights reserved.连接到: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsORA-31655: 尚未为作业选择数据或元数据对象已成功加载/卸载了主表 "JNMCBUSI"."SYS_IMPORT_TABLESPACE_01"启动 "JNMCBUSI"."SYS_IMPORT_TABLESPACE_01": jnmcbusi/********@orcl directory=data_pump_dir dumpfile=MKM_ORGUSER_MAP.dmp tablespaces=jnmcdb_data作业 "JNMCBUSI"."SYS_IMPORT_TABLESPACE_01" 已于 11:20:48 成功完成 【原因】数据泵导入数据的时候，因生产环境和本地环境的表空间不同，需要设置新老不同的表空间 【处理方案】1234567891011121314151617D:\app&gt;impdp jnmcbusi/123456@orcl directory=data_pump_dir dumpfile=MKM_CUST_AREA_FX.dmp remap_tablespace=data_custtemp:jnmcdb_dataImport: Release 11.2.0.1.0 - Production on 星期四 3月 7 11:34:36 2019Copyright (c) 1982, 2009, Oracle and/or its affiliates. All rights reserved.连接到: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options已成功加载/卸载了主表 "JNMCBUSI"."SYS_IMPORT_FULL_01"启动 "JNMCBUSI"."SYS_IMPORT_FULL_01": jnmcbusi/********@orcl directory=data_pump_dir dumpfile=MKM_CUST_AREA_FX.dmp remap_tablespace=data_custtemp:jnmcdb_data处理对象类型 TABLE_EXPORT/TABLE/TABLE处理对象类型 TABLE_EXPORT/TABLE/TABLE_DATA. . 导入了 "JNMCBUSI"."MKM_CUST_AREA_FX" 814.9 MB 8607689 行作业 "JNMCBUSI"."SYS_IMPORT_FULL_01" 已于 11:36:11 成功完成 ORA-12546: TNS:permission denied 【场景】使用root账号启动sqlplus /nolog ，连接数据库【原因】root账号下尽量不要操作Oracle相关操作【处理方案】切换到oracle用户下，然后执行相关操作 ORA-08189: cannot flashback the table because row movement is not enabled 【场景】执行数据库表闪回的时候，报错【原因】该表不支持闪回，未设置闪回配置【处理方案】可以通过select flashback_on from v$database;查询是否设置了闪回，可以通过百度设置对应数据库的闪回配置 ORA-12162: TNS:net service name is incorrectly specified 【场景】sqlplus / as sysdba连接数据库的时候【原因】未设置ORACLE_HOME和ORACLE_SID的问题【处理方案】12export ORACLE_HOME="D:\ProgramFiles\Oracle\product\11.2.0\dbhome_1"export ORACLE_SID=orcl 【场景】【原因】【处理方案】 【场景】【原因】【处理方案】 【场景】【原因】【处理方案】]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Oracle11g安装]]></title>
    <url>%2F2019%2F03%2F06%2FWindows%E4%B8%8BOracle11g%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[5年多没有碰Oracle了，从原来的9i已经到现在的12c了，今天项目上要用到Oracle11g的测试环境，因此在Window上部署了一版Oracle，期间碰到的坑还是蛮多的，比如说要安装的电脑上本来安装着10g，需要现卸载，但是咨询说是简版的oracle，卸载程序不生效，又各种捣鼓卸载，删注册表等等，介于此，特此在这记录一下 准备材料下载Oracle的两个安装包，下载地址分别是： win64_11gR2_database_1of2链接：https://pan.baidu.com/s/1AewnMe-mwm54_aRTFAHbSg提取码：vbxg win64_11gR2_database_2of2链接：https://pan.baidu.com/s/1rj9WBsut79NYTgLpEHq3uQ提取码：un5g 如果下载慢，可以去官网上下载，但是下载下来的是12c，哈哈，没有找到之前版本的下载地址下载地址 解压 将下载下来的两个压缩包进行解压，然后合并到一块，可以直接右键解压到当前目录（尽量一个一个解压，防止出现问题），如图所示 解压完成之后，会出现一个合并的database文件夹，文件夹总体大小大概在2.12G左右，具体见下图所示 安装步骤 打开database文件夹，双击setup.exe文件启动安装程序，如果是win10，会显示下面的图片，可以直接点击“是”继续安装，或者修改配置文件，配置文件在下面的步骤中讲到 修改配置文件，修复上面的提示框打开%解压目录%\stage\cvu\cvu_prereq.xml文件，然后修改配置文件内容，修改方法为找到Windows 7所在的OPERATING_SYSTEM，然后整个复制OPERATING_SYSTEM及内部的内容，然后粘贴在OPERATING_SYSTEM的兄弟节点的最后，然后修改RELEASE为6.2，Windows 7改为Windows 10，修改后的内容和粘贴后的配置文件截图如下所示，修改完成后再启动安装程序：12345678&lt;OPERATING_SYSTEM RELEASE="6.2"&gt; &lt;VERSION VALUE="3"/&gt; &lt;ARCHITECTURE VALUE="64-bit"/&gt; &lt;NAME VALUE="Windows 10"/&gt; &lt;ENV_VAR_LIST&gt; &lt;ENV_VAR NAME="PATH" MAX_LENGTH="1023" /&gt; &lt;/ENV_VAR_LIST&gt;&lt;/OPERATING_SYSTEM&gt; 在此打开安装程序，界面显示如下，其中的电子邮件和我希望...可选填，不填后面会提醒“是否确认不希望收到相关配置中的…”，直接点击是就可以了 网格安装选项、安装类型，具体操作见下图 典型安装 后面我就盗图了，因为已经安装过了，所以提示其他内容了 先决条件检查，检查电脑硬件是否满足条件 概要信息，即安装信息的概要显示 安装过程不用管，界面显示如下图 数据库软件安装完成后，会弹出安装数据库默认实例ORCL名称数据库的向导界面，如下图所示 数据库实例创建完后，系统默认是把所有的账户锁定（除sys和system外），建议点开“口令管理”，将scott账号解锁，并设置密码，操作如下图所示 安装完成后的界面如下 创建自己业务上需要的数据库即新建数据库实例 点击Win键，找到Oracle文件夹下面的Database Configuration Assitant菜单，并点击打开，具体见下图 打开之后，点击下一步，勾选创建数据库后点击下一步 选择一般用途或事务处理，点击下一步，填写数据库实例，然后点击下一步 剩下的一路Next，字符集看自己需求，如果有需要，可以对应的设置，直到下面的界面，然后点击完成会出一个汇总信息界面，点击确定，就会打开创建的Progress界面 在对应的数据库实例下面创建表空间，表数据空间等 在客户端机子上修改tnsnames.ora文件，添加新创建数据库的信息，修改里面的HOST为Oracle服务器的IP地址，SERVICE_NAME为你创建数据库实例的名称 12345678khgl_116 = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 68.0.0.116)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ORCL) ) ) 使用创建数据库时的sys用户连接数据库，并执行下面的命令创建表空间和表数据控件 123456789101112131415161718-- 创建表空间create temporary tablespace jnmcdb_table tempfile 'D:\app\Administrator\oradata\orcl\jnmcdb_table.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;-- 创建表数据空间create tablespace jnmcdb_data logging datafile 'D:\app\Administrator\oradata\orcl\jnmcdb_data.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local;-- 创建用户关联到表空间和表数据空间 create user jnmcbusi identified by 123456 default tablespace jnmcdb_data temporary tablespace jnmcdb_table ; 数据导入1imp username/password@ORALCEID（数据库名，以下图，在登录后左上方） file=D:\20140227.dmp full=y ignore=y 问题解决 本机可以正常访问，局域网内其他主机访问显示ORA-12541:TNS:无监听程序，修复方法见下图]]></content>
      <categories>
        <category>软件安装</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Oracle安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux学习之路-安装]]></title>
    <url>%2F2019%2F03%2F03%2FKali-Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[从今天开始准备学习一下Kali Linux，也算是个人的一点兴趣爱好，喜欢干些自己之前没有涉及过的区域，今天第一天开篇，讲讲Kali Linux操作系统和系统的安装，后续会讲到自己在使用过程中碰到的问题，以及一些使用的技巧，这个坑呢算是从这里开始挖了，到最后能不能填完，还得看有没有充裕的时间了 Kali Linux Kali Linux is a Debian-based Linux distribution aimed at advanced Penetration Testing and Security Auditing. Kali contains several hundred tools which are geared towards various information security tasks, such as Penetration Testing, Security research, Computer Forensics and Reverse Engineering. Kali Linux is developed, funded and maintained by Offensive Security, a leading information security training company. 上面引用的这段是官网上说的，Kali Linux是基于Debian系统的分布式系统，主要用作高级渗透测试和安全审计。它包含了百种工具，适用于各种安全任务，像渗透测试，安全研究，计算机取证或者逆向工程等。 安装Kali Linux可以在Win系统或者Linux系统下进行安装，官网推荐使用U盘进行安装，当然也可以在Laptop上安装，我们这里就单纯讲在U盘上安装，因为方便，随时找个电脑拿过U盘来，插上就能启动Kali- Windows操作系统安装Kali需要准备的材料 4G以上空间的U盘一个：推荐8G以上的，因为后面要做数据持久化，也就是修改内容都可以直接存储在U盘里面 Window操作系统的电脑一台，用作给U盘装Kali Kali的系统安装镜像（下面会讲到该怎么下载及具体的下载地址） Win32DiskImager软件（下面会讲到下载地址）准备材料 下载Kali 操作系统镜像Kali操作系统的下载地址，打开这个地址，然后选择Kali Linux 64 Bit这个版本的镜像，然后下载，下载的时候尽量使用下载工具，因为我之前使用HTTP下载的时候都有出现过中断的情况，具体的操作步骤如下图所示 下载Win32DiskImagerWin32DiskImager下载地址，这个的下载和安装很简单，就不上图了，自己安装即可安装Kali Win系统插入U判断，保证U盘是空的或者备份好自己的文件 打开Win32DiskImager软件，并选择Kali 镜像，其中设备区域中的G是我插入U盘的盘符，并选择写入按钮，具体操作见下图 大概20分钟左右（看U盘写入速度），即可完成刻录，值此系统安装成功 将U盘插到电脑上重启，U盘优先启动，各个电脑不同有的是重启摁F2、F12、Delete键，有的是按其他，选择完U盘启动之后即可进入Kali Linux系统界面 Kali Linux的默认账号和密码是root/toor，如果没有改过密码的情况下，那应该是toor 持久化数据到U盘（即修改信息后U盘可保存）常规情况下，系统做完之后，插在电脑上启动，修改的账号密码等等信息是不会保存的，需要一些额外的设置，才能保存到U盘当中，以下是详细的操作流程 准备工具 MiniTool Partition Wizard Free Edition for Windows.（下载地址）]]></content>
      <categories>
        <category>安全测评</category>
        <category>Kali Linux</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中Calendar使用及日期增减]]></title>
    <url>%2F2019%2F03%2F02%2FJava%E4%B8%ADCalendar%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%97%A5%E6%9C%9F%E5%A2%9E%E5%87%8F%2F</url>
    <content type="text"><![CDATA[Calendar的使用12345678910111213Calendar cal = Calendar.getInstance(); //首先需要实例化一个calendarcal.get(Calendar.DATE);//-----------------------当天 1-31cal.get(Calendar.DAY_OF_MONTH);//---------------当天 1-12cal.get(Calendar.DAY_OF_WEEK);//----------------从星期天开始计算，如果今天星期二，那么返回3cal.get(Calendar.DAY_OF_YEAR);//----------------cal.get(Calendar.HOUR);//-----------------------12小时制cal.get(Calendar.HOUR_OF_DAY);//----------------24小时制，一般使用这个属性赋值cal.get(Calendar.MILLISECOND);//----------------cal.get(Calendar.MINUTE);//---------------------cal.get(Calendar.SECOND);//---------------------cal.get(Calendar.WEEK_OF_MONTH);//--------------cal.get(Calendar.WEEK_OF_YEAR);//---------------cal.get(Calendar.MONTH);//-----------------------月份获取需要 +1，那么，赋值时需要 -1 日期加减1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 日期相加减 * @param time * 时间字符串 yyyy-MM-dd HH:mm:ss * @param num * 加的数，-num就是减去 * @return * 减去相应的数量的年的日期 * @throws ParseException */ public static Date yearAddNum(Date time, Integer num) &#123; //SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //Date date = format.parse(time); Calendar calendar = Calendar.getInstance(); calendar.setTime(time); calendar.add(Calendar.YEAR, num); Date newTime = calendar.getTime(); return newTime; &#125; /** * * @param time * 时间 * @param num * 加的数，-num就是减去 * @return * 减去相应的数量的月份的日期 * @throws ParseException Date */ public static Date monthAddNum(Date time, Integer num)&#123; //SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //Date date = format.parse(time); Calendar calendar = Calendar.getInstance(); calendar.setTime(time); calendar.add(Calendar.MONTH, num); Date newTime = calendar.getTime(); return newTime; &#125; /** * * @param time * 时间 * @param num * 加的数，-num就是减去 * @return * 减去相应的数量的天的日期 * @throws ParseException Date */ public static Date dayAddNum(Date time, Integer num)&#123; //SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //Date date = format.parse(time); Calendar calendar = Calendar.getInstance(); calendar.setTime(time); calendar.add(Calendar.DAY_OF_MONTH, num); Date newTime = calendar.getTime(); return newTime; &#125; 引用java日期加减年月日Java Calendar使用]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日期操作</tag>
        <tag>Calendar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取时间]]></title>
    <url>%2F2019%2F03%2F02%2Fjs%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[获取基础时间数据1var myDate = new Date();//获取系统的当前时间 格式化基础时间根据需求，格式化获取到的基础数据12345678910111213myDate.getYear();//获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>获取时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle/MySQL实现根据一个表更新另一张表]]></title>
    <url>%2F2019%2F03%2F02%2FOracle-MySQL%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9B%B4%E6%96%B0%E5%8F%A6%E4%B8%80%E5%BC%A0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最近接到一个从DB2数据导出，Oracle数据库导入的工作，导入到Oracle时肯定不能直接使用业务表，需要创建临时表，然后通过临时表更新业务表，那么问题来了，有更新有插入，该如何处理，之前记得MySQL是支持update A,B…操作的，Oracle之前没有听过，因此百度了下，得到的结论如下文所示 OracleOracle中可以使用MERGE INTO语句1234567891011121314151617181920MERGE INTO T_USER T1 USING ( SELECT userid AS id, NAME AS username, sex AS usersex FROM DUAL) T2 ON (T1.userid = T2.id) WHEN MATCHED THEN UPDATESET t1. NAME = t2.username, t1.sex = t2.usersex WHEN NOT MATCHED THEN INSERT (userid, NAME, sex)VALUES ( t2.id, t2.username, t2.usersex ) MySQLMySQL有则更新，无则插入mysql中可以使用ON DUPLICATE KEY进行处理，但是需要注意的是需要有主键，下面的实例中需要userid是主键1234INSERT INTO T_USER (userid, NAME, sex)VALUES (id, username, usersex) ON DUPLICATE KEY UPDATE NAME = username, sex = usersex; 单纯表更新这种方式只是单纯的根据一个表的数据更新另一张的数据12345UPDATE table_1 t1, table_2 t2SET t1. COLUMN = t2. COLUMNWHERE t1.id = t2.pid 引用：Oracle实现一张表根据另一张表更新（有则更新无则插入）]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle/MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Oracle</tag>
        <tag>跨表更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2数据表Oracle数据库导入]]></title>
    <url>%2F2019%2F03%2F01%2FDB2%E6%95%B0%E6%8D%AE%E8%A1%A8Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[本操作手册用作从信贷系统导出操作员基本数据、机构信息数据等基础数据，然后在客户管理平台中导入的引导手册 基础数据准备需要先从行方获取对应的数据，获取数据的对应规则和对应字段的顺序一定要给行方人员说明清楚，然后他根据规则从信贷系统中根据你要的规则从DB2中导出数据，导出的文件是.del类型的文件 修改脚本 将行方给的.del文件放到服务器上，记录下路径，本例为/home/20190301/user.del 创建临时表 1234-- 只需要创建一个表结构相同的表CREATE TABLE SYS_OPER_TEMP AS SELECT * FROM SYS_OPER WHERE 1=2;-- 下面只会显示表的结构，没有数据SELECT * FROM SYS_OPER_TEMP; 修改下这块代码中的第二行为第一步中的路径，修改第三行为你要导入的表，这个地方最好是创建一个临时表，防止与服务器的数据冲突造成业务异常，同时还需要保证要导入的表不能有数据，第六行的括号里面包裹的内容是上面创建的临时表的字段，而且字段的顺序要和del文件的顺序保持一致，然后保存为一个.ctl的文件，本例为SYS_OPER_TEMP.ctl，然后将这个文件也上传到/home/20190301目录下 1234567891011121314load datainfile &quot;/home/20190301/org.del&quot;into table SYS_OPER_TEMPfields terminated by &quot;,&quot; optionally enclosed by &apos;&quot;&apos;trailing nullcols( USERID, USERNAME, LOGINID, DEPTID, ORGID, PHONENUM, IDCARDNO) 远程登录服务器执行su - oracle切换到oracle用户，然后执行sqlplus /nolog，登录Oracle 12345678910[root@MCDB ~]# su - oracle上一次登录：五 3月 1 23:53:37 CST 2019pts/2 上-bash: $'\302\240': command not found[oracle@MCDB ~]$ sqlplus /nologSQL*Plus: Release 11.2.0.4.0 Production on Fri Mar 1 23:58:49 2019Copyright (c) 1982, 2013, Oracle. All rights reserved.SQL&gt; 执行下面的命令，开始导入数据（执行前需要修改成自己的路径和文件） 1host sqlldr userid=jnmcbusi/123456@jnmcdb control=/home/20190301/SYS_OPER_TEMP.ctl log=/home/ctl/user.log 剩下的就是从临时表更新业务表了 附件Oracle查询一个表的数据更新另一张表的数据 123456789101112131415161718MERGE INTO SYS_OPER T1USING (SELECT USERID, ORGID, DEPTID, USERNAME, LOGINID, PHONENUM, IDCARDNO FROM SYS_OPER_TEMP) T2ON (T1.USERID = T2.USERID)WHEN MATCHED THEN UPDATE SET T1.ORGID = T2.ORGID, T1.DEPTID = T2.DEPTIDWHEN NOT MATCHED THEN INSERT (USERID, ORGID, DEPTID, USERNAME, LOGINID, PASSWORD, PHONENUM, IDCARDNO) VALUES (T2.USERID,T2.ORGID,T2.DEPTID,T2.USERNAME,T2.LOGINID,'e10adc3949ba59abbe56e057f20f883e',T2.PHONENUM,T2.IDCARDNO);]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>DB2</tag>
        <tag>数据导入导出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NamedParameterJdbcTemplete使用方法总结]]></title>
    <url>%2F2019%2F02%2F27%2FNamedParameterJdbcTemplete%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近修复SQL注入的问题，单当遇到in操作的时候，直接使用?占位符是行不通的，因此进行查询发现NamedParameterJDBCTemplate能够修复这种问题，因此在这里记录下NamedParameterJDBCTemplate的使用方式，常规NamedParameterJDBCTemplate提供execute方法、query及queryForXXX方法、update和batchUpdate方法 支持类SqlParameterSource简介SqlParameterSource命名参数设置 MapSqlParameterSource 使用java.util.Map封装使用 BeanPropertySqlParameterSource封装了JavaBean对象，通过对象传递参数 EmptySqlParameterSource空的，一般用作占位RowMapper简介实现sql查询结果和对象之间的转换，可自己实现或者系统实现，主要的实现类： SingleColumnRowMapper，sql查询结果为单列数据，如List&lt;String&gt;、List&lt;Integer&gt;、String、Integer BeanPropertyRowMapper,sql 结果匹配到对象List&lt;JavaBean&gt;,JavaBean updateXXX方法使用Map作为参数API：int update(String sql,Map&lt;String,Object&gt; map)12345Map&lt;String,Obejct&gt; paramMap = new HashMap&lt;String,Object&gt;();paramMap.put("id","1");paramMap.put("name","1");template.update("INSERT INTO TEMP_TABLE VALUES(:id,:name)",paramMap); BeanPropertySqlParameterSource作为参数API：int update(String sql, BeanPropertySqlParameterSource paramSource)1234public class Student&#123; private String name; private int age;&#125; 1234Student st = new Student();st.setName("张三");st.setAge(10);template.update("INSERT INTO STUDENT VALUES(:name,:age)",new BeanPropertySqlParameterSource(st)); MapSqlParameterSource作为参数API:int update(String sql,MapSqlParameterSource paramSource)12MapSqlParameterSource paramSource = new MapSqlParameterSource().addValue("name","张三").addValue("age",10);template.update("INSERT INTO STUDENT VALUES (:name,:age)",paramSource); 查询单行单列数据API:public T queryForObject(String sql,Map&lt;String,Object&gt; paramMap,Class requiredType)API:public T queryForObject(String sql,SqlParameterSource paramSource,Class requiredType)1Integer tempInt = template.queryForObject("select count(*) from student ",new HashMap&lt;String,Object&gt;(),Integer.class); 1String name = template.queryForObject("select name from student limit 1",EmptySqlParameterSource.INSTANCE,String.class); 多行数据查询API：public&lt;T&gt; List&lt;T&gt;queryForList(String sql,Map&lt;String,Object&gt; paramMap,Class&lt;T&gt; elementType)API: public &lt; T&gt; List&lt; T&gt; queryForList(String sql, SqlParameterSource paramSource, Class&lt; T&gt; elementType)1List&lt; String&gt; namelist = template.queryForList("select name from student", new HashMap&lt;&gt;(), String.class); 单行数据查询API：public &lt; T&gt; T queryForObject(String sql, Map&lt; String, ?&gt; paramMap, RowMapper&lt; T&gt;rowMapper)API:public &lt; T&gt; T queryForObject(String sql, SqlParameterSource paramSource, RowMapper&lt; T&gt; rowMapper)1234Student stu = template.queryForObject( "select * from student limit 1", new HashMap&lt;&gt;(), new BeanPropertyRowMapper&lt;Student&gt;(Student.class));//BeanPropertyRowMapper会把下划线转化为驼峰属性//结果对象可比实际返回字段多或者少 这两个API也可以使用SingleColumnRowMapper返回单行单列数据12String name = template.queryForObject( "select name from student limit 1", EmptySqlParameterSource.INSTANCE, new SingleColumnRowMapper&lt;&gt;(String.class)); 单行数据（Map）API：public Map&lt; String, Object&gt; queryForMap(String sql, Map&lt; String, ?&gt; paramMap)API：public Map&lt; String, Object&gt; queryForMap(String sql, SqlParameterSource paramSource)1Map&lt; String, Object&gt; studentMap = template.queryForMap("select * from student limit 1", new HashMap&lt;&gt;()); 多行数据API：public &lt; T&gt; List&lt; T&gt; query(String sql, Map&lt; String, ?&gt; paramMap, RowMapper&lt; T&gt; rowMapper)API：public &lt; T&gt; List&lt; T&gt; query(String sql, SqlParameterSource paramSource, RowMapper&lt; T&gt; rowMapper)API：public &lt; T&gt; List&lt; T&gt; query(String sql, RowMapper&lt; T&gt; rowMapper)1234List&lt; Student&gt; studentList = template.query( "select * from student", new BeanPropertyRowMapper&lt;&gt;(Student.class)); 多行数据（Map）API：public List&lt; Map&lt; String, Object&gt;&gt; queryForList(String sql, Map&lt; String, ?&gt; paramMap)API：public List&lt; Map&lt; String, Object&gt;&gt; queryForList(String sql, SqlParameterSource paramSource)1List&lt;Map&lt;String, Object&gt;&gt; mapList = template.queryForList("select * from student", new HashMap&lt;&gt;()); 应用SQL注入中in问题的解决1234567891011121314public void queryListByMapSqlParameterSource(List&lt;String&gt; userids)&#123; String sql = "select * from user_table u where u.user_id in (:userids )"; MapSqlParameterSource parameters = new MapSqlParameterSource(); parameters.addValue("userids", userids); List&lt;Map&lt;String,Object&gt;&gt; list = namedJdbcTemplate.queryForList(sql, parameters); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println("-------------------"); System.out.println(map.get("user_id")); System.out.println(map.get("user_name")); &#125;&#125; 本文引自NamedParameterJdbcTemplate常用方法总结本文引自springjdbc-NamedParameterJdbcTemplate处理in查询]]></content>
      <categories>
        <category>安全测评</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>JDBCTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL行转列问题及内部排序问题]]></title>
    <url>%2F2019%2F02%2F24%2FMySQL%E8%A1%8C%E8%BD%AC%E5%88%97%E9%97%AE%E9%A2%98%E5%8F%8A%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常规情况下是用不到行转列的，但是在今天做Echarts图标的时候，发现查出来的数据是纵向的，所以查了下行转列及GROUP_CONCAT 常规行转列 数据脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485-- 创建表 学生表CREATE TABLE `student` ( `stuid` VARCHAR(16) NOT NULL COMMENT '学号', `stunm` VARCHAR(20) NOT NULL COMMENT '学生姓名', PRIMARY KEY (`stuid`))COLLATE='utf8_general_ci'ENGINE=InnoDB;-- 课程表CREATE TABLE `courses` ( `courseno` VARCHAR(20) NOT NULL, `coursenm` VARCHAR(100) NOT NULL, PRIMARY KEY (`courseno`))COMMENT='课程表'COLLATE='utf8_general_ci'ENGINE=InnoDB;-- 成绩表CREATE TABLE `score` ( `stuid` VARCHAR(16) NOT NULL, `courseno` VARCHAR(20) NOT NULL, `scores` FLOAT NULL DEFAULT NULL, PRIMARY KEY (`stuid`, `courseno`))COLLATE='utf8_general_ci'ENGINE=InnoDB;-- 插入数据-- 学生表数据Insert Into student (stuid, stunm) Values('1001', '张三');Insert Into student (stuid, stunm) Values('1002', '李四');Insert Into student (stuid, stunm) Values('1003', '赵二');Insert Into student (stuid, stunm) Values('1004', '王五');Insert Into student (stuid, stunm) Values('1005', '刘青');Insert Into student (stuid, stunm) Values('1006', '周明');-- 课程表数据Insert Into courses (courseno, coursenm) Values('C001', '大学语文');Insert Into courses (courseno, coursenm) Values('C002', '新视野英语');Insert Into courses (courseno, coursenm) Values('C003', '离散数学');Insert Into courses (courseno, coursenm) Values('C004', '概率论与数理统计');Insert Into courses (courseno, coursenm) Values('C005', '线性代数');Insert Into courses (courseno, coursenm) Values('C006', '高等数学(一)');Insert Into courses (courseno, coursenm) Values('C007', '高等数学(二)');-- 成绩表数据Insert Into score(stuid, courseno, scores) Values('1001', 'C001', 67);Insert Into score(stuid, courseno, scores) Values('1002', 'C001', 68);Insert Into score(stuid, courseno, scores) Values('1003', 'C001', 69);Insert Into score(stuid, courseno, scores) Values('1004', 'C001', 70);Insert Into score(stuid, courseno, scores) Values('1005', 'C001', 71);Insert Into score(stuid, courseno, scores) Values('1006', 'C001', 72);Insert Into score(stuid, courseno, scores) Values('1001', 'C002', 87);Insert Into score(stuid, courseno, scores) Values('1002', 'C002', 88);Insert Into score(stuid, courseno, scores) Values('1003', 'C002', 89);Insert Into score(stuid, courseno, scores) Values('1004', 'C002', 90);Insert Into score(stuid, courseno, scores) Values('1005', 'C002', 91);Insert Into score(stuid, courseno, scores) Values('1006', 'C002', 92);Insert Into score(stuid, courseno, scores) Values('1001', 'C003', 83);Insert Into score(stuid, courseno, scores) Values('1002', 'C003', 84);Insert Into score(stuid, courseno, scores) Values('1003', 'C003', 85);Insert Into score(stuid, courseno, scores) Values('1004', 'C003', 86);Insert Into score(stuid, courseno, scores) Values('1005', 'C003', 87);Insert Into score(stuid, courseno, scores) Values('1006', 'C003', 88);Insert Into score(stuid, courseno, scores) Values('1001', 'C004', 88);Insert Into score(stuid, courseno, scores) Values('1002', 'C004', 89);Insert Into score(stuid, courseno, scores) Values('1003', 'C004', 90);Insert Into score(stuid, courseno, scores) Values('1004', 'C004', 91);Insert Into score(stuid, courseno, scores) Values('1005', 'C004', 92);Insert Into score(stuid, courseno, scores) Values('1006', 'C004', 93);Insert Into score(stuid, courseno, scores) Values('1001', 'C005', 77);Insert Into score(stuid, courseno, scores) Values('1002', 'C005', 78);Insert Into score(stuid, courseno, scores) Values('1003', 'C005', 79);--select st.stuid,st.stunm from student st;select sc.stuid , sc.courseno,sc.scores from score sc ;select cs.courseno,cs.coursenm from courses cs; 要求查询每个学生的 每门课程与每门成绩 123456789101112select st.stuid 编号, st.stunm 姓名 ,Max(case c.coursenm when '大学语文' then s.scores else 0 end ) '大学语文',max(case c.coursenm when '新视野英语' then IFNULL(s.scores,0)else 0 end) '新视野英语',Max(case c.coursenm when '离散数学' then IFNULL(s.scores,0) ELSE 0 END) '离散数学',MAX(case c.coursenm when '概率论与数理统计' then IFNULL(s.scores,0) else 0 end) '概率论与数理统计',MAX(case c.coursenm when '线性代数' then IFNULL(s.scores,0) else 0 END) '线性代数',MAX(case c.coursenm when '高等数学(一)' THEN IFNULL(s.scores,0) else 0 end) '高等数学(一)',MAX(case c.coursenm when '高等数学(二)' THEN IFNULL(s.scores,0) else 0 end) '高等数学(二)'from student stLEFT JOIN score s on st.stuid = s.stuidLEFT JOIN courses c on c.courseno = s.coursenoGROUP BY st.stuid GROUP_CONCAT该函数返回带有来自一个组的连接的非NULL值的字符串结果。白话解释：group_concat()会计算哪些行属于同一组，将属于同一组的列显示出来。要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据group by指定的列进行分组12345678SELECT s.stuid 编号, GROUP_CONCAT(courseno) 课程号, GROUP_CONCAT(s.scores) 成绩FROM score sGROUP BY s.stuid 查询结果图 GROUP_CONCAT内部排序不能直接查询出来就算了，在Echarts里面需要进行日期的排序，因此就有了如下SQL，也就是出来的数据能够自定义进行排序 1GROUP_CONCAT( columnA ORDER BY columnA) 本文引自mysql行转列转换]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>行转列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse中Tomcat热部署问题]]></title>
    <url>%2F2019%2F02%2F24%2FEclipse%E4%B8%ADTomcat%E7%83%AD%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近接了一个比较坑的项目，用的是Eclipse，而且插件都是老古董级别的，因此有很多不兼容或者异常的问题，而且之前都是用的MyEclipse或者IDEA，这次用Eclipse突然间各种不适应，特别是Tomcat的问题，一修改文件就自己重启，因此查了下，发现这个方案是可以修复的，具体的步骤如下 找到Servers，然后双击你需要修改的Tomcat，具体界面如下 打开Tomcat配置界面后，下面会分成两个TAB页卡，点击Modules 选择项目，点击Edit按钮，然后去掉Auto Reloading…的复选框，点击Ok，关闭配置页面，操作见下图 在项目栏中找到Servers，打开它下面的server.xml，将Context中的reloadable修改为false，如果没有，需要说动添加，具体见下图 本文引自Eclipse下设置tomcat,修改Java代码不必重启tomcat]]></content>
      <categories>
        <category>办公知识</category>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>热部署</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali-Linux-Revealed(About Kali Linux)]]></title>
    <url>%2F2019%2F02%2F21%2FKali-Linux-Revealed-About-Kali-Linux%2F</url>
    <content type="text"><![CDATA[Pursepose and Use CasesThese tasks and activities include: Information Collection:Collecting data about the target network and its structure,idetifying computers,their operating systems,and the services that they run.Idetifying potentially(可能)sensitive parts of the information system.Extracting all sorts of listings from running directory services. Vulnerability(漏洞) Analysis:Quickly testing whether a local or remote system is afffected bt a number of known vulnerabilities or insecure(不安全) configurations.Vulnerability scanners use databases containing thousands of signatures(签名) to idetify potential(潜在) vulnerabilities. Web Application Analysis:idetifying misconfigurations and security weakness in web applications. It is crucial(重要) to idetify and mitigate these issues given that the public availability of these applications makes them idel targets for attacker. Database Assessment(评定):From SQL injection(注入) to attacking credentials,database attacks are a very common vector for attackers. Tools that test for the attack vectors ranging from SQL inhection to data extraction and analysis can be found here. Password Attack：Authentication systems are always a go-to attack vector. Many useful tools can be found here,from online password attack tools to offline attack against the encryption(加密) or hashing systems. Wireless Attacks:]]></content>
      <categories>
        <category>安全测评</category>
      </categories>
      <tags>
        <tag>Kali Linux</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派操作摄像头]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%93%8D%E4%BD%9C%E6%91%84%E5%83%8F%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[连接方式：连接器的位置：90度垂直连接器，HDMI口旁边那个。连接时触点一侧朝向HDMI接口 1. 首先进行系统和软件升级12sudo apt-get updatesudo apt-get upgrade 2. 设置摄像头enable1sudo raspi-config ①首先选择Interfacing Options②选择Camera③选择Yes，然后回车④显示设置成功提示⑤重启树莓派1sudo reboot 3. 使用摄像头拍一张照片1raspistill -o image.jpg #会在当前目录下生成一张叫image.jpg的图片 4. 使用摄像头录制一段(h264格式的)视频12raspivid -o video.h264raspivid -o video.h264 -t 10000 #录制一段10S中的视频 5. 以demo模式录制视频（没太懂）1raspivid -o video.h264 -t 10000 -d 以下是原英文的 How to use the Raspberry Pi camera software raspivid is a command line application that allows you to capture video with the camera module, while the applicationraspistill allows you to capture images. -o or –output specifies the output filename and -t or –timeout specifies the amount of time that the preview will be displayed in milliseconds. Note that this set to 5s by default and that raspistill will capture the final frame of the preview period. -d or –demo runs the demo mode that will cycle through the various image effects that are available. Example commandsCapture an image in jpeg format:1raspistill -o image.jpg Capture a 5s video in h264 format: 1raspivid -o video.h264 Capture a 10s video:1raspivid -o video.h264 -t 10000 Capture a 10s video in demo mode:1raspivid -o video.h264 -t 10000 -d To see a list of possible options for running raspivid or raspistill, you can run: raspivid | less raspistill | less Use the arrow keys to scroll and type q to exit. Extended documentation is available. Note that we recommend that you change SSH password if you are using a camera, in order to prevent unwanted access. How to stream video from the Raspberry Pi camera over a networkTo view the feed on LinuxInstall the dependencies by running the following in a terminal:1sudo apt-get install mplayer netcat Find your IP address by running ifconfig. (Your IP address will be listed in the console output and will probably be of the form 192.168.1.XXX). Run the following command in a terminal to view the feed using MPlayer:1nc -l -p 5001 | mplayer -fps 31 -cache 1024 - To view the feed on WindowsInstall and run Linux instead. Find your IP address by running ipconfig. (Your IP address will be listed in the console output and will probably be of the form 192.168.1.XXX). Download MPlayer. Download Netcat. Note that your browser may complain that these files are malicious, as they are unsigned executables. Press the Windows key and the ‘r’ key simultaneously to bring up the “Run” dialog. Enter cmd.exe into the dialog and press enter/return to open a DOS prompt. Enter the following command at the prompt to view the feed using MPlayer: [Path to nc.exe]\nc.exe -L -p 5001 | [Path to mplayer.exe]\mplayer.exe -fps 31 -cache 1024 - To view the feed on OS XDownload MPlayer. Alternatively, you can download mplayer using Brew, which we recommend. Find your IP address by running ifconfig. (Your IP address will be listed in the console output and will probably be of the form 192.168.1.XXX). Run the following command in Terminal to view the feed using MPlayer: nc -l -p 5001 | mplayer -fps 31 -cache 1024 - To view the feed on a Raspberry Pi: Find your IP address by running ifconfig. (Your IP address will be listed in the console output and will probably be of the form 192.168.1.XXX). Run the following commands in a terminal on the receiving Pi: mkfifo buffer nc -p 5001 -l &gt; buffer | /opt/vc/src/hello_pi/hello_video/hello_video.bin buffer To transmit the feed from the Pi with camera module attached After setting up the “receiving” machine as per the instructions above, run the following commands in a terminal on the “transmitting” Pi: raspivid -t 999999 -o – | nc [insert the IP address of the client] 5001 You can then use the commands listed in the “How to use the Raspberry Pi camera software” section above to change the capture time or to add a video effect]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>摄像头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3GPIO引脚图]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE3GPIO%E5%BC%95%E8%84%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>引脚图</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装LiRC配合红外接收（HX1838B）记录遥控发射内容]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85LiRC%E9%85%8D%E5%90%88%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6%EF%BC%88HX1838B%EF%BC%89%E8%AE%B0%E5%BD%95%E9%81%A5%E6%8E%A7%E5%8F%91%E5%B0%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[废话 最近想制作一个家庭智能遥控系统，控制空调等设备，因此就像用家里积灰的树莓派做个空调智能控制器，初步的思路很简单，就是先判定时间，如果是到了下午六点，温度还在30度以上，发起指令，控制空调启动设置温度为27℃，也可以通过APP远程进行启动和关闭 步骤1.HX 1838B(红外接收模块)连线示意图如下： HW-483(发送红外模块)连线示意图如下： 2.安装LiRC12$ sudo apt-get update$ sudo apt-get install lirc 添加下面这几行到/etc/modules中12lirc_devlirc_rpi gpio_in_pin=18 gpio_out_pin=17 添加下面这几行到文件/etc/lirc/hardware.conf中，如果这个文件不存在，可以直接创建12345LIRCD_ARGS=&quot;--uinput --listen&quot;LOAD_MODULES=trueDRIVER=&quot;default&quot;DEVICE=&quot;/dev/lirc0&quot;MODULES=&quot;lirc_rpi&quot; 添加下面的代码到/boot/config.txt文件中1dtoverlay=lirc-rpi,gpio_in_pin=18,gpio_out_pin=17 修改这个文件/etc/lirc/lirc_options.conf中的driver和device对应的值12driver = defaultdevice = /dev/lirc0 关闭服务然后进行启动，使上面的配置文件生效12$ sudo /etc/init.d/lircd stop$ sudo /etc/init.d/lircd start 检查lirc的启动状态1$ sudo /etc/init.d/lircd status 在测试之前重启系统1$ reboot 检测lirc状态是否正常123456$ sudo /etc/init.d/lircd stop$ mode2 -d /dev/lirc0&lt;摁遥控上的遥控键，看是否打印一些带有pulse和space的字符&gt;pulse 560space 1706pulse 535 3. 录制普通的遥控器12$ sudo /etc/init.d/lircd stop$ sudo irrecord -d /dev/lirc0 ~/lircd.conf 根据提示进行操作，其中需要输入到遥控器的名称，其中得注意，如果摁键的时间最好在1S多点，保证出现两个点以上，不超过10个，然后把所有的键都摁一边 备份系统自带的 lircd.conf，然后把生成的配置文件拷贝到/etc/lirc/l下123$ sudo mv /etc/lirc/lircd.conf /etc/lirc/lircd_original.conf$ sudo cp ~/lircd.conf /etc/lirc/lircd.conf$ sudo /etc/init.d/lircd start 使用下面的命令测试按键是否生效12$ irsend SEND_ONCE &lt;遥控器的名字&gt; KEY_POWER$ irsend SEND_ONCE &lt;device-name&gt; KEY_VOLUMEUP 4.录制空调遥控器空调遥控器这种带逻辑控制的比较麻烦.每次发射的都是含有温度、模式、制冷制热等一连串的指令，按照之前irrecord指令生成conf文件，行不通，只能使用raw的原始码，记录也是通过mode2 命令实现①首先制作模板，得到的模板见下面,如果不行可以直接拷贝下面的代码12sudo /etc/init.d/lircd restartirrecord -f -d /dev/lirc0 ~/lircd.conf #制作模板，具体的模板制作过程和上面一样 1234567891011121314151617begin remote name /home/pi/lircd.conf flags RAW_CODES eps 30 aeps 100 gap 19886 begin raw_codes name KEY_OPEN 90 102 331 end raw_codesend remote ②接下来就是录制,然后把第一行最大的数去掉，把剩下的填到对应的按钮下面，然后重复上面的操作，记录多个按钮，然后填在对应的按钮下面，配置完的配置文件如下12# -m --mode 使用行列显示模式，不显示pulse、spacemode2 -m -d /dev/lirc0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121begin remote name air flags RAW_CODES eps 30 aeps 100 gap 19987 begin raw_codes name KEY_CLOSE 8990 4486 677 1630 680 527 651 555 679 527 680 527 676 530 679 527 682 523 682 1629 684 523 681 523 682 1629 679 525 688 519 655 551 680 533 673 526 682 526 682 522 654 554 653 561 672 1627 681 528 678 528 683 525 678 528 678 525 691 527 670 1628 681 525 682 1626 682 526 682 523 692 1615 683 522 682 19958 687 522 683 549 660 519 684 520 687 522 680 524 686 549 652 527 687 522 690 514 683 522 686 520 684 525 679 527 685 521 681 525 681 528 682 522 684 527 681 521 711 495 688 518 670 540 682 522 683 523 683 549 659 524 682 522 681 552 658 523 685 1621 683 525 682 39966 9028 4451 689 1620 686 547 658 553 657 544 657 549 665 542 662 545 658 548 658 1624 685 547 663 544 657 1625 683 548 657 550 662 543 657 550 661 545 670 537 659 547 660 546 658 549 634 1651 682 548 657 549 632 575 657 549 629 577 661 545 643 1638 657 1652 662 1647 654 577 630 579 628 1650 665 578 632 19975 651 581 631 576 626 581 627 578 659 547 631 577 631 575 627 1662 673 553 627 580 628 577 630 576 627 579 634 573 631 574 655 551 630 577 657 550 655 553 628 578 631 575 628 578 654 552 627 580 654 552 632 575 653 554 626 580 629 577 630 576 627 1654 657 1652 653 name KEY_OPEN 8984 4493 648 1659 648 559 648 557 649 1656 676 534 648 557 649 558 648 561 646 1662 649 557 647 561 644 1660 655 552 649 558 648 558 648 559 648 558 648 560 646 558 649 560 647 556 650 1658 651 557 648 560 646 558 648 559 648 557 650 558 646 1660 649 558 648 1658 650 559 648 558 648 1659 649 564 645 19988 648 556 651 558 647 562 646 558 648 557 650 559 649 556 649 557 649 557 651 558 646 557 650 558 649 556 650 557 656 553 647 557 649 557 651 556 650 559 647 560 646 556 650 569 638 557 649 560 646 558 649 558 648 562 646 556 650 557 648 561 646 1660 648 1659 650 40004 8989 4491 648 1659 650 559 646 560 647 1661 648 559 647 558 649 556 651 558 647 1659 651 557 648 558 650 1659 649 558 649 558 648 556 650 557 648 557 652 558 646 559 648 559 647 560 655 1652 646 559 651 553 651 557 649 559 648 555 650 559 649 1657 650 1658 650 1658 649 557 651 557 648 1658 650 558 648 19992 648 559 649 559 647 558 648 559 648 558 647 560 648 558 648 1658 650 557 649 557 648 559 648 558 647 557 651 558 647 558 648 559 647 567 640 558 648 560 647 558 648 559 648 558 649 558 648 559 648 558 648 557 648 558 650 560 646 558 648 557 649 1660 648 558 650 end raw_codesend remote ③最后，把配置文件复制到指定目录 /etc/lirc/lircd.conf/ 并重启lircd服务：12sudo cp aircon.lircd.conf /etc/lirc/lircd.conf.d/sudo service lircd restart 5. 发射信号12# 发射命令：irsend SEND_ONCE 遥控器名称 按钮名称irsend SEND_ONCE aircon KEY_OPEN 如果前面的步骤一切正常，但在发射信号时报错“transmission failed”。请检查生成的遥控器配置文件，查看flags项，若是flags RAW_CODES|CONST_LENGTH，请尝试将其修改成flags RAW_CODES并重启lircd服务。再测试能否发射信号。 github上的一个文章树莓派给家用电器加上智能（红外篇）树莓派学习手记——制作一个空调遥控器（红外接收、发射的实现）题]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>红外线</tag>
        <tag>HX1838B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派开发智能小车]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%8F%91%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[小车的配件 底盘 4个轮子和4个减速电机 双路L298N一个 电池盒（最好要5号8节电池） 树莓派 若干的跳线和杜邦线（最好是母对母的） 小车代码，使用的Python的Web异步框架（tornado）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import tornado.ioloopimport tornado.webimport RPi.GPIO as GPIOimport timeIN1=11IN2=12IN3=13IN4=15def init(): GPIO.setmode(GPIO.BOARD) GPIO.setup(IN1,GPIO.OUT) GPIO.setup(IN2,GPIO.OUT) GPIO.setup(IN3,GPIO.OUT) GPIO.setup(IN4,GPIO.OUT)def goLeft(): init() GPIO.output(IN1,GPIO.LOW) GPIO.output(IN2,GPIO.HIGH) GPIO.output(IN3,False) GPIO.output(IN4,False) time.sleep(0.3) GPIO.cleanup()def goRight(): init() GPIO.output(IN1,False) GPIO.output(IN2,False) GPIO.output(IN3,GPIO.LOW) GPIO.output(IN4,GPIO.HIGH) time.sleep(0.3) GPIO.cleanup()def goForward(): init() GPIO.output(IN1,GPIO.LOW) GPIO.output(IN2,GPIO.HIGH) GPIO.output(IN3,GPIO.LOW) GPIO.output(IN4,GPIO.HIGH) time.sleep(0.3) GPIO.cleanup()def goBack(): init() GPIO.output(IN1,GPIO.HIGH) GPIO.output(IN2,GPIO.LOW) GPIO.output(IN3,GPIO.HIGH) GPIO.output(IN4,GPIO.LOW) time.sleep(0.3) GPIO.cleanup()def parkRight(): init() GPIO.output(IN1,GPIO.HIGH) GPIO.output(IN2,GPIO.LOW) GPIO.output(IN3,GPIO.LOW) GPIO.output(IN4,GPIO.HIGH) time.sleep(0.3) GPIO.cleanup()def parkLeft(): init() GPIO.output(IN1,GPIO.LOW) GPIO.output(IN2,GPIO.HIGH) GPIO.output(IN3,GPIO.HIGH) GPIO.output(IN4,GPIO.LOW) time.sleep(0.3) GPIO.cleanup()class MainHandler(tornado.web.RequestHandler): def get(self): self.write("Hello, world") def post(self): print(self.get_argument('key')) arg = self.get_argument('key') if(arg == 'a'): goLeft() if(arg == 'd'): goRight() if(arg == 'w'): goForward() if(arg == 's'): goBack() if(arg == 'pr'): parkRight() if(arg == 'pl'): parkLeft()def make_app(): return tornado.web.Application([ (r"/", MainHandler), ])if __name__ == "__main__": app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() 安卓手机APP的程序代码（安卓初学，求放过） 界面布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.daniel.controlcar.MainActivity" android:background="#fff"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:layout_marginTop="128px"&gt; &lt;Button android:id="@+id/go_a" android:layout_width="256px" android:layout_height="256px" android:background="@mipmap/left" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="center"&gt; &lt;Button android:id="@+id/go_s" android:layout_width="256px" android:layout_height="256px" android:background="@mipmap/down" /&gt; &lt;Button android:id="@+id/go_w" android:layout_width="256px" android:layout_height="256px" android:background="@mipmap/up" android:layout_marginLeft="256px" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center"&gt; &lt;Button android:id="@+id/go_d" android:layout_width="256px" android:layout_height="256px" android:background="@mipmap/right" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"&gt; &lt;Button android:id="@+id/p_left" android:layout_width="256px" android:layout_height="256px" android:background="@mipmap/p_left" /&gt; &lt;Button android:id="@+id/p_right" android:layout_width="256px" android:layout_height="256px" android:background="@mipmap/p_right" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 后台代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.example.daniel.controlcar;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.Button;import com.example.daniel.common.HttpUtil;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class MainActivity extends Activity implements View.OnTouchListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button goWBtn = (Button) findViewById(R.id.go_w); goWBtn.setOnTouchListener(this); Button goABtn = (Button) findViewById(R.id.go_a); goABtn.setOnTouchListener(this); Button goSBtn = (Button) findViewById(R.id.go_s); goSBtn.setOnTouchListener(this); Button goDBtn = (Button) findViewById(R.id.go_d); goDBtn.setOnTouchListener(this); Button goPLeftBtn = (Button) findViewById(R.id.p_left); goPLeftBtn.setOnTouchListener(this); Button goPRightBtn = (Button) findViewById(R.id.p_right); goPRightBtn.setOnTouchListener(this); &#125; public void sendPost(final String key) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpUtil httpUtil = new HttpUtil(); String response = httpUtil.doPost("http://192.168.31.242:8888?key=" + key, "&#123;&#125;"); Log.d("returnValue", response); &#125; &#125;).start(); &#125; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123; action(view); &#125; else if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; stop(); &#125; return false; &#125; private ScheduledExecutorService scheduledExecutor; /** * 开始计划任务，定时每100ms执行一次 * @param view */ private void action(final View view)&#123; stop();//首先把已有的定时任务关闭 scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); scheduledExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; switch (view.getId()) &#123; case R.id.go_w: sendPost("w"); break; case R.id.go_a: sendPost("a"); break; case R.id.go_s: sendPost("s"); break; case R.id.go_d: sendPost("d"); break; case R.id.p_left: sendPost("pl"); break; case R.id.p_right: sendPost("pr"); break; &#125; &#125; &#125;, 0, 300, TimeUnit.MILLISECONDS); //每间隔100ms发送Message &#125; /** * 停止计划任务 */ private void stop() &#123; if (scheduledExecutor != null) &#123; scheduledExecutor.shutdownNow(); scheduledExecutor = null; &#125; &#125;&#125; 配置文件AndroidManifest.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.daniel.controlcar"&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" android:theme="@android:style/Theme.NoTitleBar.Fullscreen"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; HttpUtil 123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.daniel.common;import java.io.IOException;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;/** * Created by Daniel on 2018/6/20. */public class HttpUtil &#123; public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8"); OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); try (Response response = client.newCall(request).execute()) &#123; return response.body().string(); &#125; &#125; public String doPost(String url,String paramJson)&#123; HttpUtil httpUtil = new HttpUtil(); String responseStr = ""; try &#123; responseStr = httpUtil.post(url,paramJson); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return responseStr; &#125;&#125;]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>智能小车</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派控制低电平触发蜂鸣器]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E4%BD%8E%E7%94%B5%E5%B9%B3%E8%A7%A6%E5%8F%91%E8%9C%82%E9%B8%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[连线如下图所示 Python代码(欢乐颂的第一段)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import RPi.GPIO as GPIOimport timeGPIO.setmode(GPIO.BOARD)GPIO.setup(12,GPIO.OUT)GPIO.output(12,GPIO.LOW)def INT1(time1): p = GPIO.PWM(12,523) p.start(1) time.sleep(time1)def INT2(time1): p = GPIO.PWM(12,587) p.start(1) time.sleep(time1)def INT3(time1): p = GPIO.PWM(12,659) p.start(1) time.sleep(time1)def INT4(time1): p = GPIO.PWM(12,698) p.start(1) time.sleep(time1)def INT5(time1): p = GPIO.PWM(12,784) p.start(1) time.sleep(time1)def INT6(time1): p = GPIO.PWM(12,880) p.start(1) time.sleep(time1)def INT7(time1): p = GPIO.PWM(12,988) p.start(1) time.sleep(time1)def INT11(time1): p = GPIO.PWM(12,1046) p.start(1) time.sleep(time1)INT3(0.5)INT3(0.5)INT4(0.5)INT5(0.5)INT5(0.5)INT4(0.5)INT3(0.5)INT2(0.5)INT1(0.5)INT1(0.5)INT2(0.5)INT3(0.5)INT3(1)INT2(0.5)INT2(0.5)p.stop()GPIO.cleanup() 运行1python3 laba.py]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>蜂鸣器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派更换键盘布局]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%8D%A2%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[遇到的问题：树莓派键盘输入的时候会出现不是自己想要的字符，比如说输入|，会出现顶部~线，输入#，显示的却是£字符的问题 首先输入命令1sudo dpkg-reconfigure keyboard-configuration 2.选择通用101键盘布局，直接回车 3.在键盘Layout中选择Other,回车 4.在选项中选择English(US)，回车 5.再选择English(US, alternative international),回车 6.然后一路回车就可以了 7.最重要的一步，重启系统，整个过程完成]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>更换键盘布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派常用命令]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令:123456789101. sudo raspi-config 初始化配置2. startx 启动图形化界面3. sudo rpi-update 升级系统4. sudo reboot 重启5. sudo shutdown -h now 立即关机6. sudo apt-get update 更新软件源7. sudo apt-get upgrade 更新已经安装的软件8. sudo apt-get install XX 安装XX软件9. su root 切换到root用户10. passwd user 设置user用户的密码 资源管理命令：12341. top :查看系统的运行情况2. free -m(-k, -g):查看内存分配情况3. sudo df -h ：查看磁盘使用情况4. sudo du -sh :查看当前目录下的磁盘使用信息 进程管理123456781. ps ：查看系统正在运行的进程2. ps -ef | less :查看系统所有的进程，包括后台进程。3. kill -&lt;signal&gt; &lt;PID&gt; 对进程做出一定的操作 注：* signal 1 (SIGHUP): hang-up的缩写，该信号通知应用程序重新启动 * signal 3 （SIGQUIT）：该信号通知应用程序清理自身资源并退出 * signal 6 （SIGABRT）：该信号通知应用程序终止并立即退出 * signal 9 （SIGKILL）：该信号立即终止应用程序 * PID ：应用程序的进程号，可以通过ps 查看 文件管理12345678910111213141516171. pwd :显示当前的绝对路径2. cd ：切换路径3. cd .. :切换到上级目录4. find ：查找文件 注：参数解析 -L ：表示启动符号连接跟踪，默认情况下是不会启动的。 -maxdepth&lt;number&gt;: 该选项指定find命令最大的目录查看深度，如果为1的话表示当前目录文件和一级子目录文件。 -newer&lt;file&gt;:表示只查找指定文件的修改时间更新的文件 -empty：表示只查找空文件 -atime&lt;number&gt; ：表示只查找距离上次访问指定天数之后的文件 -name&lt;filename&gt;:表示搜索完全匹配指定文件名的文件 -exec&lt;command&gt;:指示find命令为每个匹配的文件路径执行指定的命令。例：find /mnt/volumer -empty -name foobar -exec rm作用：该命令会搜索/mnt/volumer 中的所有名称匹配foobar的空文件，并执行rm命令将其删去5、file &lt;filename&gt; :通过读取filename文件的内容判断文件的类型。6、grep &lt;pattern&gt; &lt;file&gt;: grep 所有的参数都支持通配符，所以你可以搜索整个目录中所有文件内容 编辑器vi的使用：（vi和vim的联系）编辑器：编辑器就是一款软件，他的主要作用是用来编辑。如编写文件，编写代码等。windows中的常用编辑器： notepad（笔记本） notepad++,UltraEditor, SlickEditorlinux中常用的编辑器： 自带的最古老的vi。比较好用的是vim，gedit。注意：vim是vi的升级版，推荐使用vim。但使用vim（vi）打开一个文件时，如果文件不存在他会帮你新建一个文件。 vi的两种工作模式：命令模式： 当vi打开时默认为命令模式，要转入输入模式，需要按a或i键。在命令模式下所有的输入都被vi当作命令来对待。（所以不要乱按）输入模式： 输入模式用来向文件输入内容。当输入完成要保存文件时需要按Esc键切换到命令模式。注意 : 看屏幕左下角，当命令模式时无提示信息或者提示文件名等信息，当输入模式时，提示：–INSERT– 使用方式： vi pathname 打开或创建一个文件 在命令模式下保存文件： ：wq 保存并且退出 ：w 只保存不退出 ：q 不保存退出 （只是进来看了一下没改时退出用） ：q! 不保存强制退出 ：wq! 保存并强制退出 vi 的高级使用(在命令模式下使用) /xxx 查找 xxx ：行数 快速切换到指定行数 ：set nu 设置显示行号 ：set nonu 设置不显示行号注意：设置永久显示行号，需要修改vi的配置文件。打开vi的配置文件~/.vimrc 在其中输入set nu 即可。 dd 删除一整行 numdd 删除num行 numyy 复制num行 p 粘贴注意: 复制时要把光标放在多行的第一行，粘贴时实际粘贴到当前光标所在行的下一行。 vim水平分屏的使用 :vim -on file1 file2 …其中: o(是小写字母o,不是数字零)n(表示你要分屏的文件个数) filen(文件名多个文件用空格分开) 我用两个文件做测试想到上面那个文件用:ctrl + w + k 想到下面的文件用:ctrl + w + j 当然你懒的话可以用:ctrl + w + w 在水平分屏好的文件中在打开别的文件:sp filename vim垂直分屏:vim -On file1 file2 ….. 其中:O(是大写字母O,不是数字零)n(表示你要分屏的文件个数) filen(文件名多个文件用空格分开) 想到左面那个文件用:ctrl + w + h 想到右面的文件用:ctrl + w + l 在垂直分屏好的文件中在打开别的文件:vsp filename 撤销命令（命令模式下有效） u ：小写的 u 键。]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派更换apt-get update && apt-get upgrade源，解决更新慢的问题]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%8D%A2apt-get-update-apt-get-upgrade%E6%BA%90%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%9B%B4%E6%96%B0%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起因：树莓派执行sudo apt-get update下载慢，中断 步骤 备份sources.list文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 编辑sources.list 文件 1sudo nano /etc/apt/source.list 使用#注释原来的内容,并添加以下内容 12deb http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contribdeb-src http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib 更新系统软件并更新已安装的包 1sudo apt-get update &amp;&amp; apt-get upgrade -y]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派开机启动]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[制作脚本该步骤直接省略，按照个人需求编写 添加开机启动方法一: 向rc.local文件添加启动代码修改rc.local文件，在中断输入并回车1pi@raspberry:~$sudo nano /etc/rc.local 在打开的文本中找到exit 0,在此之前添加的代码再启动时会被执行(在执行代码的末尾加上&amp; 可以在后台执行)： 方法二: 将程序作为服务启动在/etc/init.d/目录下新建一个服务脚本文件，在终端输入并回车1pi@raspberry:~ $ sudo nano /etc/init.d/my_start 在打开的文本编辑器中输入一下内容1234567891011121314#!/bin/bashcase &quot;$1&quot; in start): echo &quot;Starting app&quot; nohup python3 /home/pi/share/ip_acquire.py &amp; ;; stop): echo &quot;to&quot; #kill $( ps aux | grep -m 1 &apos;python3 /home/pi/share/ip_acquire.py&apos; | awk &apos;&#123; print $2 &#125;&apos;) ;; *) echo &quot;Usage: service start_tool start|stop&quot; exit 1 ;;esacexit 0 设置python脚本开机启动1sudo chmod 777 /etc/init.d/my_start 这样启动该脚本用service命令就可以了12sudo service my_start start #启动sudo service my_start stop #停止 最后设置开机启动就好了1sudo update-rc.d my_start defaults]]></content>
      <categories>
        <category>物联网</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>开机启动</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kaa CentOS7安装 启动命令]]></title>
    <url>%2F2019%2F02%2F20%2FKaa-CentOS7%E5%AE%89%E8%A3%85-%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.启动Mariadbservice mysql startMariadb的授权信息CREATE USER &#39;sqladmin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;admin&#39;; GRANT ALL PRIVILEGES ON *.* TO &#39;sqladmin&#39;@&#39;localhost&#39; WITH GRANT OPTION; FLUSH PRIVILEGES;`Mariadb的数据库名字123CREATE DATABASE kaa CHARACTER SET utf8 COLLATE utf8_general_ci; 2.启动zookeepersudo /usr/share/zookeeper/bin/zkServer.sh start（重启服务器需要重启）systemctl start supervisord（已经设置自动启动）检查启动的情况12#supervisorctlnetstat -ntlp | grep 2181 3.启动MongoDB12345sudo systemctl start mongodb（重启服务器需要重启）service mongod start（已经设置自动启动）检查mongoDB的启动情况sudo systemctl status mongodbcat /var/log/mongodb/mongod.log | grep "waiting for connections on port" 4.启动kaa12service kaa-node startcat /var/log/kaa/* | grep ERROR 5、Kaa关闭12sudo service kaa-node stopsudo service kaa-node start 5、Kaa的Administrator账号和密码 教程：http://docs.kaaproject.org/display/KAA/Administration+UI+guidehttp://192.168.1.115:8080/kaaAdmin/administrator]]></content>
      <categories>
        <category>物联网</category>
        <category>kaa</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>kaa</tag>
        <tag>启动命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件整理]]></title>
    <url>%2F2019%2F02%2F20%2F%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[应用软件 Python开发工具JetBrains PyCharm 2017.1.2 x64 原型工具Axure RP Pro 7.0（PC端）、墨刀（手机端） C++开发CodeBlocks Mysql存储过程调试dbForge Studio for MySQL 截取手机APP请求信息软件Fiddler 4 文本编辑器NodePad++、UltraEdit32、EditPlus 数据库前端软件Navicat Premium、PLSQL、Studio 3T（Mongodb） 大数据分析Tableau、Qlik 邮箱客户端FoxMail、Gmail SDCard格式化（树莓派镜像会出现Windows无法格式化情况）SDFormatter 数模设计软件（能够快速导出已完成数据库的数模）PowerDesigner 远程Linux系统Xshell、Xftp 视频播放器、听歌、视频格式化、Win10扫雷完美解码、Potplayer、网易云音乐、格式工厂、MineSweeper 云笔记有道云、Evernote（印象笔记） 安卓开发、IOS开发AndroidStudio、apicloud-studio-2.exe CAD看图软件CAD迷你看图 Json格式化、XML格式化JsonView、XMLFormat 翻墙软件（需要国外搭建服务器，简单的VPS配置操作，可在搬瓦工上买服务器，相对稳定，不会封杀）Shadowsocks、蓝灯Lantern Windows内存分析RAMMap.1.50.chs 端口开放情况PortScan Java反编译工具jd-gui反编译 C#反编译dnSpy 截图软件，这个可以录视频幺FSCapture 接口测试HTTPPostman可自动生成接口调用代码 SQL文件分割工具SQLDumpSplitter 取色工具TakeColor、抓色小猫、Chrome和IE里面也有取色工具 流程在线制作软件Processon 脑图百度脑图、Xmind 关于我们或者推广在线H5展页兔展、人人秀、企业秀 图标下载、GIF图标下载https://preloaders.net/en/free GIF图标下载地址，包含等待之类的http://www.iconfont.cn/ 阿里图标下载，各种图标http://www.easyicon.net 国外的一个图标下载的网址 MarkDown编写工具Typora：（目前免费，样式好看而且可以切换多种样式皮肤，喜欢Github和Vue风格的，适合于本地写文档，可以使用Github同步自己的文档到云端，而且Github是免费的幺，导出功能免费）AtomCmd Markdown：（写出来的文档好看，文件管理不是很好，导出PDF、带样式HTML收费） GIF截屏工具GifCam 鼠标键盘多电脑共享Synergy、MouseWithOutBorder（Windows自带，免费，但是得在同一个WIFI下） 文件搜索ListaryEverything 内网映射工具frp可以自己搭建服务器进行域名的映射，很简单ngrok(免费,前提是自己有服务器和域名，也可以使用公共的，比较慢) 花生壳（部分功能收费，特别是80端口） 日志查看工具emeditorLogViewer Redis可视化管理工具Redis Desktop Manager 下载软件Internet Download Manager简称IDM 开发使用的常用插件 地图百度地图（SDK jsAPI）等等，使用很方便 图表(柱状、饼状、折线、雷达、地图、仪表盘、漏斗、热力图、混搭配合多种主题组合)Echarts（界面比较美观，可以使用上面JSONview进行分析） 富文本编辑UEditor(本地化保存) 接口管理工具（前后端协作）Swagger apizza 网页打印工具C-lodop 图片剪切上传Cropper 文件上传WebUploader Word文档文本搜索和数据存储ES Java后台图片处理（缩放、旋转、水印、剪裁、格式转换、输出到OutputStream、输出到BufferedImage）thumbnailator Java工作流开发（流程相关）Activiti 跨服务器跨不同数据库不同业务表不同业务字段数据库同步ETL kettle Oracle修改导出版本AlxcTools Web中使用Word、ExcelLibreOffice、openoffice、pageOffice 前端RSA加密JSEncrypt 规则引擎Drools Mock工具RAP2 网站搜索插件Solr 内容管理系统：管理网站的后台和前端页面CMS 开发框架 手机APP开发框架afinal、ThinkAndroid、andBase、KJFrameForAndroid、SmartAndroid、dhroidQMUI（手机APP开发布局框架）、ButterKnife（个人理解是减少findViewById）、OkHttp框架（网络请求框架） JAVA 开发框架SSM(Spring+SpringMVC+MyBatis)，阿里数据库连接池durid 权限管理框架Apache shiroSpring Security PC前端开发框架Bootstrap、LayUI(Layer)（PC端管理后台）、Ant Designer、Element UI 手机前端框架uni-appFramework7(阿里手机前端框架)MUI(HBuilder)SUI、MUI、WEUI（手机端）GMU(百度) Frozen UI（QQ） 中后台框架jeecg-boot 相关软件 Kali Linux （还在研究各种渗透，里面有很多渗透用的工具） 人工智能、人脸识别 人脸识别OpenCV 博客、BBS论坛 博客HEXO、WordPress 论坛Xiuno]]></content>
      <categories>
        <category>办公知识</category>
        <category>软件整理</category>
      </categories>
      <tags>
        <tag>软件整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN服务端安装设置（Windows版本）]]></title>
    <url>%2F2019%2F02%2F20%2FSVN%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE%EF%BC%88Windows%E7%89%88%E6%9C%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先下载并安装SVN服务端 新建一个文件夹用于SVN同步文件到这个文件夹中 如：G:\svnData cmd命令中执行如下命令：（这一步的含义是创建一个资源库）svnadmin create G:\svnData\webDemo 进入 G:\svnData\webDemo目录下的conf中，打开svnserve.conf文件，将 12anon-access=readanauth-access= write 两行的注释去掉（第一行的意思是匿名用户也能读取资源库，如果想禁止的话只需要改成anon-access=none,第二行的意思是允许授权用户对资源进行读取和写入操作） 取消svnserve.conf文件中的password-db=passwd的注释，此句的意思是将svn资源库使用的passwd文件来保存用户名和密码 启动SVNsvnserve -d -r D:\SVNData exit]]></content>
      <categories>
        <category>软件安装</category>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>SVN</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装SVN]]></title>
    <url>%2F2019%2F02%2F19%2FCentOS7%E5%AE%89%E8%A3%85SVN%2F</url>
    <content type="text"><![CDATA[安装SVN 通过 yum install subversion来安装 提示已经安装。查看svn版本使用: svnserve –-version 使用命令: svnadmin create svn/repo 进入版本库中的配置目录conf，此目录有三个文件： svn服务综合配置文件、 用户名口令文件、权限配置文件 配置权限配置文件authz说明：两个站点为bbs,blog,所以分为三个组超级管理组admin、bbs管理组bbsadmin、blog管理组blogadmin。超级管理组admin可以读写所有站点内容，而bbsadmin对bbs站点可以读写，而只能读blog站点。以及blogadmin对blog站点可以读写,对bbs站点只读。 配置用户口令文件passwd,添加组用户以及密码 配置 svn服务综合配置文件svnserve.conf，取消以下项目的注释，其中一定要注意anon-access=none，因为这个是要看历史版本用的 启用/关闭svn 启动SVNsvnserve -d -r /home/svn/project/ 关闭svn通过ps -aux|grep svn 查看到的svn进程id来进行关闭]]></content>
      <categories>
        <category>软件安装</category>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>CentOS7</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN问题集合]]></title>
    <url>%2F2019%2F02%2F19%2FSVN%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[SVN安装完成后没有svn.exe的问题 在安装的SVN的时候，有时候会出现安装完之后，没有svn.exe的问题，解决该问题的办法是在安装的时候选择安装command line client tools 打开小三角然后选择里面的Will be installed on local hard drive IDEA中SVN报错E230001Server SSL certificate verification failedcertificate issue 首先执行cmd命令 1svn ls http://xxxx 其中http://xxx指的是svn服务器的地址 然后会显示(R)eject, accept (t)emporarily or accept (p)ermanently?,这个时候输入p 执行完成后会出现让输入Administrator的密码，直接输入电脑的Administrator的密码，如果没有密码，直接回车即可 然后根据提示输入svn的账号和密码 最后就可以直接在IDEA中进行checkout操作了]]></content>
      <categories>
        <category>办公知识</category>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6安装Git]]></title>
    <url>%2F2019%2F02%2F19%2FCentOS6%E5%AE%89%E8%A3%85Git%2F</url>
    <content type="text"><![CDATA[1. git卸载 如果是之前安装过git，需要先进行卸载操作 1rpm -e --nodeps git 2. 下载最新版本的git 去Git的下载地址查找自己的Git版本，页面地址为Git下载地址，这个地方可以按照日期进行查询，找当年的最新发布的版本，文件名的格式为“git-2.18.0.tar.gz”，这里使用的下载地址为https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.18.0.tar.gz 1234567891011121314151617181920# 下载源程序包cd /home/Downloadwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.18.0.tar.gz# 安装依赖包yum -y install libcurl-devel expat-devel curl-devel gettext-devel openssl-devel zlib-develyum -y install gcc perl-ExtUtils-MakeMaker# 解压编译程序tar -zxvf git-2.18.0.tar.gzcd git-2.18.0make prefix=/usr/local/git allmake prefix=/usr/local/git install# 添加git到环境变量echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc# 查看git版本git --version 问题：git clone的时候报SSL错误 问题 123[root@localhost temp]# git clone https://github.com/alibaba/anyproxy.gitCloning into &apos;anyproxy&apos;...fatal: unable to access &apos;https://github.com/alibaba/anyproxy.git/&apos;: SSL connect error 解决方案 更新系统的NNS1yum -y update nss]]></content>
      <categories>
        <category>软件安装</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github学习]]></title>
    <url>%2F2019%2F02%2F19%2FGithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Git Flow如何工作初始分支所有在Master分支上Commit应该Tag Feature分支分支名feature/*Feature分支做完之后，必须合并回Develop分支，合并完之后一般会删除这个Feature分支，但是我们也是可以保留的 Release分支分支名release/*Release分支基于Develop分支创建，打完Release分支之后，我们可以在Release分支上测试，修改BUG，同时，其他研发人员可以基于开发新的Feature（一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支）发布Release分支时，合并Release到Master和Develop，同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了 维护分支Hotfix分支名hotfix/*hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个Tag Git Flow代码示例 创建develop分支 12git branch developgit push -u origin develop 开始新Feature开发 123456789#基于develop创建feature分支 git checkout -b new-feature develop #可选，是否推送feature分支到remote端 git push -u origin new-feature#做一些改动git statusgit add some-file #或者 git add *git commit 完成feature 12345678910#拉取开发库远端，保证合并代码不覆盖git pull orgin developgit checkout developgit merge --no-ff new-featuregit push origin develop#删除功能分支git branch -d new-feature#如果你把功能分支推送到远端了git push origin --delete new-feature 开始Release 12345#创建基于develop的release分支git checkout -b release-0.1.0 develop#可选项：Bump version number，commit#Prepare release，commit 这个地方还没看懂 完成Release 12345678910111213141516171819#将release代码合并到主分支上git checkout mastergit merge --no-ff release-0.1.0git push#将release分支合并到develop分支上git checkout developgit merge --no-ff release-0.1.0git push#删除release分支git branch -d release-0.1.0#如果远端也有release分支，需要进行删除操作git push origin --delete release-0.1.0#给主分支打标签git tag -a v0.1.0 mastergit push --tags 开始Hotfix 12#首先clone master分支git checkout -b hotfix-0.1.9 master 完成Hostfix 12345678910111213141516#切换到master分支上，将hotfix合并到master分支上git checkout mastergit merge --no-ff hotfix-0.1.0git push#然后将分支内容合并到develop分支上git checkout developgit merge --no-ff hotfix-0.1.0git push#删除hotfix分支git branch -d hotfix-0.1.0#给master分支打标签git tag -a v0.1.1 mastergit push --tags 引用自：https://www.cnblogs.com/cnblogsfans/p/5075073.html，没事的可以看下 Git Flow确实是一个很好的Git开发流程]]></content>
      <categories>
        <category>办公知识</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10安装Maven]]></title>
    <url>%2F2019%2F02%2F19%2FWin10%E5%AE%89%E8%A3%85Maven%2F</url>
    <content type="text"><![CDATA[准备工作 电脑安装JDK1.7以上 Win10操作系统 Maven安装包 下载地址 解压Maven安装包 下载完之后，把Maven安装包解压到你想要解压的目录下，本人解压到D:\Program Files\apache-maven-3.5.3下,解压完成后，目录下会有bin、boot、conf、lib文件夹及ReadMe文件等配置环境变量 我的电脑-右键-属性-高级系统设置-环境变量-系统变量-新建 变量名称：M2_HOME 变量值：D:\Program Files\apache-maven-3.5.3 找到Path在环境变量值尾部加入：;%M2_HOME%\bin; //前面注意分号 检查JDK和Maven配置是否成功 Win键+R，输入cmd，打开dos界面 输入mvn -v ,出现以下说明安装成功 1234567C:\Users\Daniel&gt;mvn -vApache Maven 3.5.3 (3383c37e1f9e9b3bc3df5050c29c8aff9f295297; 2018-02-25T03:49:05+08:00)Maven home: D:\Program Files\apache-maven-3.5.3\bin\..Java version: 1.7.0_80, vendor: Oracle CorporationJava home: D:\Program Files\Java\jdk1.7.0_80\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 8.1", version: "6.3", arch: "amd64", family: "windows" 修改本地仓库位置Maven会将下载的类库（jar包）放置到本地的一个目录下（一般默认情况下maven在本机的仓库位于C:\我的文档中.m2.\repository），如果想重新定义这个目录的位置就需要修改Maven本地仓库的配置 在自己喜欢的位置创建文件夹，此处本人创建的位置是（F:\Maven\repo） 在安装Maven的目录下找到conf文件夹，在文件夹中找到settings.xml文件，复制settings.xml文件放于F:\Maven，如下图所示： 3.修改settings.xml文件，如下图所示： 在安装Maven的目录下找到conf文件夹，在文件夹中找到settings.xml文件，更改默认的仓库位置如下图所示：（注意两个地方的settings.xml都要修改） 校验修改的配置是否成功，控制台输入：mvn help:system，如果成功，maven会从远程中央仓库下载jar包到本地的repo文件夹中]]></content>
      <categories>
        <category>软件安装</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok内网映射使用]]></title>
    <url>%2F2019%2F02%2F19%2Fngrok%E5%86%85%E7%BD%91%E6%98%A0%E5%B0%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装将本地Web服务器公开到Internetngrok允许您将在本地计算机上运行的Web服务器公开到Internet。只需告诉ngrok您的Web服务器正在侦听的端口。 如果您不知道您的Web服务器正在侦听的端口，则可能是端口80，HTTP的默认端口。 1ngrok http 80 当您启动ngrok时，它将在您的终端中显示您的隧道的公共URL以及有关通过隧道进行的连接的其他状态和指标信息。 其中 http://127.0.0.1:4040 可以查看具体的映射请求情况12345678910ngrok by @inconshreveableTunnel Status onlineVersion 2.0/2.0Web Interface http://127.0.0.1:4040Forwarding http://92832de0.ngrok.io -&gt; localhost:80Forwarding https://92832de0.ngrok.io -&gt; localhost:80Connnections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 检查您的流量ngrok提供了一个实时网络用户界面，您可以在这里查看隧道上运行的所有HTTP流量。启动ngrok后，只需在Web浏览器中打开http：// localhost：4040以检查请求详细信息。尝试向您的公开网址发送请求。有了之后，请回顾一下检查用户界面。您将看到请求和响应的所有详细信息，包括时间，持续时间，标题，查询参数和请求负载以及线路上的原始字节。 安装authtoken注册一个账号，可以获取到一个authtoken，然后通过下面的命令添加到自己的ngrok1ngrok authtoken &lt;YOUR_AUTHTOKEN&gt; HTTP 隧道自定义子域名常规情况下，ngrok会提供一个16进制随机的域名，然后开通一个http隧道，如果需要自定义的subdomain，可以使用以下方法1ngrok http -subdomain=inconshreveable 80 12345ngrok by @inconshreveable...Forwarding http://inconshreveable.ngrok.io -&gt; 127.0.0.1:80Forwarding https://inconshreveable.ngrok.io -&gt; 127.0.0.1:80 使用密码保护隧道可以使用 -auth 保证交换数据的安全性1ngrok http -auth=&quot;username:password&quot; 8080 自定义域名（收费就不记录了）1ngrok http -region=us -hostname=dev.example.com 8000 暂时比较忙，先写到这里，具体可以见这个地址]]></content>
      <categories>
        <category>软件安装</category>
        <category>ngrok</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>内网映射</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp-内网映射 服务端部署]]></title>
    <url>%2F2019%2F02%2F19%2Ffrp-%E5%86%85%E7%BD%91%E6%98%A0%E5%B0%84-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[frp作用 利用处于内网或者防火墙后的服务器，对外网环境提供HTTP或HTTPS服务 对于http、https服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口 对往往提供tcp和udp服务，可以在夹中ssh访问处于公司内网的主机 配置说明 配置前准备公网服务器1台及独立固定IP地址 服务器安装 首先下载frp，下载页面点击frp下载地址，下载的时候根据自己服务器和映射主机的需求进行判断下载 服务器(Linux) 123456cd /usr/localmkdir frp#上传frp解压出来的内容到该目录下#删除和客户端相关的内容 frpc*(删掉frpc、frpc.ini两个文件)rm -rf frpc* 1234#编辑frps.ini[common]bind_port = 7000 #与客户端绑定的进行通信的端口vhost_http_port = 80 #访问的域名后面跟的端口号，如果是80，直接域名到项目就能访问，如果其他，需要在域名后跟这个端口号然后再跟项目名访问 12345#启动服务./frps -c ./frps.ini # 前台启动#创建日志文件夹mkdir logsnohup ./frps -c frps.ini &gt; ./logs/print.out 2&gt;&amp;1 &amp; #后台启动命令，并输出日志到print.out 这个地方要提前创建好文件路径 客户端首先删掉frps、frps.ini两个文件,然后再进行配置,然后编辑frpc.ini 12345678910[common]server_addr = xxx.xxx.xxx.xxx #公网服务器ipserver_port = 7000 #与服务端bind_port一致## 公网访问内部web服务器以http方式[web]type = http #访问协议local_ip = 192.168.2.62local_port = 8080 #本地启动服务的端口号custom_domains = frp.xxx.cn #所绑定的公网服务器域名，一级、二级域名都可以 启动frpc 1./frpc -c ./frpc.ini 设置A记录将二级域名（frp.xxx.cn）指向frp服务器 现在你就可以通过url：frp.xxx.cn/Projectname访问你的项目了]]></content>
      <categories>
        <category>软件安装</category>
        <category>frp</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>frp</tag>
        <tag>内网映射</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键]]></title>
    <url>%2F2019%2F02%2F19%2FIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[高频使用 Ctrl+Shift+Enter : 语句填补（获取建议里面的第一条补全）Ctrl+Shift+Space:代码提示输入Ctrl+E :打开最近打开的文档、对话框（TODO、Structure等等）Shift+Click :（左键点击标签可以关闭当前文件）Ctrl+[ or ]:可跳转到大括号的开始和结束Ctrl+F12 :打开当前文档的文档结构Ctrl+N:快速打开类Ctrl+Shift+N:快速打开文件Ctrl+Shift+Insert,Ctrl+Shift+V:选择剪切板并快速插入Alt+Insert:可以生成构造器Getter/Setter等 Ctrl+Alt+T: 代码块使用代码包裹起来，例如：try/catchAlt+Enter:导入包，选择修正（需要在异常的对象后面使用该快捷键）Ctrl+Alt+L:当前整个文档格式化代码Ctrl+Alt+I:选中代码格式化Shift+F6:重构-重命名文件（类、jsp、js等等）Ctrl+Shift+UP/DOWN,Alt+Shift+UP/DOWN:选中代码向上或向下移动一行Ctrl+X:删除光标所在当前行Ctrl+Y:删除选中行Ctrl+D:复制光标所在行Ctrl+/orCtrl+Shift+/:注释选中代码或者光标所在当前行 Alt+left/right:切换代码视图 Alt+up/down:在方法间快速切换 F2 or Shift+F2:代码异常快速定位位置Alt+F8:计算变量值 Ctrl+B/Ctrl+Click:快速打开光标处的类或方法（跳转到定义处）Ctrl+O:Overrider:重写Ctrl+Shift+J:整合两行Ctrl+Shift+U:大小写转化Ctrl+Alt+S:打开设置对话框 Alt+Shift+Inert:开启/关闭列选择模式 Ctrl+BackSpace:按单词删除 查找/替换 Ctrl+R:替换文本Ctrl+F:查找文本F3: 查找时，跳转到下一个Shift+F3:查找时，跳转到上一个Ctrl+Shift+F:指定路径下全文搜索Ctrl+Shift+R:指定路径下全文替换Alt+F1:查找代码所在位置Ctrl+Alt+left/right:代码浏览的位置切换Ctrl+Shift+BackSpace:返回到上次编辑的位置Ctrl+Alt+Up/Down:快速跳转搜索结果 Ctrl+G:定位行 调试/运行 Ctrl+F2:停止Alt+Shift+F9:选择Debug模式启动Alt+Shift+F10:选择Run模式启动Ctrl+Shift+F9:编译Ctrl+Shift+F10:运行Ctrl+Shift+F8:查看断点F8:步进F9:恢复程序，直到下一个断点，如果没有断点，直接运行完成Alt+F9:运行至光标处Ctrl+Alt+F9:强制运行至光标处 代码提交 Ctrl+K:打开代码提交界面：Commit ChangesCtrl+T:更新（Update Project） 较少使用 Ctrl+F7 :当前选中元素在当前文件中的引用，按F3可以在找到的多个引用元素间跳转Alt+Q:快速查看当前方法的声明Ctrl+Alt+O:优化导入的类和包Ctrl+Shift+Alt+N:查找类中的方法或变量Ctrl+J:自动代码（例如：serr）Ctrl+Alt+J:用动态模板环绕Ctrl+H:显示类结构图（类的继承层次）Ctrl+Q:显示注释文档Tab:代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7:高亮显示所有该文本，按 Esc 高亮消失，类似选中文本然后Ctrl+FAlt+F3:逐个往下查找相同文本，并高亮显示Ctrl+Up/Down:光标中转到第一行或最后一行下Ctrl+Alt+Space:类名自动完成Shift+Esc:不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12:把焦点从编辑器移到最近使用的工具窗口Alt+Home:跳转到导航栏Ctrl+”+/-”:(小键盘数字)当前方法展开、折叠Ctrl+Shift+”+/-”:(小键盘数字)全部展开、折叠Ctrl+Enter:上插一行Alt+1:项目Alt+2:收藏Alt+6:TODOAlt+7:结构Ctrl+Alt+Shift+C:复制引用，必须选择类名Shift+F12:还原默认布局 不生效Ctrl+Shift+S:搜索结构Ctrl+Shift+M:替换结构]]></content>
      <categories>
        <category>办公知识</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>IDEA</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA安装免重启服务生效配置的插件]]></title>
    <url>%2F2019%2F02%2F19%2FIDEA%E5%AE%89%E8%A3%85%E5%85%8D%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%95%88%E9%85%8D%E7%BD%AE%E7%9A%84%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前开发过程中总是修改完xml、添加类、方法的时候，重启Tomcat服务，今天有同事提到了一个插件，可以在不用重启Tomcat的时候，就能完成部署操作，这个插件叫JreBel，具体的安装步骤和操作方法如下 下载插件和破解的相关资料链接：https://pan.baidu.com/s/12sU2m7pfE4qVk1EDg98uLg提取码：79an百度网盘路径：我的网盘&gt;安装文件&gt;IDE&gt;IDEA&gt;服务免重启插件 安装 点击File找到Settings 打开Settings,找到Plugins 点击Install from disk，打开选择本地插件选择的对话框 选择刚刚从百度云上下载的插件 选择本地的文件 安装完成后显示如下，需要重启下IDEA才能生效 激活 按照图示将地址和账号输入进去，选择I Agree，点击激活，激活完成后会弹出如下图效果 设置激活完成之后，还需要设置离线可用操作，具体操作方法见下图所示： 使用]]></content>
      <categories>
        <category>软件安装</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>插件安装</tag>
        <tag>IDEA</tag>
        <tag>服务免重启</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer知识点]]></title>
    <url>%2F2019%2F02%2F19%2FSQLServer%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[RTRIM是去除第一个参数中的第二个参数的元素 ，第二个参数不填的话，默认为空格例：去掉FIRSTNAME字段中的空格，RTRIM（FIRSTNAME），RTRIM一般用在计算字段的长度时使用，例如计算FIRSTNAME的长度的SQL是 SELECT FIRSTNAME,LENGTH(RTRIM(FIRSTNAME)) FROM CHARACTERS TO_CHAR将其他数据类型转换为字符型]]></content>
      <categories>
        <category>数据库</category>
        <category>SQLServer</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数据库</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle SQL性能优化]]></title>
    <url>%2F2019%2F02%2F19%2FOracle-SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Oracle SQL查询对于大数据量的查询，通常会因为一些SQL编写上不规范造成效率低的问题，比如在查询中使用START WITH 造成分页的时候，拼接外部，从而改变内部执行策略，本来3S能执行完的SQL，到最后执行了20S+，因此Copy了这篇文章大家看看 SQL语句的执行顺序语法分析&gt; 语义分析&gt; 视图转换 &gt;表达式转换&gt; 选择优化器 &gt;选择连接方式 &gt;选择连接顺序 &gt;选择数据的搜索路径 &gt;运行“执行计划” 选择适合的Oracle优化器RULE（基于规则） COST（基于成本） CHOOSE（选择性） 访问TABLE的方式全表扫描 全表扫描就是顺序地访问表中每条记录，ORACLE采用一次读入多个数据块(database block)的方式优化全表扫描 通过ROWID访问表 ROWID包含了表中记录的物理位置信息，ORACLE采用索引实现了数据和存放数据的物理位置(ROWID)之间的联系，通常索引提供了快速访问ROWID的方法，因此那些基于索引列的查询就可以得到性能上的提高 共享 SQL 语句 Oracle提供对执行过的SQL语句进行高速缓冲的机制。被解析过并且确定了执行路径的SQL语句存放在SGA的共享池中 Oracle执行一个SQL语句之前每次先从SGA共享池中查找是否有缓冲的SQL语句，如果有则直接执行该SQL语句 可以通过适当调整SGA共享池大小来达到提高Oracle执行性能的目的 选择最有效率的表名顺序 ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，因此FROM子句中写在最后的表(基础表 driving table)将被最先处理 当ORACLE处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表(FROM子句中最后的那个表)并对记录进行排序，然后扫描第二个表(FROM子句中最后第二个表)，最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并 只在基于规则的优化器中有效 简单来说，就是把数据多的放在左侧，数据少的放在右侧（描述有待大家考证） 举例： 表 TAB1 16,384 条记录 表 TAB2 1 条记录 12345 /*选择TAB2作为基础表 (最好的方法)*/select count(*) from tab1,tab2 执行时间0.96秒 /*选择TAB2作为基础表 (不佳的方法)*/select count(*) from tab2,tab1 执行时间26.09秒 如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。 EMP:交叉表，包含LOCATION和CATEGORY的关联关系 1234SELECT * FROM LOCATION L, CATEGORY C, EMP EWHERE E.EMP_NO BETWEEN 1000 AND 2000 AND E.CAT_NO = C.CAT_NO AND E.LOCN = L.LOCN 将比下列SQL更有效率 1234SELECT * FROM EMP E, LOCATION L, CATEGORY CWHERE E.CAT_NO = C.CAT_NO AND E.LOCN = L.LOCN AND E.EMP_NO BETWEEN 1000 AND 2000 Where子句中的连接顺序Oracle采用自下而上的顺序解析WHERE子句。 根据这个原理,表之间的连接必须写在其他WHERE条件之前，那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾 1234567/*低效,执行时间156.3秒*/SELECT … FROM EMP EWHERE SAL &gt; 50000 AND JOB = ‘MANAGER’ AND 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR = E.EMPNO) 1234567/*高效,执行时间10.6秒*/SELECT … FROM EMP EWHERE 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR=E.EMPNO) AND SAL &gt; 50000 AND JOB = ‘MANAGER’ SELECT子句中避免使用“*” Oracle在解析SQL语句的时候，对于“*”将通过查询数据库字典来将其转换成对应的列名。 如果在Select子句中需要列出所有的Column时，建议列出所有的Column名称，而不是简单的用“*”来替代，这样可以减少多于的数据库查询开销 减少访问数据库的次数当执行每条SQL语句时, ORACLE在内部执行了许多工作： 解析SQL语句 &gt; 估算索引的利用率 &gt; 绑定变量 &gt; 读数据块等等 由此可见, 减少访问数据库的次数 , 就能实际上减少ORACLE的工作量 整个简单无关联的数据库访问如果有几个简单的数据库查询语句，你可以把它们整合到一个查询中（即使它们之间没有关系），以减少多于的数据库IO开销。 虽然采取这种方法，效率得到提高，但是程序的可读性大大降低，所以还是要权衡之间的利弊 使用Truncate而非Delete Delete表中记录的时候，Oracle会在Rollback段中保存删除信息以备恢复。Truncate删除表中记录的时候不保存删除信息，不能恢复。因此Truncate删除记录比Delete快，而且占用资源少 删除表中记录的时候，如果不需要恢复的情况之下应该尽量使用Truncate而不是Delete Truncate仅适用于删除全表的记录 尽量多使用COMMIT只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少 COMMIT所释放的资源： 回滚段上用于恢复数据的信息 被程序语句获得的锁 redo log buffer 中的空间 ORACLE为管理上述3种资源中的内部花费 计算记录条数123Select count(*) from tablename;Select count(1) from tablename;Select max(rownum) from tablename; 一般认为，在没有索引的情况之下，第一种方式最快。 如果有索引列，使用索引列当然最快 用Where子句替换Having子句避免使用HAVING子句，HAVING 只会在检索出所有记录之后才对结果集进行过滤。这个处理需要排序、总计等操作。 如果能通过WHERE子句限制记录的数目，就能减少这方面的开销 减少对表的查询操作在含有子查询的SQL语句中，要注意减少对表的查询操作 12345678/*低效的查询方式*/SELECT TAB_NAME FROM TABLESWHERE TAB_NAME =（SELECT TAB_NAME FROM TAB_COLUMNS WHERE VERSION = 604） AND DB_VER =（SELECT DB_VER FROM TAB_COLUMNS WHERE VERSION = 604） 12345SELECT TAB_NAME FROM TABLESWHERE （TAB_NAME，DB_VER）= （SELECT TAB_NAME，DB_VER FROM TAB_COLUMNS WHERE VERSION = 604） 使用表的别名（Alias）当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。 Column歧义指的是由于SQL中不同的表具有相同的Column名,当SQL语句中出现这个Column时,SQL解析器无法判断这个Column的归属。 用EXISTS替代IN在许多基于基础表的查询中，为了满足一个条件 ，往往需要对另一个表进行联接。在这种情况下，使用EXISTS(或NOT EXISTS)通常将提高查询的效率 123456/*低效*/SELECT * FROM EMP (基础表)WHERE EMPNO &gt; 0 AND DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB’) 1234567/*高效*/SELECT * FROM EMP (基础表)WHERE EMPNO &gt; 0 AND EXISTS (SELECT ‘X’ FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB’) 用NOT EXISTS替代NOT IN在子查询中，NOT IN子句将执行一个内部的排序和合并，对子查询中的表执行一个全表遍历，因此是非常低效的。 为了避免使用NOT IN，可以把它改写成外连接（Outer Joins）或者NOT EXISTS。 123456/*低效*/SELECT … FROM EMPWHERE DEPT_NO NOT IN （SELECT DEPT_NO FROM DEPT WHERE DEPT_CAT=’A’） 1234567/*高效*/SELECT …. FROM EMP EWHERE NOT EXISTS （SELECT ‘X’ FROM DEPT D WHERE D.DEPT_NO = E.DEPT_NO AND DEPT_CAT = ‘A’） 用表连接替换EXISTS通常来说 ，采用表连接的方式比EXISTS更有效率 。 1234567/*低效*/SELECT ENAME FROM EMP EWHERE EXISTS （SELECT ‘X’ FROM DEPT WHERE DEPT_NO = E.DEPT_NO AND DEPT_CAT = ‘A’） 12345/*高效*/SELECT ENAME FROM DEPT D，EMP EWHERE E.DEPT_NO = D.DEPT_NO AND DEPT_CAT = ‘A’ 用EXISTS替换DISTINCT当提交一个包含对多表信息（比如部门表和雇员表）的查询时，避免在SELECT子句中使用DISTINCT。 一般可以考虑用EXIST替换。 EXISTS 使查询更为迅速，因为RDBMS核心模块将在子查询的条件一旦满足后，立刻返回结果 1234/*低效*/SELECT DISTINCT DEPT_NO，DEPT_NAME FROM DEPT D，EMP E WHERE D.DEPT_NO = E.DEPT_NO 123456/*高效*/SELECT DEPT_NO，DEPT_NAME FROM DEPT D WHERE EXISTS （SELECT ‘X’ FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO 识别低效的SQL语句下面的SQL工具可以找出低效SQL 123456789SELECT EXECUTIONS, DISK_READS, BUFFER_GETS, ROUND ((BUFFER_GETS-DISK_READS)/BUFFER_GETS, 2) Hit_radio, ROUND (DISK_READS/EXECUTIONS, 2) Reads_per_run, SQL_TEXTFROM V$SQLAREAWHERE EXECUTIONS&gt;0AND BUFFER_GETS &gt; 0AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8ORDER BY 4 DESC 另外也可以使用SQL Trace工具来收集正在执行的SQL的性能状态数据，包括解析次数，执行次数，CPU使用时间等 用Explain Plan分析SQL语句EXPLAIN PLAN 是一个很好的分析SQL语句的工具, 它甚至可以在不执行SQL的情况下分析语句. 通过分析, 我们就可以知道ORACLE是怎么样连接表, 使用什么方式扫描表(索引扫描或全表扫描)以及使用到的索引名称 SQL PLUS的TRACE1234567891011121314SQL&gt; list SELECT * FROM dept, emp 3* WHERE emp.deptno = dept.deptnoSQL&gt; set autotrace traceonly /*traceonly 可以不显示执行结果*/SQL&gt; /rows selected.Execution Plan---------------------------------------------------------- SELECT STATEMENT Optimizer=CHOOSE 0 NESTED LOOPS 1 TABLE ACCESS (FULL) OF 'EMP' 1 TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' 3 INDEX (UNIQUE SCAN) OF 'PK_DEPT' (UNIQUE) 用索引提高效率 特点 优点：提高效率 主键的唯一性验证 代价：需要空间存储 定期维护 重构索引： 1ALTER INDEX &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt; Oracle对索引的两种访问模式 索引唯一扫描 (Index Unique Scan) 索引范围扫描 (Index Range Scan) 基础表的选择 基础表(Driving Table)是指被最先访问的表(通常以全表扫描的方式被访问)。 根据优化器的不同，SQL语句中基础表的选择是不一样的 如果你使用的是CBO (COST BASED OPTIMIZER)，优化器会检查SQL语句中的每个表的物理大小，索引的状态，然后选用花费最低的执行路径 如果你用RBO (RULE BASED OPTIMIZER)， 并且所有的连接条件都有索引对应，在这种情况下，基础表就是FROM 子句中列在最后的那个表 多个平等索引 当SQL语句的执行路径可以使用分布在多个表上的多个索引时，ORACLE会同时使用多个索引并在运行时对它们的记录进行合并，检索出仅对全部索引有效的记录 在ORACLE选择执行路径时，唯一性索引的等级高于非唯一性索引。然而这个规则只有当WHERE子句中索引列和常量比较才有效。如果索引列和其他表的索引类相比较。这种子句在优化器中的等级是非常低的 如果不同表中两个相同等级的索引将被引用，FROM子句中表的顺序将决定哪个会被率先使用。 FROM子句中最后的表的索引将有最高的优先级 如果相同表中两个相同等级的索引将被引用，WHERE子句中最先被引用的索引将有最高的优先级 等式比较优先于范围比较 DEPTNO上有一个非唯一性索引，EMP_CAT也有一个非唯一性索引 1234SELECT ENAME FROM EMP WHERE DEPTNO &gt; 20 AND EMP_CAT = ‘A’; 这里只有EMP_CAT索引被用到,然后所有的记录将逐条与DEPTNO条件进行比较. 执行路径如下: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON CAT_IDX 即使是唯一性索引，如果做范围比较，其优先级也低于非唯一性索引的等式比较 不明确的索引等级 当ORACLE无法判断索引的等级高低差别，优化器将只使用一个索引,它就是在WHERE子句中被列在最前面的 DEPTNO上有一个非唯一性索引，EMP_CAT也有一个非唯一性索引 1234SELECT ENAME FROM EMP WHERE DEPTNO &gt; 20 AND EMP_CAT &gt; ‘A’; 这里, ORACLE只用到了DEPT_NO索引. 执行路径如下: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON DEPT_IDX 强制索引失效 如果两个或以上索引具有相同的等级，你可以强制命令ORACLE优化器使用其中的一个(通过它,检索出的记录数量少) 。 12345SELECT ENAMEFROM EMPWHERE EMPNO = 7935 AND DEPTNO + 0 = 10 /*DEPTNO上的索引将失效*/AND EMP_TYPE || ‘’ = ‘A’ /*EMP_TYPE上的索引将失效*/ 避免在索引上使用计算 WHERE子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描 自动选择索引 如果表中有两个以上（包括两个）索引，其中有一个唯一性索引，而其他是非唯一性索引。在这种情况下，ORACLE将使用唯一性索引而完全忽略非唯一性索引 1234SELECT ENAME FROM EMPWHERE EMPNO = 2326 AND DEPTNO = 20 ; 这里，只有EMPNO上的索引是唯一性的，所以EMPNO索引将用来检索记录。 TABLE ACCESS BY ROWID ON EMP INDEX UNIQUE SCAN ON EMP_NO_IDX 避免在索引上使用NOT 通常，我们要避免在索引列上使用NOT，NOT会产生在和在索引列上使用函数相同的影响。当ORACLE遇到NOT，它就会停止使用索引转而执行全表扫描 1234/*低效*/ SELECT … FROM DEPT WHERE NOT DEPT_CODE = 0 用&gt;=代替&gt; 如果DEPTNO上有一个索引 1234/*高效*/SELECT * FROM EMP WHERE DEPTNO &gt;=4 两者的区别在于，前者DBMS将直接跳到第一个DEPT等于4的记录，而后者将首先定位到DEPTNO等于3的记录并且向前扫描到第一个DEPT大于3的记录. 用Union替换OR（适用于索引列）通常情况下，用UNION替换WHERE子句中的OR将会起到较好的效果。对索引列使用OR将造成全表扫描。 注意，以上规则只针对多个索引列有效 12345678/*高效*/SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 UNION SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE REGION = “MELBOURNE” 1234/*低效*/SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 用IN替换OR123456/*低效*/SELECT…. FROM LOCATIONWHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 123SELECT… FROM LOCATIONWHERE LOC_IN IN （10，20，30） 实际的执行效果还须检验，在ORACLE8i下， 两者的执行路径似乎是相同的 避免在索引上使用IS NULL 和IS NOT NULL避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引 1234/*低效*/SELECT … FROM DEPARTMENTWHERE DEPT_CODE IS NOT NULL; 1234/*高效*/SELECT … FROM DEPARTMENTWHERE DEPT_CODE &gt;=0; 总是使用索引的第一列如果索引是建立在多个列上， 只有在它的第一个列(leading column)被where子句引用时， 优化器才会选择使用该索引。 12345678SQL&gt; create index multindex on multiindexusage(inda,indb);Index created.SQL&gt; select * from multiindexusage where indb = 1;Execution Plan---------------------------------------------------------- SELECT STATEMENT Optimizer=CHOOSE 0 TABLE ACCESS (FULL) OF 'MULTIINDEXUSAGE' 很明显, 当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引。 使用UNION ALL替换UNION当SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION-ALL的方式被合并，然后在输出最终结果前进行排序。如果用UNION ALL替代UNION，这样排序就不是必要了，效率就会因此得到提高。 由于UNION ALL的结果没有经过排序，而且不过滤重复的记录，因此是否进行替换需要根据业务需求而定。 对UNION的优化由于UNION会对查询结果进行排序，而且过滤重复记录，因此其执行效率没有UNION ALL高。 UNION操作会使用到SORT_AREA_SIZE内存块，因此对这块内存的优化也非常重要。 可以使用下面的SQL来查询排序的消耗量 ： 1234select substr（name，1，25） "Sort Area Name"， substr（value，1，15） "Value"from v$sysstatwhere name like 'sort%' 避免改变索引列的类型当比较不同数据类型的数据时， ORACLE自动对列进行简单的类型转换。 123456789/*假设EMP_TYPE是一个字符类型的索引列.*/SELECT … FROM EMP WHERE EMP_TYPE = 123/*这个语句被ORACLE转换为:*/SELECT … FROM EMP WHERE TO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换，这个索引将不会被用到 几点注意： 当比较不同数据类型的数据时，ORACLE自动对列进行简单的类型转换 如果在索引列上面进行了隐式类型转换，在查询的时候将不会用到索引 注意当字符和数值比较时，ORACLE会优先转换数值类型到字符类型 为了避免ORACLE对SQL进行隐式的类型转换，最好把类型转换用显式表现出来 几种不能使用索引的WHERE子句 下面的例子中，‘!=’ 将不使用索引 ，索引只能告诉你什么存在于表中，而不能告诉你什么不存在于表中 1234/*不使用索引*/SELECT ACCOUNT_NAME FROM TRANSACTION WHERE AMOUNT !=0； 1234/*使用索引*/SELECT ACCOUNT_NAME FROM TRANSACTION WHERE AMOUNT &gt; 0； 下面的例子中，‘||’是字符连接函数。就象其他函数那样，停用了索引 1234/*不使用索引*/SELECT ACCOUNT_NAME，AMOUNT FROM TRANSACTIONWHERE ACCOUNT_NAME||ACCOUNT_TYPE=’AMEXA’； 12345/*使用索引*/SELECT ACCOUNT_NAME，AMOUNT FROM TRANSACTIONWHERE ACCOUNT_NAME = ‘AMEX’ AND ACCOUNT_TYPE=’ A’； 下面的例子中，‘+’是数学函数。就象其他数学函数那样，停用了索引。 1234/*不使用索引*/SELECT ACCOUNT_NAME，AMOUNT FROM TRANSACTIONWHERE AMOUNT + 3000 &gt;5000； 1234/*使用索引*/SELECT ACCOUNT_NAME，AMOUNTFROM TRANSACTIONWHERE AMOUNT &gt; 2000 ； 下面的例子中，相同的索引列不能互相比较，这将会启用全表扫描 1234/*不使用索引*/SELECT ACCOUNT_NAME, AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME = NVL(:ACC_NAME, ACCOUNT_NAME) 1234/*使用索引*/SELECT ACCOUNT_NAME，AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME LIKE NVL(:ACC_NAME, ’%’) 连接多个扫描如果对一个列和一组有限的值进行比较，优化器可能执行多次扫描并对结果进行合并连接 举例： 123SELECT * FROM LODGING WHERE MANAGER IN (‘BILL GATES’, ’KEN MULLER’) 优化器可能将它转换成以下形式： 1234SELECT * FROM LODGING WHERE MANAGER = ‘BILL GATES’ OR MANAGER = ’KEN MULLER’ CBO下使用更具选择性的索引 基于成本的优化器（CBO，Cost-Based Optimizer）对索引的选择性进行判断来决定索引的使用是否能提高效率 如果检索数据量超过30%的表中记录数，使用索引将没有显著的效率提高 在特定情况下，使用索引也许会比全表扫描慢。而通常情况下，使用索引比全表扫描要块几倍乃至几千倍 避免使用耗费资源的操作 带有DISTINCT，UNION，MINUS，INTERSECT，ORDER BY的SQL语句会启动SQL引擎执行耗费资源的排序（SORT）功能。DISTINCT需要一次排序操作，而其他的至少需要执行两次排序 通常，带有UNION，MINUS，INTERSECT的SQL语句都可以用其他方式重写 优化GROUP BY提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉 123456 /*低效*/ SELECT JOB ，AVG（SAL） FROM EMP GROUP BY JOBHAVING JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ 123456/*高效*/SELECT JOB，AVG（SAL） FROM EMPWHERE JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’GROUP BY JOB 使用日期当使用日期时，需要注意如果有超过5位小数加到日期上，这个日期会进到下一天 123456789SELECT TO_DATE（‘01-JAN-93’+.99999） FROM DUALReturns：’01-JAN-93 23:59:59’SELECT TO_DATE（‘01-JAN-93’+.999999） FROM DUALReturns：’02-JAN-93 00:00:00’ 使用显示游标（CURSORS）使用隐式的游标，将会执行两次操作。第一次检索记录，第二次检查TOO MANY ROWS 这个exception。而显式游标不执行第二次操作。 分离表和索引 总是将你的表和索引建立在不同的表空间内（TABLESPACES） 决不要将不属于ORACLE内部系统的对象存放到SYSTEM表空间里 确保数据表空间和索引表空间置于不同的硬盘上]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle知识点]]></title>
    <url>%2F2019%2F02%2F19%2FOracle%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Oracle分组拼接函数123SELECT LISTAGG(ID, ’, ’) WITHIN GROUP(ORDER BY DEPON) FROM TEST_1 GROUP BY DEPON 注意：分组拼接函数在Oracle11g之前是没有的 Sql函数 Oracle中的日期时间函数：在Oracle中以字符串表示的数据是不能自动转换为日期时间类型的，必须使用TO_DATE()函数来手动将字符串转换为日期时间类型，比如 TO_DATE(‘2010-10-10’,’YYYY-MM-DD HH24:MI:SS’)。 Oracle取得系统当前时间：Oracle中没有提供取得当前日期时间的函数，不过我们可以到系统表DUAL中查询SYSTIMESTAMP的值来得到当前的时间戳。如下： 12345Select SYSTIMESTAMPFrom DUAL同样我们可以到系统表DUAL中查询SYSDATE的值来得到当前日期时间。如下：Select SYSDATEFrom DUAL 使用TO_CHAR(时间日期值，’YYYY-MM-DD’)可以得到日期时间值的日期部分，因此下面的SQL语句可以得到当前的日期值： 12Select TO_CHAR(SYSDATE,’YYYY-MM-DD’)From DUAL 日期增减：有时我们需要在一个日期的基础上增加某个时间长度或者减去某个时间长度，比如我们知道每个员工的出生日期，而想计算出他出生后10000 天的日期，再如我们想计算所有合同的到期日的三月后的日期。Oracle中可以直接使用加号“+”来进行日期的加法计算，其计算单位为“天”，比如date+3就表示在日期date的基础上增加三天；同理使用减号“-”则可以用来计算日期前的特定时间段的时间，比如date-3就表示在日期date的三天前的日期。比如下面的sql语句用于计算每个人出生日期3天后以及10天前的日期； 1234Select FBirthDay，FBirthDay+3，FBirthDay-10From T_Person Oracle中提供了ADD_MONTHS()函数用于以月为单位的日期增减运算，ADD_MONTHS()函数的参数格式如下：ADD_MONTHS(date，number) 其中参数date为待计算的日期，参数number为要增加的月份数，如果number为负数则表示进行日期的减运算。下面的SQL语句用于计算每个人的出生日期两个月后以及10个月前的日期： 1234Select FBirthDay,ADD_MONTHS(FBirthDay,2),ADD_MONTHS(FBirthDay,-10)From T_Person 计算日期差额：在Oracle中，可以在两个日期类型的数据之间使用减号运算符“-”，其计算结果为两个日期之间的天数差。比如执行下面的SQL语句用于计算注册日期FRegDay和出生日期FBirthDay之间的时间间隔： 12Select FRegDay,FBirthDay,FRegDay – FbirthDayFrom T_Person 计算一个日期是星期几：Oracle中提供了TO_CHAR（）函数用于将数据转换为字符串类型，当针对时间日期类型数据进行转换的时候，它接受两个参数，其参数格式如下：TO_CHAR(date,format)其中参数date为待转换的日期，参数format为格式化字符串，数据库系统将按照这个字符串对date进行转换。如下是以2008-08-08这样的形式显示出生日期： 123Select FBirthDay，TO_CHAR(FbirthDay，’YYYY-MM-DD’) as 出生日期From TPerson 取得日期的指定部分：提取日期的特定不是非常有必要的，比如检索本年的每个月的16日的销售量、检索访问用户集中的时间段，这些都需要对日期的特定部分进行提取。使用TO_CHAR()函数就可以提取日期的任意部分，比如下面的SQL用于提取每个人员的出生年份、出生时是当年的第几天、出生时是当年的第几周： 123456SelectFBirthDay,TO_CHAR(FBirthDay,’YYYY’) AS y,TO_CHAR(FBirthDay,’DDD’) AS d,TO_CHAR(FBirthDay,’WW’) AS uFrom T_Person 类型转换：在使用SQL语句的时候，我们使用的数据的类型不一定符合函数或者运算符的需要，比如函数需要整数类型的数据而我们使用的则是一个字符串，在一些情况下数据库系统会替我们自动将字符串类型转换为整数类型，这种转换称为隐式转换。但是在有的情况下数据库系统不会进行隐式转换，这时就要使用类型转换函数了，这种转换称为显式转换。使用类型转换函数不仅可以保证类型转换的正确性，而且可以提高数据处理的速度，因此应该使用显式转换，尽量避免使用隐式转换。Oracle提供了针对TO_CHAR()、TO_DATE()、TO_NUMBER()等函数，这些函数可以将数据显示的转换为字符串类型、日期时间类型或者数值类型。Oracle中还提供了HEXTORAW()、RAWTOHEX()、TO_MULTI_BYTE()、TO_SINGLE_BYTE()等函数用于存储格式的转换。1） TO_CHAR()TO_CHAR()函数用来将时间日期类型或者数值类型的数据转换为字符串，其参数格式如下：TO_CHAR(expression，format)，参数expression为待转换的表达式，参数format为转换后的字符串格式，参数format可以省略，如果省略参数format将会按照数据库系统内置的转换规则进行转换。2） TO_DATE()函数用来将字符串转换为时间类型，其参数格式如下：TO_DATE(expression，format)，参数expression为待转换的表达式，参数format为转换格式，参数format可以省略，如果省略参数format将会按照数据库系统内置的转换规则进行转换。下面的SQL语句用于将字符串形式的数据按照特定的格式解析为日期类型： 1234SelectTO_DATE('2008-08-08 08:09:10', 'YYYY-MM-DD HH24:MI:SS') as dt1,TO_DATE('20080808 080910', 'YYYYMMDD HH24MISS') as dt2From DUAL TO_NUMBER()函数用法类似3） HEXTORAW()、RAWTOHEX()：HEXTORAW()用于将十六进制格式的数据转换为原始值，而RAWTOHEX()函数用来将原始值转换为十六进制格式的数据4） TO_MULTI_BYTE()、TO_SINGLE_BYTE()：TO_MULTI_BYTE()函数用于将字符串中的半角字符转换为全角字符，而TO_SINGLE_BYTE()`函数则用来将字符串中的全角字符转换为半角字符。 空值处理：主流数据库系统都支持COLAESCE()函数，这个函数主要用来进行空值处理，其参数格式如下：COLAESCE(expression，valuel,value2……,valuen)COLAESEC()函数的第一个参数expression为待检测的表达式，而其后的参数个数不定。COLAESEC()函数将会返回包括expression在内的所有参数中的第一个非空表达式。如果expression不为空值则返回expression；否则不、判断value1是否是空值，如果value1不为空值则返回value1；否则判断value2是否是空值，如果value2不为空值则返回value3；……以此类推，如果所有的表达式都为空值，则返回NULL。Oracle中NVL(expression1,expression2)函数将NULL转变为实际值，如果expression1不为NULL则返回expression1，若为NULL则返回expression2，两个表达式可以是任意数据类型，但两个表达式的数据类型必须一致。而函数NVL2(expr1,expr2,expr3)，如果expr1不是NULL，则返回expr2；如果expr1是NULL，则返回expr3。参数expr1可以是任意数据类型，而expr2和expr3可以是除LONG类型之外的任何数据类型，但三者的数据类型必须保持一致。 自动增长字段：在Oracle中可以通过SEQUENCE序列来实现自动增长字段，在Oracle中SEQUENCE被称为序列，每次取的时候它会自动增加，一般用在需要按序列号排序的地方。在使用SEQUENCE前需要首先定义一个SEQUENCE，定义SEQUENCE的语法如下： 123CREATE SEQUENCE sequence_nameINCREMENT BY stepSTART WITH startvalue; 其中sequence_name 为序列的名字，每个序列都必须有唯一的名字；startvalue 参数值为起始数字，step 参数值为步长，即每次自动增长时增加的值。一旦定义了SEQUENCE，你就可以用CURRVAL来取得SEQUENCE的当前值，也可以通过NEXTVAL来增加SEQUENCE，然后返回 新的SEQUENCE值。比如： 12sequence_name.CURRVALsequence_name.NEXTVAL 如果SEQUENCE不需要的话就可以将其删除：DROP SEQUENCE sequence_name; ORACLE中的分析函数（即开窗函数） 按照FSALARY进行排序，ROWS 按照行数进行范围定位; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM T_PERSON; 按照FSALARY进行排序，RANGE 按照FSALARY值范围进行定位; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM T_PERSON; 按照FSALARY进行排序，计算从当前行的前两行与当前行的后两行的和; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) FROM T_PERSON; 按照FSALARY进行排序，计算从当前行的后一行到当前行的后三行的和，注意：最后一行没有后续行，其计算结果为空值NULL而非0; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY ROWS BETWEEN 1 FOLLOWING AND 3 FOLLOWING) FROM T_PERSON; Oracle中的聚合函数MAX() 该函数用于取得列或表达式的最大值，它适用于任何数据类型；MIN() 该函数用于取得列或表达式的最小值，它适用于任何数据类型；AVG() 该函数用于取得列或表达式的平均值，它适用于任何数据类型；SUM() 该函数用于取得列或表达式的总和，它适用于任何数据类型；COUNT() 该函数用于取得总计行数；VARIANCE() 该函数用于取得列或表达式的方差，并且该函数只适用于数字类型。当只有一行数据时，其值返回为0；当存在多行数据时，方差是按照如下公式计算取得：(SUM(EXPR)2-SUM(EXPR)2/COUNT(EXPR))/(COUNT(EXPR)-1);STDDEV() 该函数用于取得列或表达式的标准偏差，并且该函数只适用于数字类型。当只有一行数据时，其值返回为0；当存在多行数据时，Oracle按照方差的平方根来计算标准偏差。 创建表空间12CREATE TABLESPACE USER_IRS_SPACE DATAFILE'D:\oracle\product\10.1.0\oradata\orcl\USER_IRS_TBS_temp01.dbf'SIZE 500M AUTOEXTEND ON NEXT 50MCREATE TABLESPACE USER_IRS_TBS DATAFILE 'D:\oracle\product\10.1.0\oradata\orcl\USER_IRS_TBS_temp01.dbf'size 500M autoextend on next 50M 备份数据库 如果所有数据都对，但是就是倒不出来的话，可以看下Oracle的基本服务是不是开了，例如Services服务是不是开了exp sgirs/sgirsdb@orcl file=&#39;D :\db.dmp&#39; 数据库导入imp sgirs/sgirsdb file=&#39;D:\dba.dmp&#39; ORACLE查询表死锁 查看锁表进程SQL语句1： 12345678910select sess.sid, sess.serial#, lo.oracle_username, lo.os_user_name, ao.object_name, lo.locked_mode from v$locked_object lo, dba_objects ao, v$session sesswhere ao.object_id = lo.object_id and lo.session_id = sess.sid; 查看锁表进程SQL语句2： 1select * from v$session t1, v$locked_object t2 where t1.sid = t2.SESSION_ID; 杀掉锁表进程如有記錄則表示有lock，記錄下SID和serial# ，將記錄的ID替換下面的738,1429，即可解除LOCK 1alter system kill session '738,1429'; 一次插入多条数据需要注意，最后的select * from dual不能少1234insert allinto table1(filed1,filed2)values('value1','value2')into table2(字段1，字段2，字段3) values(值1，值2，值3)select * from dual;]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL对于大小写敏感问题的处理方式]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Linux上安装MySQL默认是数据库的表大小写敏感的。修改很简单，只要该一个mysql的配置文件就可以了。 修改配置文件my.cnf 编辑my.cnf文件 1vim /etc/my.cnf 添加lower_case_table_names=1，添加完成后的效果如下 12345[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockskip-grant-tableslower_case_table_names=1 重启数据库123[root@chicago init.d]# service mysql restartShutting down MySQL.. [ OK ]Starting MySQL...................................... [ OK ] 验证]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>大小写敏感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自动扣款存储过程Demo]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E8%87%AA%E5%8A%A8%E6%89%A3%E6%AC%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8BDemo%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CREATEPROCEDURE charge.seven_days_auto_pay()BEGIN#订单编号DECLARE orderId VARCHAR (32);#租户IDDECLARE tenantId VARCHAR (20);#用户充电金额DECLARE chargePrice DECIMAL (10,2);#用户余额DECLARE ownCoin DECIMAL(10,2);#充电记录IDDECLARE chargesId VARCHAR(500);#遍历数据结束标志DECLARE done INT DEFAULT FALSE;#Routine body goes here...DECLARE cur CURSOR FOR SELECT id,tenant_id,charge_priceFROM t_order INNER JOIN t_user_person ON userid = tenant_idWHERE t_order.create_time &lt; DATE_ADD(NOW(), INTERVAL - 7 DAY)AND order_state = 4AND del = 0#测试服务器上出现userid在t_user_person没有的情况AND charge_price &gt; 0 ORDER BY tenant_id;#将结束标志绑定到游标DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;OPEN cur;#开始循环read_loop:LOOP #提取游标中的数据 FETCH cur INTO orderId,tenantId,chargePrice;IF done THEN LEAVE read_loop;END IF;#使用事务START TRANSACTION;#获取一个订单的充电记录SELECT GROUP_CONCAT(id) INTO chargesId FROM t_charging WHERE order_id = orderId AND del = 0 AND valid = 0 GROUP BY order_id;#首先判断用户的余额是否大于订单金额SELECT charging_coins INTO ownCoin FROM t_user_person WHERE userid = tenantId LIMIT 1 FOR UPDATE;IF ownCoin &gt;= chargePrice THEN #处理订单表中的订单为已付款、充电币支付等 UPDATE t_order SET pay_time = NOW(),order_state=5,coins_flag=1,consume_coins = charge_price WHERE id = orderId AND order_state = 4; SELECT ROW_COUNT() INTO @rc; IF @rc = 0 THEN ROLLBACK; ITERATE read_loop; END IF; #处理用户表中充电币数据 UPDATE t_user_person SET charging_coins = (ownCoin-chargePrice) WHERE userid = tenantId AND deleted = 0; #处理t_pay表中的充电记录数据 INSERT INTO t_pay (id,order_id,pay_success,defray_time,charges,total_price,create_time,has_inqueue) VALUES (CONCAT('10',UNIX_TIMESTAMP()*10000,FLOOR(1000+RAND()*9000)),orderId,1,NOW(),chargesId,chargePrice,NOW(),0); #处理t_chargingcoins_pay_record中数据 INSERT INTO t_chargingcoins_pay_record (id,userid,pay_money,order_no,pay_time,create_time,remain_coins) VALUES(CONCAT('10',UNIX_TIMESTAMP()*10000,FLOOR(1000+RAND()*9000)),tenantId,chargePrice,orderId,NOW(),NOW(),(ownCoin-chargePrice)); #处理t_charging表中的充电记录数据 UPDATE t_charging SET pay_time = NOW(), pay_flag=2 WHERE order_id = orderId AND del = 0 AND valid = 0;END IF;COMMIT;END LOOP;CLOSE cur;END]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.1安装MySQL]]></title>
    <url>%2F2019%2F02%2F19%2FCentos7-1%E5%AE%89%E8%A3%85MySQL%2F</url>
    <content type="text"><![CDATA[安装MySQL12345# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm# rpm -ivh mysql-community-release-el7-5.noarch.rpm# yum install mysql-community-server安装成功后重启mysql服务。# service mysqld restart 登录MySQL1[root@yl-web yl]# mysql -u root 显示已有数据库1mysql&gt; show databases; 设置密码不需要重启数据库即可生效。1mysql&gt; set password for 'root'@'localhost' =password('password'); 修改配置文件配置Mysqlmysql配置文件为/etc/my.cnf 远程设置123456mysql&gt;create user 'username'@'%' identified by 'password'; //创建用户mysql&gt; grant all privileges on *.* to root@'%'identified by 'password';//把在所有数据库的所mysql&gt; flush privileges;# 有表的所有权限赋值给位于所有IP地址的root用户。# 查看mysql授权用户列表 select distinct contact('user:',user,'host:',host) from mysql.user; 开放服务器对应的3306端口号12firewall-cmd --add-port=3306/tcp --permanent //添加端口号firewall-cmd --reload //重新加载端口 其他设置mysql数据库不区分大小写 在/etc/mg.cnf的[msqld]节点下面增加lower_case_table_names=1然后重启mysql`数据库就可以了]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>MySQL</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中授权及撤销]]></title>
    <url>%2F2019%2F02%2F19%2Fmysql%E4%B8%AD%E6%8E%88%E6%9D%83%E5%8F%8A%E6%92%A4%E9%94%80%2F</url>
    <content type="text"><![CDATA[grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权力 12345grant select on testdb.* to common_user@'client_ip' identified by 'password';grant insert on testdb.* to common_user@'client_ip' identified by 'password';grant update on testdb.* to common_user@'client_ip' identified by 'password';grant delete on testdb.* to common_user@'client_ip' identified by 'password';grant select, insert, update, delete on testdb.* to common_user@'%' identified by 'password'; grant 数据库开发人员，创建表、索引、视图、存储过程、函数等权限, 12345678910111213141516171819202122grant 创建、修改、删除 MySQL 数据表结构权限。grant create on testdb.* to developer@'192.168.0.%' identified by 'password'; grant alter on testdb.* to developer@'192.168.0.%' identified by 'password'; grant drop on testdb.* to developer@'192.168.0.%' identified by 'password';grant 操作 MySQL 外键权限：grant references on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 临时表权限：grant create temporary tables on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 索引权限：grant index on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 视图、查看视图源代码权限：grant create view on testdb.* to developer@'192.168.0.%'; grant show view on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 存储过程、函数权限：grant create routine on testdb.* to developer@'192.168.0.%';grant alter routine on testdb.* to developer@'192.168.0.%';grant execute on testdb.* to developer@'192.168.0.%'; grant 普通 DBA 管理某个 MySQL 数据库的权限 1grant all privileges on testdb to dba@'localhost' grant 高级 DBA 管理 MySQL 中所有数据库的权限 1grant all on *.* to dba@'localhost' MySQL grant 权限，分别可以作用在多个层次上 12345grant 作用在单个数据库上：grant select on testdb.* to dba@localhost; -- dba 可以查询 testdb 中的表。 grant 作用在单个数据表上：grant select, insert, update, delete on testdb.orders to dba@localhost; 这里在给一个用户授权多张表时，可以多次执行以上语句。例如： 123456789grant select(user_id,username) on smp.users to mo_user@'%' identified by '123345'; grant select on smp.mo_sms to mo_user@'%' identified by '123345'; grant 作用在表中的列上：grant select(id, se, rank) on testdb.apache_log to dba@localhost;grant 作用在存储过程、函数上：grant execute on procedure testdb.pr_add to 'dba'@'localhost' grant execute on function testdb.fn_add to 'dba'@'localhost' 查看 MySQL 用户权限查看当前用户（自己）权限： 1show grants; 查看其他 MySQL 用户权限： 1show grants for dba@localhost; 撤销已经赋予给 MySQL 用户权限的权限。 1revoke all on *.* from dba@localhost;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>授权及撤销</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库备份脚本]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[之前的项目中用到了MySQL数据库的备份功能，因此做了如下记录，以便后期用到 123456789101112131415backup_date=`date +'%Y-%m-%d %H:%M:%S'`backup_path="/home/3uadmin/backups"removedate=`date -d "7 day ago" +"%Y-%m-%d"`# 冷备charge库/usr/bin/mysqldump -uhssydbuser --password='hs3u@16171246' --database charge &gt; "$backup_path/charge/$backup_date.db"bzip2 "$backup_path/charge/$backup_date.db"rm -f "$backup_path/charge/$removedate*.db.bz2"# 冷备m2m库/usr/bin/mysqldump -um2m --password='m2mdbroot' --database m2m &gt; "$backup_path/m2m/$backup_date.db"bzip2 "$backup_path/m2m/$backup_date.db"rm -f "$backup_path/m2m/$removedate*.db.bz2"]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL跨数据库查询]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[数据库是否支持第一步是要验证数据库是否支持federated输入show engines，检查显示情况，如果显示support为NO说明已经安装了federated服务，但是没有启动，但是如果没有federated这一行，说明服务都没有启动; 安装服务只需要在my.cnf（一般是在/etc/my.cnf下面）中的[mysqld]的最后一行，添加federated 验证查询的SQL如下12345678CREATE TABLE federated_table ( id int(20) NOT NULL auto_increment, name varchar(32) NOT NULL default '', other int(20) NOT NULL default '0', PRIMARY KEY (id), KEY name (name), KEY other_key (other)) ENGINE=FEDERATED CONNECTION='mysql://username:password@remote_host:3306/db_name/table_name';]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>跨库查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双数据源配置SpringMVC+Spring+Mybatis]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AESpingMVC-Sping-Mybatis%2F</url>
    <content type="text"><![CDATA[最近下载了一个SSM的框架，然后项目上要用到双数据源的情况，因此在这方面查资料查了很久，最终完成了，具体过程如下，有误之处麻烦各位大神指出，及时更新 首当其冲第一步就是修改数据库配置文件，我这里叫dbconfig.properties，修改的时候，只需要把原来的数据库的配置文件复制一套，然后在前面加上对应数据库的标识就行了 修改Sping的配置文件ApplicationContext.xml，复制一套org.springframework.jdbc.datasource.DataSourceTransactionManager对应的bean，修改对应的name值为transactionManager2，然后复制一套数据库连接的配置，改为数据源2的数据信息 再就是DAO层面的修改了，只需要修改两个地方，一个地方是sqlSessionTemplate2对应到上面Spring配置文件中的sqlSessionTemplate2，在一个就是DaoSupport的声明了吧 下面就可以直接使用了 附件源码：双数据源配置代码下载]]></content>
      <categories>
        <category>后端开发框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>双数据源</tag>
        <tag>Mybatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MySQL 插入数据MySQL使用INSERT INTO 语句插入数据 语法1INSERT INTO table_name (filed1, field2, field3) VALUES (value1, value2, value3); 例子：1INSERT INTO tt_area (id, name, pid) VALUES (&apos;1&apos;, &apos;北京&apos;, &apos;0&apos;); MySQL 查询数据123SELECT * FROM TABLE LIMIT 10; #查询前10条数据SELECT * FROM TABLE LIMIT 5,10;#查询6-15条数据，第一个参数是从那条数据开始，第二个参数是指查询多少条SELECT * FROM tt_users A ORDER BY reg_time DESC,reco_name ASC #按照多个字段进行排序，DESC是倒序，ASC是正序，其中 MySQL Update更新数据123456/*通过查询一个表里面的数据更新另一个表中的数据*/UPDATE tableA, tableBSET tableA.columnA = tableB.columnBWHERE tableA.clumnC = tableB.columnD 数据库层面的操作 常规的update 12345mysql -u root -p password #登录mysql数据库use database name #使用哪个数据库实例drop database #删除某个数据库实例mysqldump -u root -p database_name&gt; /usr/data/mysqldata_bak_20171110.db #数据泵导出mysqldump -u root -p database_name&lt; /usr/data/mysqldata_bak_20171011.db #数据泵导入 非常规update(通过子查询更新主表，子查询中牵扯GROUP BY 和 查询条件)首先在数据库创建表，并插入数据，具体的sql如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647DROP TABLE IF EXISTS `demo_value`;CREATE TABLE `demo_value` ( `id` int(5) NOT NULL, `user_id` int(5) DEFAULT NULL, `value` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of demo_value-- ----------------------------INSERT INTO `demo_value` VALUES (&apos;1&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;2&apos;, &apos;1&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;3&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;4&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;5&apos;, &apos;2&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;6&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;7&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;8&apos;, &apos;3&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;9&apos;, &apos;4&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;10&apos;, &apos;4&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;11&apos;, &apos;5&apos;, &apos;40&apos;);INSERT INTO `demo_value` VALUES (&apos;12&apos;, &apos;6&apos;, &apos;20&apos;);DROP TABLE IF EXISTS `demo_value`;CREATE TABLE `demo_value` ( `id` int(5) NOT NULL, `user_id` int(5) DEFAULT NULL, `value` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of demo_value-- ----------------------------INSERT INTO `demo_value` VALUES (&apos;1&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;2&apos;, &apos;1&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;3&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;4&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;5&apos;, &apos;2&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;6&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;7&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;8&apos;, &apos;3&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;9&apos;, &apos;4&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;10&apos;, &apos;4&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;11&apos;, &apos;5&apos;, &apos;40&apos;);INSERT INTO `demo_value` VALUES (&apos;12&apos;, &apos;6&apos;, &apos;20&apos;); 1234567891011UPDATE demo_nameSET sum_value = ( SELECT SUM(`value`) FROM demo_value WHERE demo_value.user_id = demo_name.id GROUP BY user_id) 其他 在Navicat中，Ctrl+Q是创建一个查询界面 MySQL底层实现是从右往左进行解析执行，因此把]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 MySQL5.7免安装版安装教程]]></title>
    <url>%2F2019%2F02%2F19%2FWindows10-MySQL5-7%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[首先是下载 最近发现官网上下载版本直接跳到8.0了，下载的时候一定要注意找之前的版本 打开mysql的官网mysql下载地址 找到顶部的DOWNLOADS ，如果地址没换的话，应该是下面这个地址下载地址 选择社区版本（Community），然后选择左侧的菜单中的MySQL Community Server 滑动滚轮，向下，一直到选择系统和下载版本 选择完之后选择列表中展示的（ZIP Archive）版本的进行下载，我下载的版本是5.7.20，下载完成成解压 添加环境变量 首先是添加MYSQL_HOME，设置的VALUE值是MYSQL的解压目录，我是解压在了D:\Program Files\mysql，所以对应的MYSQL_HOME就是这个值 设置PATH在PATH的最后添加%MYSQL_HOME%\bin; 配置文件 在mysql文件夹下，新建一个my.ini的文件此处需要注意：保存文件的编码集一定是ANSI，这个地方不要用记事本编辑，记事本默认是UTF-8，因为他是个坑，用专业的Notepad++ 或者UE进行编辑，具体my.ini的内容如下,内容解释下面的文件中都已经有了，就不再废话了，另外这个地方先开启skip-grant-tables是为了给root修改密码123456789[mysqld]basedir=D:\Program Files\mysqldatadir=D:\Program Files\mysql\data\port=3306skip-grant-tables#basedir表示mysql安装路径#datadir表示mysql数据文件存储路径#port表示mysql端口#skip-grant-tables表示忽略密码 安装 然后以管理员的权限进入cmd窗口界面，管理员权限进入方式：搜索cmd，右键在对应程序上，以管理员的权限启动 切换到mysql/bin文件夹下，也就是你解压的出来的文件夹的bin目录下，怎么切换我就不讲了 各种cd，然后执行命令，命令如下，执行完成后会显示“Service successfully installed” 1mysqld --install 生成data数据。不要着急于启动，先生成mysql的data数据，上面的my.cnf中设置了datadir=D:\Program Files\mysql\data\，因此我们需要先手动在mysql文件夹下面新建一个data文件夹，否则接下来的步骤会报错 1mysqld --initialize-insecure --user=mysql; 然后看下data目录下会生成一堆文件夹和文件 启动 在刚刚的cmd窗口中直接输入 net start mysql，然后会提示启动成功1net start mysql 登录 输入命令mysql -u root -p，这个时候是没有密码的，所以输入完之后直接回车，就可以进入mysql中了1mysql -u root -p 更新密码 输入以下命令修改密码，当然密码需要修改成你自己想要修改的内容,再就是刷新下quanxian 1update mysql.user set authentication_string=password(&apos;123456789&apos;) where user=&apos;root&apos; and Host = &apos;localhost&apos;; 1flush privileges; 恢复my.ini配置文件 现在修改完密码了，需要删除或注释my.ini文件中的skip-grant-tables选项，一定注意不要用记事本，那是个坑 停止和启动mysql服务12net start mysqlnet stop mysql 常规错误提示及可能遇到的问题 出现这个问题的原因一般是my.ini文件的编码格式出现问题了，保存的时候一定要记得是ANSI mysqld: [ERROR] Found option without preceding group in config file D:\Program Files\mysql\my.ini at line 1!mysqld: [ERROR] Fatal error in defaults handling. Program aborted! 如果你电脑的性能没啥问题的话，一般4-5S就能启动，像这种一直冒点的情况，可以在“计算机管理”界面查看Windows应用程序日志，翻一翻，MySQL相关错误 D:\Program Files\mysql\bin&gt;net start mysqlMySQL 服务正在启动 ……………. sc delete mysql 服务的时候回提示服务正在启动，不能删除，或者已经标记为删除的情况，但是服务就是删不掉的情况，这种情况下，第一确认你的服务是否已经停止（有时候 net stop mysql 不好使，可以直接在任务管理器里面，把mysql的进程结束掉） 第二、关闭你的services.msc界面 然后再执行sc 命令进行服务删除操作]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>免安装版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB资料]]></title>
    <url>%2F2019%2F02%2F19%2FMongoDB%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[MongoDB数据表基本操作http://www.cnblogs.com/libingql/archive/2011/06/09/2076440.html mongodb安全认证http://www.cnblogs.com/silentjesse/p/4676440.html mongodb Replica Sets +Sharding高可用集群搭建(含认证)http://www.cnblogs.com/ylh1223/archive/2013/04/23/3037301.html MongoDB的授权和权限http://blog.csdn.net/lixiaoweihubin/article/details/8620552 mongodb key文件报 permissions on xxx are too openhttps://blog.csdn.net/lixiaoweihubin/article/details/8620552 mongodb 添加用户及权限设置详解http://www.jb51.net/article/52485.htm mongodb-常见问题http://www.cnblogs.com/cyhe/p/5526662.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat性能优化]]></title>
    <url>%2F2019%2F02%2F19%2FTomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文转自闲谈Tomcat性能优化,tomcat服务器优化 转不意味着Copy，而是对别人知识的汲取和吸收的同时加上自己的理解 Tomcat默认配置作为生产环境，尤其是内存和线程的配置，默认都是很低，容易成为性能的瓶颈，下面对Tomcat的内存、线程、IO三个方面的优化进行详解： Tomcat内存优化（内存调优的最直接方式）启动Tomcat的时候告诉JVM（java虚拟机）分配一块大内存 打开Linux服务器下bin文件夹下的catalina.sh文件，修改虚拟机配置 修改的主要内容包含如下：123# -Xms&lt;size&gt; JVM初始化堆的大小# -Xmx&lt;size&gt; JVM堆的最大值 实际参数大小根据服务器配置或者项目具体设置.JAVA_OPTS='-server -Xms512m -Xmx512m' 参数解析 -server:一定要作为第一个参数，在多个CPU时性能佳 -Xms:初始Heap大小，使用的最小内存,一般建议堆的最大值配置为可用内存的最大值的80% -Xmx:java heap最大值，使用的最大内存,一般建议堆的最大值配置为可用内存的最大值的80% -XX:PermSize:内存永久保留区域 -XX:MaxPermSize:内存最大永久保留区域 -Xmn:jvm最小内存* 服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小 123# 32G 内存配置示例：JAVA_OPTS="-server -Xms10g -Xmx10g -XX:PermSize=1g -XX:MaxPermSize=2g -Xshare:off -Xmn1024m" Tomcat线程优化server.xml文件中修改以下内容，从而优化线程12&lt;Connector port="80" protocol="HTTP/1.1" maxThreads="600" minSpareThreads="100" maxSpareThreads="500" acceptCount="700"connectionTimeout="20000" /&gt; maxThread:最大并发数，默认设置 200，一般建议在 500 ~ 800，根据硬件设施和业务来判断 minSpareThread:Tomcat 初始化时创建的线程数，默认设置 25 maxSpareThread:最多可以有多少个线程，一个超过这个数，则会关闭不再需要的线程 acceptCount:当同时连接的人数达maxThread时，还可以排队，排队大小为这个数，超过这个数就不进行处理 maxQueueSize，最大的等待队列数，超过则拒绝请求 Tomcat IO优化 同步阻塞IO（java BIO），服务器实现模式为一个连接一个线程，线程是宝贵资源，所以可以通过线程池机制改善。 Java NIO:分为同步非阻塞IO，异步IO与BIO最大的区别是可以通过一个线程处理多个connection（多路复用） 异步非阻塞IO（Java NIO2又叫AIO） BIO:适用于连接数目比较小且固定架构，这种方式对服务器资源要求比较高，而且局限于应用中，JDK1.4以前的唯一选择，但程序只管简单易理解 NIO:适用于连接数目比较多且连接比较短（轻操作）架构，比如聊天服务器，并且局限于应用中，编程比较复杂 AIO:连接数目比较多且连接比较长（重操作），比如相册服务器，充分调用OS参与并发操作，编程比较复杂，从JDK1.7开始支持 配置方法： 在server.xml中： 1234567&lt;Connector executor="tomcatThreadPool" port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol"connectionTimeout="20000" maxConnections="10000"redirectPort="8443" enableLookups="false" acceptCount="100" maxPostSize="10485760" compression="on" disableUploadTimeout="true"compressionMinSize="2048" acceptorThreadCount="2"compressableMimeType="text/html,text/xml,text/plain,text/css,text/javascript,application/javascript" URIEncoding="utf-8"/&gt; 参数解析 protocol：Tomcat 8 设置 nio2 更好：org.apache.coyote.http11.Http11Nio2Protocol（如果这个用不了，就用下面那个） protocol：Tomcat 6、7 设置 nio 更好：org.apache.coyote.http11.Http11NioProtocol acceptCount，指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认设置 100 maxPostSize，以 FORM URL 参数方式的 POST 提交方式，限制提交最大的大小，默认是 2097152(2兆)，它使用的单位是字节。10485760 为 10M。如果要禁用限制，则可以设置为 -1。 acceptorThreadCount，用于接收连接的线程的数量，默认值是1。一般这个指需要改动的时候是因为该服务器是一个多核CPU，如果是多核 CPU 一般配置为 2. APRAPR是从操作系统级别来解决异步IO问题，大幅度提高性能，具体可见链接地址APR(Apache Portable Runtime)是一个高可移植库,它是Apache HTTP Server 2.x的核心.能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器.在局域网环境测，就算是400个并发，也是一瞬间就处理/传输完毕，但是在真实的Internet环境下，页面处理时间只占0.1%都不到，绝大部分时间都用来页面传输.如果不用APR，一个线程同一时间只能处理一个用户，势必会造成阻塞。所以生产环境下用apr是非常必要的. 安装Apache Tomcat Native Library，直接启动就支持apr(http://tomcat.apache.org/native-doc/)它本身是基于APR的. 具体安装方法可以参考其他博客和文章. 排除代码问题Tomcat优化到这个层次,可以应对大部分性能需求]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>中间件</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5中Tomcat部署及单机多Tomcat部署]]></title>
    <url>%2F2019%2F02%2F19%2FCentOS6-5%E4%B8%ADTomcat%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%8D%95%E6%9C%BA%E5%A4%9ATomcat%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Tomcat下载Tomcat的下载地址，根据自己的需求进行版本的下载12cd /usr/localwget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.73/bin/apache-tomcat-7.0.73.tar.gz Tomcat安装（Linux）解压tomcat并进行目录重命名12345tar -zxvf apache-tomcat-7.0.73.tar.gz # 解压mv apache-tomcat-7.0.73 tomcat1 # 重命名为tomcat1tar -zxvf apache-tomcat-7.0.73.tar.gz # 解压mv apache-tomcat-7.0.73 tomcat2 # 重命名为tomcat2rm -rf apache-tomcat-7.0.73.tar.gz # 删除安装包 修改配置文件修改两个tomcat的配置文件server.xml，修改的内容如下图所示 tomcat1 tomcat2 验证修改完成，启动Tomcat，访问对应的端口号进行验证]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>多节点</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+Tomcat 负载均衡配置]]></title>
    <url>%2F2019%2F02%2F19%2FNginx-Tomcat-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nginx 安装依赖安装首先由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，这些依赖库主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel 所以执行如下命令安装1234$ yum install gcc-c++ $ yum install pcre pcre-devel $ yum install zlib zlib-devel $ yum install openssl openssl--devel 安装步骤验证是否安装过ngnix如果已经安装过，需要进行卸载 yum remove nginx$ find -name nginx 下载Ngnix$ wget http://nginx.org/download/nginx-1.7.4.tar.gz 解压压缩包$ tar -zxvf nginx-1.7.4.tar.gz 安装进入解压的文件夹，接下来安装，使用–prefix参数指定nginx安装的目录,make、make install安装123$ ./configure $默认安装在/usr/local/nginx $ make $ make install 查看安装位置$ whereis nginx 负载均衡配置修改nginx的配置文件修改/usr/local/nginx/conf文件夹下面的nginx.conf文件12cd /usr/local/nginx/confvim nginx.conf 定义一个mysite，然后定义这个mysite对应需要负载均衡的服务器12345upstream mysite&#123;server 192.168.1.148:8080;server 192.168.1.148:8081;ip_hash;&#125; ip_hash 是为了保证访问的时候只对一个服务器，使session能够保持住 启动、停止nginx进入nginx的安装文件夹下123456cd /usr/local/nginx/sbin./nginx //启动./nginx -s stop //停止./nginx -s reload //重新加载./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>负载均衡</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat指定JDK启动]]></title>
    <url>%2F2019%2F02%2F19%2FTomcat%E6%8C%87%E5%AE%9AJDK%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[项目上出现一个服务器上多个版本JDK的问题，而且目前要用的JDK和默认JDK版本不一致的时候，就需要在Tomcat启动的时候，设置对应的JDK版本，特别是在Linux服务器上 配置Windows服务器找到Tomcat的目录下的bin文件夹，打开bin文件夹下面的setclasspath.bat文件，在文件顶部添加如下代码： 12set JAVA_HOME=D:\Program Files\Java\jdk7\jdk1.7.0_51set JRE_HOME=D:\Program Files\Java\jdk7\jre7 Linux服务器找到Tomcat目录下的bin文件夹，打开bin文件夹下面的setclasspath.sh文件，在文件顶部添加如下代码： 一定要注意Linux是Export而Windows是set12345678910# -----------------------------------------------------------------------------# Set JAVA_HOME or JRE_HOME if not already set, ensure any provided settings# are valid and consistent with the selected start-up options and set up the# endorsed directory.# -----------------------------------------------------------------------------# Make sure prerequisite environment variables are setexport JAVA_HOME=/usr/local/java/jdk1.8.0_191export JRE_HOME=/usr/local/java/jdk1.8.0_191/jre... 校验在tomcat启动的时候，会报Tomcat JRE信息，可以看下JRE信息是否和配置的位置一致，如果位置一致，说明没有问题 原理Tomcat启动的时候会执行start.sh(Linux)或者start.bat(Win)，启动的时候会分别调用catalina.sh(Linux)，然后调用setclasspath.sh(Linux)文件，因此在setclasspath文件中设置JAVA_HOME和JRE之后，就可以指向特定的JDK 扩展基于上面的原理，也可以用下面的方法设置Tomcat指定的JDK 修改tomcat/bin/catalina.sh，增加 export JAVA_HOME=…]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>JDK</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动失败问题解决]]></title>
    <url>%2F2019%2F02%2F19%2FTomcat%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[未安装JDK或JDK配置错误 新建JAVA_HOME 他的值为JDK的安装绝对路径 例如：C:\Program Files\Java\jdk1.5.0_18\ 新建Classpath（如果已经有的话，直接点击编辑，用分号隔开），他的值为 .;%JAVA_HOME%\lib 新建Path，如果已经有了，可以直接加分号隔开他的值为：%JAVA_HOME%\bin 已安装，启动bat闪退 在startup.bat文件末尾添加pause，启动tomcat，查看输出日志 如果是JDK的问题，可在start.bat顶部添加如下代码Windows: 12set JAVA_HOME=D:\Program Files\Java\jdk7\jdk1.7.0_51set JRE_HOME=D:\Program Files\Java\jdk7\jre7 Linux 12export JAVA_HOME=/home/jdk/Java\jdk7\jdk1.7.0_51export JRE_HOME=/home/jdk/Java\jdk7\jre7]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>中间件</tag>
        <tag>启动失败</tag>
        <tag>闪退</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx开启Gzip压缩大幅提高页面加载速度]]></title>
    <url>%2F2019%2F02%2F18%2FNginx%E5%BC%80%E5%90%AFGzip%E5%8E%8B%E7%BC%A9%E5%A4%A7%E5%B9%85%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[刚刚给博客加了一个500px相册插件，lightbox引入了很多js文件和css文件，页面一下子看起来非常臃肿，所以还是把Gzip打开了。环境：Debian 6 Vim打开Nginx配置文件vim /usr/local/nginx/conf/nginx.conf 找到如下一段，进行修改 12345678gzip on;gzip_min_length 1k;gzip_buffers 4 16k;#gzip_http_version 1.0;gzip_comp_level 2;gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;gzip_vary off;gzip_disable "MSIE [1-6]\."; 解释一下第1行：开启Gzip第2行：不压缩临界值，大于1K的才压缩，一般不用改第3行：buffer，就是，嗯，算了不解释了，不用改第4行：用了反向代理的话，末端通信是HTTP/1.0，有需求的应该也不用看我这科普文了；有这句的话注释了就行了，默认是HTTP/1.1第5行：压缩级别，1-10，数字越大压缩的越好，时间也越长，看心情随便改吧第6行：进行压缩的文件类型，缺啥补啥就行了，JavaScript有两种写法，最好都写上吧，总有人抱怨js文件没有压缩，其实多写一种格式就行了第7行：跟Squid等缓存服务有关，on的话会在Header里增加”Vary: Accept-Encoding”，我不需要这玩意，自己对照情况看着办吧第8行：IE6对Gzip不怎么友好，不给它Gzip了 :wq保存退出，重新加载Nginx/usr/local/nginx/sbin/nginx -s reload 用curl测试Gzip是否成功开启 123456789curl -I -H "Accept-Encoding: gzip, deflate" "http://www.slyar.com/blog/"HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:13:09 GMTContent-Type: text/html; charset=UTF-8Connection: keep-aliveX-Powered-By: PHP/5.2.17p1X-Pingback: http://www.slyar.com/blog/xmlrpc.phpContent-Encoding: gzip 页面成功压缩12345678910curl -I -H "Accept-Encoding: gzip, deflate" "http://www.slyar.com/blog/wp-content/plugins/photonic/include/css/photonic.css"HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:21:25 GMTContent-Type: text/cssLast-Modified: Sun, 26 Aug 2012 15:17:07 GMTConnection: keep-aliveExpires: Mon, 27 Aug 2012 06:21:25 GMTCache-Control: max-age=43200Content-Encoding: gzip css文件成功压缩12345678910curl -I -H &quot;Accept-Encoding: gzip, deflate&quot; &quot;http://www.slyar.com/blog/wp-includes/js/jquery/jquery.js&quot;HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:21:38 GMTContent-Type: application/x-javascriptLast-Modified: Thu, 12 Jul 2012 17:42:45 GMTConnection: keep-aliveExpires: Mon, 27 Aug 2012 06:21:38 GMTCache-Control: max-age=43200Content-Encoding: gzip js文件成功压缩12345678910curl -I -H &quot;Accept-Encoding: gzip, deflate&quot; &quot;http://www.slyar.com/blog/wp-content/uploads/2012/08/2012-08-23_203542.png&quot;HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:22:45 GMTContent-Type: image/pngLast-Modified: Thu, 23 Aug 2012 13:50:53 GMTConnection: keep-aliveExpires: Tue, 25 Sep 2012 18:22:45 GMTCache-Control: max-age=2592000Content-Encoding: gzip 图片成功压缩1234567891011curl -I -H &quot;Accept-Encoding: gzip, deflate&quot; &quot;http://www.slyar.com/blog/wp-content/plugins/wp-multicollinks/wp-multicollinks.css&quot;HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:23:27 GMTContent-Type: text/cssContent-Length: 180Last-Modified: Sat, 02 May 2009 08:46:15 GMTConnection: keep-aliveExpires: Mon, 27 Aug 2012 06:23:27 GMTCache-Control: max-age=43200Accept-Ranges: bytes 最后来个不到1K的文件，由于我的阈值是1K，所以没压缩 本文引自http://www.veryhuo.com/a/view/51706.html]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>图片压缩</tag>
        <tag>Gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器端图片压缩之Nginx+lua_nginx module+GraphicsMagick]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B9%8BNginx-lua-nginx-module-GraphicsMagick%2F</url>
    <content type="text"><![CDATA[在开发电子商务网站时，同一个图片需要不同尺寸的缩略图片，一般有两种策略生成缩略图，一种在上传图片时，生成需要的缩略图，另一种是请求指定尺寸的图片时生存缩略图片，第一种方式有一定限制，就是需要提前知道所有尺寸的图片，如果前端ui设计改变了图片大小，需要重新生成。而第二种方式更加灵活，这里采用第二种方 ，只是淘宝使用ImageMagick）。 这里主要借助lua_nginx module调用GraphicsMagick命令生存生存缩略图片，缩略图片的尺寸包含在请求图片名称中，例如：xxxxx.jpg.80x80.jpg返回的就是xxx.jpg的80x80尺寸的图片大小。nginx配置如下： 上传图片名称使用32位随机字符替换掉，图片存放目录为图片名称前六个字母，每两个一组，构造三层目录结构存放，这样可以均匀存放图片在不同目录。避免目录存放文件数量限制。为了避免随意生成不同尺寸的缩略图，这里做了限制，在image_sizes中定义了需要的缩略图尺寸。 初次版本 12345678910111213141516171819202122232425262728293031323334353637383940414243location /testImg/ &#123; rewrite_by_lua ' local image_root = "/home/tomcat/eisp-files"; function file_notexists(name) local f=io.open(name,"r") if f~=nil then io.close(f) return false else return true end end local uri = ngx.re.sub(ngx.var.uri, "/testImg/([0-9a-zA-Z]+)/([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]+).([0-9a-zA-Z]+)", "/images/$1/$2/$3/$4/$2$3$4$5.$6", "o"); local index = string.find(uri, "([0-9]+)x([0-9]+)"); local originalUri = string.sub(uri, 0, index-2); local area = string.sub(uri, index); index = string.find(area, "([.])"); area = string.sub(area, 0, index-1); if file_notexists(image_root .. uri) then local image_sizes = &#123;"80x80", "800x600", "40x40"&#125;; function table.contains(table, element) for _, value in pairs(table) do if value == element then return true end end return false end if table.contains(image_sizes, area) then local command = "gm convert " .. image_root .. originalUri .. " -thumbnail " .. area .. " -background gray -gravity center -extent " .. area .. " " .. image_root .. uri; os.execute(command); ngx.req.set_uri(uri, true); else ngx.exit(404); end; else ngx.req.set_uri(uri, true); end; '; &#125; location /images/ &#123; alias /home/tomcat/eisp-files/images/; expires 7d; &#125; 最后一次修改版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849location /images/ &#123; set $image_root /home/nds/nds-files; if ($uri ~* "/images/([0-9a-zA-Z]+)/([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]+).(.*)") &#123; set $filePath "$image_root/$1/$2/$3/$4/$2$3$4$5.$6"; set $reqPath "/$1/$2/$3/$4/$2$3$4$5.$6"; &#125; set $file "$image_root$reqPath"; if (-f $file) &#123; rewrite "/images/(.+)" /innerImages$reqPath last; &#125; if (!-f $file) &#123; rewrite_by_lua ' local index = string.find(ngx.var.filePath, "([0-9]+)x([0-9]+)"); local originalUri = string.sub(ngx.var.filePath, 0, index-2); local area = string.sub(ngx.var.filePath, index); index = string.find(area, "([.])"); area = string.sub(area, 0, index-1); local image_sizes = &#123;"155x155", "400x400","104x104", "50x50", "40x40", "56x56", "172x172","800x600"&#125;; function table.contains(table, element) for _, value in pairs(table) do if value == element then return true end end return false end if table.contains(image_sizes, area) then local command = "gm convert " .. originalUri .. " -thumbnail " .. area .. " -background white -gravity center -extent " .. area .. " " .. ngx.var.file; os.execute(command); ngx.req.set_uri("/innerImages" .. ngx.var.reqPath, true); else ngx.exit(404); end; '; &#125; &#125; location /innerImages/ &#123; alias /home/nds/nds-files/; expires max; tcp_nodelay off; tcp_nopush on; &#125; 本文引自http://www.iteye.com/topic/1125126]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Nginx</tag>
        <tag>图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开机启动服务或者Activity]]></title>
    <url>%2F2019%2F02%2F18%2FAndroid%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E6%88%96%E8%80%85Activity%2F</url>
    <content type="text"><![CDATA[有些时候，应用需要在开机时就自动运行，例如某个自动从网上更新内容的后台 service。怎样实现开机自动运行的应用？在撰写本文时，联想到高焕堂先生以“Don’’t call me, I’’ll call you back!”总结Android框架，真是说到点子上了。理解这句话的含义，许多有关Android平台上实现某种功能的问题，都能迎刃而解。 使用场景：手机开机后，自动运行程序，在屏幕上显示”Hello. I started!”字样。 背景知识：当Android启动时，会发出一个系统广播，内容为 ACTION_BOOT_COMPLETED，它的字符串常量表示为android.intent.action.BOOT_COMPLETED。只要在程序中“捕捉”到这个消息，再启动之即可。记住，Android框架说：Don’’t call me, I’’ll call you back。我们要做的是做好接收这个消息的准备，而实现的手段就是实现一个BroadcastReceiver。 代码解析： 1、界面Activity：SayHello.java123456789101112131415package com.ghstudio.BootStartDemo;import android.app.Activity;import android.os.Bundle;import android.widget.TextView;public class SayHello extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Hello. I started!"); setContentView(tv); &#125;&#125; 这段代码很简单，当Activity启动时，创建一个TextView，用它显示”Hello. I started!”字样。 2、接收广播消息：BootBroadcastReceiver.java1234567891011121314151617package com.ghstudio.BootStartDemo;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;public class BootBroadcastReceiver extends BroadcastReceiver &#123;static final String ACTION = "android.intent.action.BOOT_COMPLETED"; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(ACTION))&#123; Intent sayHelloIntent=new Intent(context,SayHello.class); sayHelloIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(sayHelloIntent); &#125; &#125;&#125; 该类派生自BroadcastReceiver，覆载方法onReceive中，检测接收到的Intent是否符合BOOT_COMPLETED，如果符合，则启动SayHello那个Activity。 3、配置文件：AndroidManifest.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"package="com.ghstudio.BootStartDemo"android:versionCode="1"android:versionName="1.0"&gt;&lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt; &lt;activity android:name=".SayHello" android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;receiver android:name=".BootBroadcastReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt;&lt;uses-sdk android:minSdkVersion="3" /&gt;&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"&gt;&lt;/uses-permission&gt;&lt;/manifest&gt; 注意其中粗体字那一部分，该节点向系统注册了一个receiver，子节点intent-filter表示接收 android.intent.action.BOOT_COMPLETED消息。不要忘记配置 android.permission.RECEIVE_BOOT_COMPLETED权限。 完成后，编译出apk包，安装到模拟器或手机中。关机，重新开机。]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>服务</tag>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 长摁连续触发事件，类似于Js里面的Interval]]></title>
    <url>%2F2019%2F02%2F18%2FAndroid-%E9%95%BF%E6%91%81%E8%BF%9E%E7%BB%AD%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8EJs%E9%87%8C%E9%9D%A2%E7%9A%84Interval%2F</url>
    <content type="text"><![CDATA[大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。 实现 首先,让对应的View设置一个OnTouchListener，在手指按下时触发不停的发送消息,手指抬起时停止发送 1234567891011subtractButton.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; updateAddOrSubtract(v.getId()); //手指按下时触发不停的发送消息 &#125;else if(event.getAction() == MotionEvent.ACTION_UP)&#123; stopAddOrSubtract(); //手指抬起时停止发送 &#125; return true; &#125; &#125;); 发送消息与终止方法：先定义一个ScheduledExecutorService对象，然后调用scheduleWithFixedDelay()方法 12345678910111213141516171819202122private ScheduledExecutorService scheduledExecutor;private void updateAddOrSubtract(int viewId) &#123; stop();//如果同时摁两个按钮或两个以上，会出现定时器不能停止的问题，因此在这里加上这个，把之前的定时器先关掉 final int vid = viewId; scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); scheduledExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.what = vid; handler.sendMessage(msg); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); //每间隔100ms发送Message &#125; private void stopAddOrSubtract() &#123; if (scheduledExecutor != null) &#123; scheduledExecutor.shutdownNow(); scheduledExecutor = null; &#125; &#125; 用来处理Touch事件的Handler定义如下： 1234567891011121314private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; int viewId = msg.what; switch (viewId)&#123; case R.id.custom_number_picker_subtract_button: setValue(value - rangeability); //减小操作 break; case R.id.custom_number_picker_add_button: setValue(value + rangeability); //增大操作 break; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>连续触发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器内存、处理器、磁盘使用情况]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[本文转自命令查看Linux服务器内存、CPU、显卡使用情况 转不意味着Copy，而是对别人知识的汲取和吸收的同时加上自己的理解 内存使用情况 free -m命令 12345[root@itlb ~]# free -m total used free shared buffers cachedMem: 32078 31202 876 0 5 21952-/+ buffers/cache: 9244 22834Swap: 16111 86 16025 参数解析 命令中的-m指的是按照MB进行数据统计 Mem行 total:内存总数 used:内存已使用数 free:内存空闲数 shared:目前该参数已经废弃不适用，为0 buffers:缓存内存数（Buffer） cached:缓存内舒数（Page） -/+ buffers/cache: （-buffers/cache）: 真正使用的内存数，指的是第一部分的 used - buffers - cached （+buffers/cache）: 可用的内存数，指的是第一部分的 free + buffers + cached Swap:交换区的内存使用情况 注：虽然看着free的剩余比较小，但是这里有一定的混淆，真正的free是free+buffers+cached 处理器使用情况 top命令 12345678910111213141516171819[root@itlb ~]# toptop - 10:21:44 up 833 days, 18:27, 1 user, load average: 1.45, 1.36, 1.19Tasks: 509 total, 2 running, 507 sleeping, 0 stopped, 0 zombieCpu(s): 0.0%us, 1.2%sy, 3.1%ni, 95.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 32848860k total, 31990756k used, 858104k free, 26208k buffersSwap: 16498680k total, 88276k used, 16410404k free, 22492248k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND24827 root 30 10 391m 97m 6940 S 106.1 0.3 0:02.40 sosreport25310 root 20 0 15300 1588 944 R 0.7 0.0 0:00.06 top 100 root 20 0 0 0 0 S 0.3 0.0 142:18.26 events/1 118 root 20 0 0 0 0 S 0.3 0.0 25:50.62 events/19 2193 root 20 0 0 0 0 S 0.3 0.0 125:46.21 kondemand/0 2199 root 20 0 0 0 0 S 0.3 0.0 213:10.72 kondemand/6 9996 root 20 0 13.6g 786m 10m S 0.3 2.5 570:23.13 java15398 oracle 20 0 6355m 23m 20m S 0.3 0.1 173:01.00 oracle25444 root 20 0 7630m 930m 31m S 0.3 2.9 128:53.80 java25775 root 30 10 77124 6324 4512 R 0.3 0.0 0:00.01 rpm28567 root 20 0 17.2g 1.8g 14m S 0.3 5.8 24:48.19 java 参数解析 Tasks total:总共目前运行的任务数量 running:目前正在运行的任务数量 zombie:僵尸进程数量-Cpu(s) us:CPU已经使用的良 id:CPU空闲使用率 注：下半部分数据中出现%CPU列中出现超过100%的情况，说明是多核服务器，而且该进程使用多核 磁盘使用情况 fdisk -l命令 1234567891011121314151617181920212223242526272829303132333435363738[root@itlb ~]# fdisk -lWARNING: GPT (GUID Partition Table) detected on '/dev/sda'! The util fdisk doesn't support GPT. Use GNU Parted.Disk /dev/sda: 299.0 GB, 298999349248 bytes255 heads, 63 sectors/track, 36351 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000 Device Boot Start End Blocks Id System/dev/sda1 1 36352 291991551+ ee GPTPartition 1 does not start on physical sector boundary.Disk /dev/mapper/vg_itlb-lv_root: 53.7 GB, 53687091200 bytes255 heads, 63 sectors/track, 6527 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000Disk /dev/mapper/vg_itlb-lv_swap: 16.9 GB, 16894656512 bytes255 heads, 63 sectors/track, 2053 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000Disk /dev/mapper/vg_itlb-lv_home: 227.7 GB, 227679404032 bytes255 heads, 63 sectors/track, 27680 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000 参数解析 第一部分：Disk /dev/sda: 299.0 GB, 298999349248 bytes说明硬盘的总空间为299Gb 第二部分：Disk /dev/mapper/vg_itlb-lv_root: 53.7 GB, 53687091200 bytes对应分区的大小 ··· du -sh 命令 123[root@itlb ~]# cd /home/[root@itlb home]# du -sh121G . 该命令是指当前文件夹下已经使用了多少空间 df -h 命令 1234567[root@itlb home]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/vg_itlb-lv_root 50G 24G 24G 51% /tmpfs 16G 1.1M 16G 1% /dev/shm/dev/sda2 485M 39M 421M 9% /boot/dev/sda1 200M 260K 200M 1% /boot/efi/dev/mapper/vg_itlb-lv_home 209G 121G 78G 61% /home 是指各个挂载点的硬盘空间及使用情况 du -cks * | sort -rn | head -n 10命令 该命令是查看 当前目录 下占用空间最多的文件或者文件夹，取前10个 1234567891011[root@itlb home]# du -cks * | sort -rn | head -n 10126247676 总用量88805524 oracle15347828 yzh4867880 itl4199764 xyd3921468 tomcatservers3389964 admin2229484 xyddev1419676 tomcat-mc-platform881904 mysqlvbs du -h --max-depth=2 / 这个经常用查看所有的文件占用大小]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>应用情况</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux公钥进行远程登录]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E5%85%AC%E9%92%A5%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[之前听领导说使用公钥远程服务器的方式进行远程，感觉挺神秘，今天实践了一下，确实挺方便，先讲几点从中的感悟 拿到一个服务器的时候，如果想看下是否有被别人使用了公钥登录方式进行登录的方法看下文件/etc/ssh/sshd_config中的PubkeyAuthentication是否为yes状态，如果是，有可能是被别人能够通过公钥登录，然后再看下AuthorizedKeysFile看后面是否有公钥文件，如果有，那就是公钥的文件目录了 12345# 查看/etc/ssh/sshd_config[root@itlb ssh]# cat /etc/ssh/sshd_config# 文件比较长，需要详细的看下里面的内容，主要关注的是以下几个点PubkeyAuthentication yesAuthorizedKeysFile /root/.ssh/id_rsa.pub 设置服务器只能通过公钥进行登录，不能通过账号和密码登录的方法设置/etc/ssh/sshd_config中的PasswordAuthentication为no 1PasswordAuthentication no # 不允许密码验证登录 设置通过公钥登录服务器步骤1. 首先检查下服务器的SSH远程登录的服务状态1234567891011[root@node1 ~]$service sshd status # 查看sshd服务运行状态,如果没有输出`正在运行`，说明存在问题，需要安装# 安装、启动、永久生效[root@node1 ~]$ yum install -y openssh-server # 安装openssh服务端[root@node1 ~]$ yum install -y openssh-clients #安装openssh客户端，可以不安装[root@node1 ~]$ service sshd start # 临时开启sshd服务[root@node1 ~]$ chkconfig sshd on # 永久开启sshd服务，服务器重启也生效# 再次检查sshd的状态[root@node1 ~]$service sshd status # 查看sshd服务运行状态，如果输出下面内容，说明运行正常openssh-daemon (pid 1384) 正在运行... # 显示正在运行 2. 生成密钥对123456789101112131415161718192021222324252627[root@node1 ~]$ ssh-keygen # 生成ssh密钥对Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): # 回车(如果默认要保存到当前路径下，就直接回车，如果需要修改，输入对应的路径)Enter passphrase (empty for no passphrase): #密码（如果远程的使用公钥的时候设置还需要密码的时候，在这里输入密码）Enter same passphrase again: # 重复上面的密码Your identification has been saved in /root/.ssh/id_rsa. # 提示你的密钥保存在这个路径下了Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:fd:72:10:50:a6:7d:83:c7:93:d2:26:3d:12:0e:38:2f root@node1The keys randomart image is:+--[ RSA 2048]----+| .o.+ || o B * . || o. O % || E .. O + || .S o || o || . o || o || |+-----------------+[root@node1 ~]$ cd root/.ssh/[root@node1 .ssh]$ ll # 查看密钥/公钥对信息，权限都为600总用量 8-rw-------. 1 root root 1675 5月 21 14:26 id_rsa # 私钥-rw-------. 1 root root 392 5月 21 14:26 id_rsa.pub # 公钥[root@node1 .ssh]$ 3. 修改sshd配置文件这个地方文件内容比较长，一定要耐心找12345[root@node1 ~]$ vim /etc/ssh/sshd_configPasswordAuthentication no # 不允许密码验证登录PubkeyAuthentication yes # 允许公钥验证登录AuthorizedKeysFile .ssh/id_rsa.pub # 指定公钥文件路径 4. 将公私钥导出到本地这个步骤就不多说了，用各种ftp软件导出到本地即可 5. 重启sshd服务（重要）12[root@node1 .ssh]$ service sshd reload重新载入 sshd： [确定] 6. 使用Xshell远程]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>公私钥</tag>
        <tag>远程登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7防火墙端口号相关]]></title>
    <url>%2F2019%2F02%2F18%2FCentOS7%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[12345678# firewall-cmd --list-all-zones #查看所有的zone信息# firewall-cmd --get-default-zone #查看默认zone是哪一个# firewall-cmd --zone=internal --change-zone=p3p1 #临时修改接口p3p1所属的zone为internal# firewall-cmd --add-service=http #暂时开放http# firewall-cmd --permanent --add-service=http #永久开放http# firewall-cmd --zone=public --add-port=80/tcp --permanent #在public中永久开放80端口# firewall-cmd --permanent --zone=public --remove-service=ssh #从public zone中移除服务# firewall-cmd --reload #重新加载配置]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>服务器</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx开机启动（添加系统服务）]]></title>
    <url>%2F2019%2F02%2F18%2Fnginx%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows添加开机启动，很简单，但是Linux呢，这两天学习了一下，通过添加/etc/rc.local文件启动，但是据说这个方法很快就要被废掉了，因此又研究了一下添加系统服务，做成开机启动，这种启动方式是可以在开机之后不登录，就能启动服务的，好用！！ 编辑service文件（文件存储在/lib/systemd/system/xxxx.service） 1vim /lib/systemd/system/nginx.service 将一下内容拷贝进nginx.service文件中 12345678910111213[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target 说明： Description:描述服务 After:描述服务类别 [Service]服务运行参数的设置 Type=forking是后台运行的形式 ExecStart为服务的具体运行命令 ExecReload为重启命令 ExecStop为停止命令 PrivateTmp=True表示给服务分配独立的临时空间 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3保存退出。 设置开机启动systemctl enable nginx.service 其他启动指令启动nginx服务：systemctl start nginx.service设置开机自启动：systemctl enable nginx.service停止开机自启动：systemctl disable nginx.service查看服务当前状态：systemctl status nginx.service重新启动服务：systemctl restart nginx.service查看所有已启动的服务：systemctl list-units --type=service]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>开机启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7卸载默认openjdk并安装新的JDK]]></title>
    <url>%2F2019%2F02%2F18%2FCentOS7%E5%8D%B8%E8%BD%BD%E9%BB%98%E8%AE%A4openjdk%E5%B9%B6%E5%AE%89%E8%A3%85%E6%96%B0%E7%9A%84JDK%2F</url>
    <content type="text"><![CDATA[通常CentOS会安装OpenJDK，因为这是JDK开源的分支，也就是后期不会收费的（目前Oracle受够Java之后，应该是准备进行收费的），但是项目中要使用的是官方的JDK，因此需要进行替换，所以需要进行如下的操作 首先第一步是查询是否安装了openjdk12java -versionrpm -qa | grep java或者rpm -qa | grep jdk 执行卸载命令 123yum -y remove java 红色框中的内容或者rpm -e --nodeps 红色框中的内容 安装jdkwget 下载地址从jdk官网下载jdk，对应的版本是http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz?AuthParam=1484402679_fcd52afad2d006c2f4d31c50b4e7b6b8 下载完成后进行解压操作，并移动到/usr/local12tar -zxvf 下载下来的tar.gz 的安装包mv jdk1.8.0_111/ /usr/local/ 配置环境变量编辑/etc/profile文件，在最后添加如下内容,然后保存123456vim /etc/profileexport JAVA_HOME=/usr/local/jdk1.8.0_111export JRE_HOME=/usr/local/jdk1.8.0_111/jreexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JRE_HOME/lib 执行编译，使配置文件生效1234. /etc/profile或者切换到etc文件夹下面执行./profile]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>JDK</tag>
        <tag>安装JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat开机启动（添加系统服务）]]></title>
    <url>%2F2019%2F02%2F18%2FTomcat%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[tomcat 需要增加一个pid文件在tomca/bin 目录下面，增加 setenv.sh 配置，catalina.sh启动的时候会调用，同时配置java内存参数 1234#add tomcat pidCATALINA_PID="$CATALINA_BASE/tomcat.pid"#add java optsJAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m" 增加tomcat.service 123456789101112[Unit]Description=tomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/tomcat/apache-tomcat-8.5.8/tomcat.pidExecStart=/usr/local/tomcat/apache-tomcat-8.5.8/bin/startup.shExecStop=/bin/kill -s QUIT $MAINPIDExecReload=/bin/kill -s HUP $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.targe 使用tomcat.service 配置开机启动systemctl enable tomcat 启动tomcatsystemctl start tomcat 停止tomcatsystemctl stop tomcat 重启tomcatsystemctl restart tomcat注:因为配置pid，在启动的时候会再tomcat根目录生成tomcat.pid文件，停止之后删除，同时tomcat在启动时候，执行start不会启动两个tomcat，保证始终只有一个tomcat服务在运行。多个tomcat可以配置在多个目录下，互不影响]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>开机启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xshell远程内网的服务器慢，指令输入和操作时快时慢的问题]]></title>
    <url>%2F2019%2F02%2F18%2FXshell%E8%BF%9C%E7%A8%8B%E5%86%85%E7%BD%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%85%A2%EF%BC%8C%E6%8C%87%E4%BB%A4%E8%BE%93%E5%85%A5%E5%92%8C%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BF%AB%E6%97%B6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[登录Linux系统，打开终端，输入以下命令vi /etc/ssh/sshd_config 打开的文件中，拖动鼠标到最后一行，可能会出现下面两种情况 UsePAM yes UseDNS yes UsePAM yes在这里将UseDNS yes修改为UseDNS no，没有的则加上这一行，便可]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Xshell</tag>
        <tag>远程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7修改静态IP地址]]></title>
    <url>%2F2019%2F02%2F18%2FCentOS7%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[服务器一般是需要修改成静态的IP地址的，否则在非DHCP下，有可能会出现IP地址变动，远程不到服务器的情况，具体修改的方法如下 第一步是先看下自己服务器对应的正在使用的网卡地址，左面对应的是网络配置文件中配置的名字，后面会讲到[daniel@localhost ~]$ ifconfig 找到对应的网络配置文件# vim /etc/sysconfig/network-scripts/ifcfg-+上面那个第一红方框中的文件名 主要修改的内容如下 123456BOOTPROTO="static" #dhcp改为static ONBOOT="yes" #开机启用本配置 IPADDR=192.168.7.106 #静态IP GATEWAY=192.168.7.1 #默认网关 NETMASK=255.255.255.0 #子网掩码 DNS1=192.168.7.1 #DNS 配置 修改后的效果如下 重启网络服务#service network restart 查看改动后的效果，Centois 7 不再使用 ifconfig 而是用 ip 命令查看网络信息]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>服务器</tag>
        <tag>静态IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat中docBase的配置及在Tomcat和Idea中的配置方法]]></title>
    <url>%2F2019%2F02%2F18%2Ftomcat%E4%B8%ADdocBase%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%9D%9E%E9%A1%B9%E7%9B%AE%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%9B%BE%E7%89%87%E7%9A%84%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%9C%A8Tomcat%E5%92%8CIdea%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[tomcat中docBase配置的三种项目部署方式docBase是web应用的本地路径，path是访问tomcat服务的路径 直接将项目放在webapps下面，这是最简单而且很初级的部署方式 在tomcat安装目录下conf文件夹下的server.xml文件中，在&lt;host&gt;....&lt;/host&gt;之间，插入如下语句 1&lt;Context path="/hello" docBase="F:\eclipse3.2\workspace\hello\WebRoot" debug="0" privileged="true"&gt;&lt;/Context&gt; 在tomcat安装目录中的conf\Catalina\localhost目录下新建一个xml文件，名字随意，只要不重复，代码如下 1&lt;Context path="/hello" docBase="F:\eclipse3.2\workspace\hello\WebRoot" debug="0" privileged="true"&gt;&lt;/Context&gt; IDEA中配置的方法 点击下图中的Edit Configurations，弹出Run/Debug Configurations对话框 选择你的Tomcat中间件，点击中间件上的Deployment，并点击绿色的加号 选择External Source，打开选择路径界面，选择一个路径进行部署 点击Apply按钮，然后点击Ok就可以了 本文引自Tomcat中的docbase和path]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不安全的HTTP方法]]></title>
    <url>%2F2019%2F02%2F16%2F%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天尝试了下Tomcat之前的关于不安全HTTP方法漏洞的实践方法，确实可以通过PUT、DELETE完成文件的上传和删除操作（但是这个必须得保证tomcat中readonly属性必须设置为false，才能执行），因此在这进行了记录，并补充了补救的措施，具体的实践步骤和解决方案如下 基础知识 HTTP请求方法HTTP1.0定义了三种请求方法： GET、POST、HEADHTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 、CONNECT 序号 方法 描述 1 GET 请求指定页面信息，返回实体主体 2 HEAD 类似于GET，只是返回的信息中没有具体的内容，用户获取头部报文 3 POST 向指定资源提交数据处理请求（表单提交或者上传文件）。数据包含在请求体中。POST请求会导致新的资源的建立或者原有资源的修改 4 PUT 从客户端向服务端传送的数据取代指定的文档内容 5 DELETE 请求服务器删除指定的资源 6 CONNECT 预留给能够将连接改为管道方式的代理服务器 7 OPTIONS 允许客户端查看服务器的性能 8 TRACE 回显服务器收到的请求，主要用于测试和诊断 确认自己的漏洞入口是否开启使用curl执行命令curl -v -X OPTIONS your-website-url -I，如果输出结果中显示Allow中包含PUT、DELETE等，说明就存在漏洞 漏洞的应用 DELETE：能够删除服务器上面的文件信息，造成恶意攻击 PUT：通过PUT方法可以上传文件替换对应的服务器文件或者挂马文件，实现服务的攻击 OPTIONS：将会暴露服务器中间件的相关信息 漏洞测试实践 准备材料： 下载Tomcat7.0.xx，安装curl7.64.0 修改Tomcat配置文件信息 打开TOMCAT_HOME/conf/web.xml文件，在org.apache.catalina.servlets.DefaultServlet下添加readonly属性，添加完的效果如下所示1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 漏洞实践 通过PUT和DELETE上传和删除文件 修复方案 关闭除GET和POST之外的其他请求协议在项目为web.xml中，或者TOMCAT_HOME\conf\web.xml中添加如下代码，这里需要解释下：项目的XML文件，只能修复本项目的漏洞，tomcat的配置文件web.xml能够修复该Tomcat所有项目对应的漏洞 123456789101112&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;fortune&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;HEAD&lt;/http-method&gt; &lt;http-method&gt;OPTIONS&lt;/http-method&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt;&lt;/auth-constraint&gt;&lt;/security-constraint&gt; web.xml中修改或添加readonly属性的值为true 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt;&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;]]></content>
      <categories>
        <category>安全测评</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows curl安装及常规命令使用]]></title>
    <url>%2F2019%2F02%2F16%2Fwindows-curl%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[curl是什么curl是一个利用URL语法在命令行下工作的文件传输工具，它支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。curl还支持SSL认证、HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling 安装步骤下载Windows版本的curl 下载Win版curl的地址如下https://curl.haxx.se/windows/ 根据你自己的个人系统位数，下载对应的版本，我是X64的因此下载了下图中的红圈标注出来的版本 下载完成后解压，放到你想放置的位置，本次安装放在了D:\Program Files\curl（这里进行了解压文件的重命名，也可以不用重命名） 添加环境变量 我的电脑-&gt;右键“属性”-&gt;高级系统设置-&gt;环境变量在系统变量中点击新建按钮，如下图所示 弹出新建系统变量界面，在变量名中输入CURL_HOME，在变量值中输入D:\Program Files\curl\bin这个地方需要注意，替换成你自己的curl安装目录，并在最后添加\bin，具体如下图所示 修改系统变量中的Path，添加%CURL_HOME%，具体操作见下图 添加完成后，点击确定测试是否安装成功 打开CMD窗口，然后输入curl --help，看是否有反应，如果有如下输出，说明正常，如果没有，说明安装失败，根据具体的提示百度确认问题出在哪里123456789101112131415161718192021222324C:\Users\zp&gt;curl --helpUsage: curl [options...] &lt;url&gt; --abstract-unix-socket &lt;path&gt; Connect via abstract Unix domain socket --anyauth Pick any authentication method -a, --append Append to target file when uploading --basic Use HTTP Basic Authentication --cacert &lt;file&gt; CA certificate to verify peer against --capath &lt;dir&gt; CA directory to verify peer against -E, --cert &lt;certificate[:password]&gt; Client certificate file and password --cert-status Verify the status of the server certificate --cert-type &lt;type&gt; Certificate file type (DER/PEM/ENG) --ciphers &lt;list of ciphers&gt; SSL ciphers to use --compressed Request compressed response --compressed-ssh Enable SSH compression -K, --config &lt;file&gt; Read config from a file --connect-timeout &lt;seconds&gt; Maximum time allowed for connection --connect-to &lt;HOST1:PORT1:HOST2:PORT2&gt; Connect to host -C, --continue-at &lt;offset&gt; Resumed transfer offset -b, --cookie &lt;data&gt; Send cookies from string/file -c, --cookie-jar &lt;filename&gt; Write cookies to &lt;filename&gt; after operation --create-dirs Create necessary local directory hierarchy --crlf Convert LF to CRLF in upload --crlfile &lt;file&gt; Get a CRL list in PEM format from the given file...... 常用命令详细的使用方法见地址https://curl.haxx.se/docs/manpage.html语法：#curl [option] [url]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114-a/--append 上传文件时，附加到目标文件 -A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 - anyauth 可以使用“任何”身份验证方法 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 - basic 使用HTTP基本验证 -B/--use-ascii 使用ASCII /文本传输 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -d/--data &lt;data&gt; HTTP POST方式传送数据 --data-ascii &lt;data&gt; 以ascii的方式post数据 --data-binary &lt;data&gt; 以二进制的方式post数据 --negotiate 使用HTTP身份验证 --digest 使用数字身份验证 --disable-eprt 禁止使用EPRT或LPRT --disable-epsv 禁止使用EPSV -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 --egd-file &lt;file&gt; 为随机数据(SSL)设置EGD socket路径 --tcp-nodelay 使用TCP_NODELAY选项 -e/--referer 来源网址 -E/--cert &lt;cert[:passwd]&gt; 客户端证书文件和密码 (SSL) --cert-type &lt;type&gt; 证书文件类型 (DER/PEM/ENG) (SSL) --key &lt;key&gt; 私钥文件名 (SSL) --key-type &lt;type&gt; 私钥文件类型 (DER/PEM/ENG) (SSL) --pass &lt;pass&gt; 私钥密码 (SSL) --engine &lt;eng&gt; 加密引擎使用 (SSL). "--engine list" for list --cacert &lt;file&gt; CA证书 (SSL) --capath &lt;directory&gt; CA目录 (made using c_rehash) to verify peer against (SSL) --ciphers &lt;list&gt; SSL密码 --compressed 要求返回是压缩的形势 (using deflate or gzip) --connect-timeout &lt;seconds&gt; 设置最大请求时间 --create-dirs 建立本地目录的目录层次结构 --crlf 上传是把LF转变成CRLF -f/--fail 连接失败时不显示http错误 --ftp-create-dirs 如果远程目录不存在，创建远程目录 --ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 --ftp-pasv 使用 PASV/EPSV 代替端口 --ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 --ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输 --ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输 -F/--form &lt;name=content&gt; 模拟http表单提交数据 -form-string &lt;name=string&gt; 模拟http表单提交数据 -g/--globoff 禁用网址序列和范围使用&#123;&#125;和[] -G/--get 以get的方式来发送数据 -h/--help 帮助 -H/--header &lt;line&gt;自定义头信息传递给服务器 --ignore-content-length 忽略的HTTP头信息的长度 -i/--include 输出时包括protocol头信息 -I/--head 只显示文档信息 从文件中读取-j/--junk-session-cookies忽略会话Cookie - 界面&lt;interface&gt;指定网络接口/地址使用 - krb4 &lt;级别&gt;启用与指定的安全级别krb4 -j/--junk-session-cookies 读取文件进忽略session cookie --interface &lt;interface&gt; 使用指定网络接口/地址 --krb4 &lt;level&gt; 使用指定安全级别的krb4 -k/--insecure 允许不使用证书到SSL站点 -K/--config 指定的配置文件读取 -l/--list-only 列出ftp目录下的文件名称 --limit-rate &lt;rate&gt; 设置传输速度 --local-port&lt;NUM&gt; 强制使用本地端口号 -m/--max-time &lt;seconds&gt; 设置最大传输时间 --max-redirs &lt;num&gt; 设置最大读取的目录数 --max-filesize &lt;bytes&gt; 设置最大下载的文件总量 -M/--manual 显示全手动 -n/--netrc 从netrc文件中读取用户名和密码 --netrc-optional 使用 .netrc 或者 URL来覆盖-n --ntlm 使用 HTTP NTLM 身份验证 -N/--no-buffer 禁用缓冲输出 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -p/--proxytunnel 使用HTTP代理 --proxy-anyauth 选择任一代理身份验证方法 --proxy-basic 在代理上使用基本身份验证 --proxy-digest 在代理上使用数字身份验证 --proxy-ntlm 在代理上使用ntlm身份验证 -P/--ftp-port &lt;address&gt; 使用端口地址，而不是使用PASV -Q/--quote &lt;cmd&gt;文件传输前，发送命令到服务器 -r/--range &lt;range&gt;检索来自HTTP/1.1或FTP服务器字节范围 --range-file 读取（SSL）的随机文件 -R/--remote-time 在本地生成文件时，保留远程文件时间 --retry &lt;num&gt; 传输出现问题时，重试的次数 --retry-delay &lt;seconds&gt; 传输出现问题时，设置重试间隔时间 --retry-max-time &lt;seconds&gt; 传输出现问题时，设置最大重试时间 -s/--silent静音模式。不输出任何东西 -S/--show-error 显示错误 --socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口 --socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口 --stderr &lt;file&gt; -t/--telnet-option &lt;OPT=val&gt; Telnet选项设置 --trace &lt;file&gt; 对指定文件进行debug --trace-ascii &lt;file&gt; Like --跟踪但没有hex输出 --trace-time 跟踪/详细输出时，添加时间戳 -T/--upload-file &lt;file&gt; 上传文件 --url &lt;URL&gt; Spet URL to work with -u/--user &lt;user[:password]&gt;设置服务器的用户和密码 -U/--proxy-user &lt;user[:password]&gt;设置代理用户名和密码 -v/--verbose -V/--version 显示版本信息 -w/--write-out [format]什么输出完成后 -x/--proxy &lt;host[:port]&gt;在给定的端口上使用HTTP代理 -X/--request &lt;command&gt;指定什么命令 -y/--speed-time 放弃限速所要的时间。默认为30 -Y/--speed-limit 停止传输速度的限制，速度时间'秒 -z/--time-cond 传送时间设置 -0/--http1.0 使用HTTP 1.0 -1/--tlsv1 使用TLSv1（SSL） -2/--sslv2 使用SSLv2的（SSL） -3/--sslv3 使用的SSLv3（SSL） --3p-quote like -Q for the source URL for 3rd party transfer --3p-url 使用url，进行第三方传送 --3p-user 使用用户名和密码，进行第三方传送 -4/--ipv4 使用IP4 -6/--ipv6 使用IP6 -#/--progress-bar 用进度条显示当前的传送状态 使用案例 获取页面的数据curl www.baidu.com 1234C:\Users\zp&gt;curl www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270...... 获取页面数据的同时，查看HTTP头信息curl -i www.baidu.com 1234567891011121314151617C:\Users\zp&gt;curl -i www.baidu.comHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2381Content-Type: text/htmlDate: Sat, 16 Feb 2019 02:10:54 GMTEtag: "588604c8-94d"Last-Modified: Mon, 23 Jan 2017 13:27:36 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action...... 仅获取HTTP头信息curl -I www.baidu.com 123456789101112C:\Users\zp&gt;curl -I www.baidu.comHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 277Content-Type: text/htmlDate: Sat, 16 Feb 2019 02:12:46 GMTEtag: "575e1f60-115"Last-Modified: Mon, 13 Jun 2016 02:50:08 GMTPragma: no-cacheServer: bfe/1.0.8.18 获取更详细的信息，包解析ip的过程等等curl -v www.baidu.com 12345678910111213141516171819202122232425262728293031323334C:\Users\zp&gt;curl -v www.baidu.com* Expire in 0 ms for 6 (transfer 0x23fb58a20a0)* Expire in 1 ms for 1 (transfer 0x23fb58a20a0)* Expire in 1 ms for 1 (transfer 0x23fb58a20a0)* Expire in 2 ms for 1 (transfer 0x23fb58a20a0)* Expire in 6 ms for 1 (transfer 0x23fb58a20a0)* Expire in 7 ms for 1 (transfer 0x23fb58a20a0)* Expire in 10 ms for 1 (transfer 0x23fb58a20a0)* Trying 111.13.100.91...* TCP_NODELAY set* Expire in 149983 ms for 3 (transfer 0x23fb58a20a0)* Expire in 200 ms for 4 (transfer 0x23fb58a20a0)* Connected to www.baidu.com (111.13.100.91) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.64.0&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Accept-Ranges: bytes&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform&lt; Connection: Keep-Alive&lt; Content-Length: 2381&lt; Content-Type: text/html&lt; Date: Sat, 16 Feb 2019 02:14:02 GMT&lt; Etag: "588604c8-94d"&lt; Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT&lt; Pragma: no-cache&lt; Server: bfe/1.0.8.18&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.co...... 保存访问的网页(文件会下载到你当前命令执行的所在目录) 使用重定向功能保存curl www.baidu.com &gt;&gt; index.html 1234C:\Users\zp&gt;curl http://www.baidu.com &gt;&gt;index.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2381 100 2381 0 0 27367 0 --:--:-- --:--:-- --:--:-- 27367 使用curl内置option:-o(小写) 保存网页curl -o temp.html www.baidu.com 1234C:\Users\zp&gt;curl -o temp.html www.baidu.com % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2381 100 2381 0 0 27686 0 --:--:-- --:--:-- --:--:-- 27686 使用curl内置option:-O(大写) 保存网页上的文件curl -O http://www.linux.com/hello.sh 1234C:\Users\zp&gt;curl -O http://www.linux.com/hello.sh % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:01 --:--:-- 0 测试网页返回值测试网站是否正常的常用方法curl -o /dev/null -s -w %{http_code} www.linux.com 12C:\Users\zp&gt; curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com301 通过执行代理服务器及端口访问curl -x 192.168.100.100:1080 http://www.linux.com 1# curl -x 192.168.100.100:1080 http://www.linux.com Cookie很多网站上使用cookie记录session信息，curl可以增加相关参数处理cookie信息 保存网站上的cookie，内置option: -c(小写)，文件会存储在你命令执行的位置curl -c cookie.txt www.baidu.com 1234C:\Users\zp&gt;curl -c cookie.txt www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.bai...... 保存http的response里面的header信息，内置option:-Dcurl -D cookie.txt www.baidu.com 1234C:\Users\zp&gt;curl -D cookie.txt www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxleng...... 使用cookie网站访问有时候会检测你的cookie信息是否合法，因此需要使用上面保存的cookie信息，内置option:-bcurl -b cookie.txt www.baidu.com 1234C:\Users\zp&gt;curl -b cookie.txt www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地....... 模拟浏览器有些网站需要特定的浏览器进行访问，而且还有些需要特定的版本。curl内置option:-A可以让我们指定浏览器去访问网址 1curl -A "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)" http://www.linux.com 伪造referer（盗链）很多服务器会出现检测http访问的rederer从而控制访问。比如：先访问主页，然后再访问主页上的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页地址，断定是盗链curl内置option:-e 可以让我们设定referer 1# curl -e "www.linux.com" http://mail.linux.com 下载文件 利用curl下载文件使用内置option: -o (小写)curl -o baidulogo.png https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png 1234C:\Users\zp&gt;curl -o baidulogo.png https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png?where=super % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 6958 100 6958 0 0 18654 0 --:--:-- --:--:-- --:--:-- 18654 使用内置option: -O (大写)，这个会保存服务器上文件的名字作为本地文件名 1curl -O https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png?where=super 循环下载有时候下载图片可能是前面的部分一样，但是后一部分不一样的情况 1# curl -O http://www.linux.com/dodo[1-5].JPG 下载重名文件如果两次下载的文件重名，就出现文件覆盖的情况，为了不覆盖文件，可执行下面的命令 1# curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG 这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖 分块下载有时候文件比较大，需要分段去下载，使用内置的option:-r 1234curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPGcurl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPGcurl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPGcat dodo1_part* &gt; dodo1.JPG/*这个是linux指令，因此需要在Linux环境下*/ 通过FTP下载文件 12# curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG# curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG 显示下载进度条 1curl -O -# http://www.linux.com/dodo1.JPG 断点续传在Window中，我们可以使用迅雷进行断点续传，curl内置option:-C 同样可以达到相同的效果 1curl -C -O http://www.linux.com/dodo1.JPG 上传文件内置option:-T 实现文件上传，下面是上传一个demo.txt文件到ftp服务器 1curl -T demo.txt -u 用户名:用户密码 ftp://www.linux.com/img/]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Windows</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F02%2F11%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253系统版本：登陆root帐户，输入 cat /etc/redhat-release，。查看CPU信息：grep "model name" /proc/cpuinfo系统位数：uname -a查看已经安装的程序：rpm -qa查看主机名：hostname 解压：tar -zxvf web.tar.gz查看端口号占用情况：netstat -ntlp[root@yan-001 ~] # uname -a # 查看内核/操作系统/CPU信息的linux系统信息命令[root@yan-001 ~] # head -n 1 /etc/issue # 查看操作系统版本，是数字1不是字母L[root@yan-001 ~] # cat /proc/cpuinfo # 查看CPU信息的linux系统信息命令[root@yan-001 ~] # hostname # 查看计算机名的linux系统信息命令[root@yan-001 ~] # lspci -tv # 列出所有PCI设备[root@yan-001 ~] # lsusb -tv # 列出所有USB设备的linux系统信息命令[root@yan-001 ~] # lsmod # 列出加载的内核模块[root@yan-001 ~] # env # 查看环境变量资源[root@yan-001 ~] # free -m # 查看内存使用量和交换区使用量[root@yan-001 ~] # df -h # 查看各分区使用情况[root@yan-001 ~] # du -sh # 查看指定目录的大小[root@yan-001 ~] # grep MemTotal /proc/meminfo # 查看内存总量[root@yan-001 ~] # grep MemFree /proc/meminfo # 查看空闲内存量[root@yan-001 ~] # uptime # 查看系统运行时间、用户数、负载[root@yan-001 ~] # cat /proc/loadavg # 查看系统负载磁盘和分区[root@yan-001 ~] # mount | column -t # 查看挂接的分区状态[root@yan-001 ~] # fdisk -l # 查看所有分区[root@yan-001 ~] # swapon -s # 查看所有交换分区[root@yan-001 ~] # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)[root@yan-001 ~] # dmesg | grep IDE # 查看启动时IDE设备检测状况网络[root@yan-001 ~] # ifconfig # 查看所有网络接口的属性[root@yan-001 ~] # iptables -L # 查看防火墙设置[root@yan-001 ~] # route -n # 查看路由表[root@yan-001 ~] # netstat -lntp # 查看所有监听端口[root@yan-001 ~] # netstat -antp # 查看所有已经建立的连接[root@yan-001 ~] # netstat -s # 查看网络统计信息进程[root@yan-001 ~] # ps -ef # 查看所有进程[root@yan-001 ~] # top # 实时显示进程状态用户[root@yan-001 ~] # w # 查看活动用户[root@yan-001 ~] # id # 查看指定用户信息[root@yan-001 ~] # last # 查看用户登录日志[root@yan-001 ~] # cut -d: -f1 /etc/passwd # 查看系统所有用户[root@yan-001 ~] # cut -d: -f1 /etc/group # 查看系统所有组[root@yan-001 ~] # crontab -l # 查看当前用户的计划任务服务[root@yan-001 ~] # chkconfig –list # 列出所有系统服务[root@yan-001 ~] # chkconfig –list | grep on # 列出所有启动的系统服务程序[root@yan-001 ~] # rpm -qa # 查看所有安装的软件包[root@yan-001 ~] # cat /proc/cpuinfo # 查看CPU相关参数的linux系统命令[root@yan-001 ~] # cat /proc/partitions # 查看linux硬盘和分区信息的系统信息命令[root@yan-001 ~] # cat /proc/meminfo # 查看linux系统内存信息的linux系统命令[root@yan-001 ~] # cat /proc/version # 查看版本，类似uname -r[root@yan-001 ~] # cat /proc/ioports # 查看设备io端口[root@yan-001 ~] # cat /proc/interrupts # 查看中断[root@yan-001 ~] # cat /proc/pci # 查看pci设备的信息[root@yan-001 ~] # cat /proc/swaps # 查看所有swap分区的信息 注释掉系统不需要的用户和用户组注意：不建议直接删除，当你需要某个用户时，自己重新添加会很麻烦。 注释掉不用的用户 1234567891011cp /etc/passwd /etc/passwdbak #修改之前先备份 vi /etc/passwd #编辑用户，在前面加上#注释掉 此行#adm:x:3:4:adm:/var/adm:/sbin/nologin#lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin#sync:x:5:0:sync:/sbin:/bin/sync#shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown#halt:x:7:0:halt:/sbin:/sbin/halt#uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin#operator:x:11:0:operator:/root:/sbin/nologin#games:x:12:100:games:/usr/games:/sbin/nologin#gopher:x:13:30:gopher:/var/gopher:/sbin/nologin#ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin #注释掉ftp匿名账号 注释掉不用的用户用户组 12345678cp /etc/group /etc/groupbak #修改之前先备份 vi /etc/group #编辑用户组，在前面加上#注释掉此行#adm:x:4:root,adm,daemon#lp:x:7:daemon,lp#uucp:x:14:uucp#games:x:20:#dip:x:40: 关闭系统不需要的服务12345678service acpid stop chkconfig acpid off #停止服务，取消开机启动 #电源进阶设定，常用在 Laptop 上service autofs stop chkconfig autofs off #停用自动挂载档桉系统与周边装置service bluetooth stop chkconfig bluetooth off #停用Bluetooth蓝芽service cpuspeed stop chkconfig cpuspeed off #停用控制CPU速度主要用来省电service cups stop chkconfig cups off #停用 Common UNIX Printing System 使系统支援印表机service ip6tables stop chkconfig ip6tables off #禁止IPv6#如果要恢复某一个服务，可以执行下面操作#service acpid start chkconfig acpid on 禁止非root用户执行/etc/rc.d/init.d/下的系统命令12chmod -R 700 /etc/rc.d/init.d/*chmod -R 777 /etc/rc.d/init.d/* #恢复默认设置 给下面的文件加上不可更改属性，从而防止非授权用户获得权限12345678910111213chattr +i /etc/passwdchattr +i /etc/shadowchattr +i /etc/groupchattr +i /etc/gshadowchattr +i /etc/services #给系统服务端口列表文件加锁,防止未经许可的删除或添加服务lsattr /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/services #显示文件的属性 注意：执行以上权限修改之后，就无法添加删除用户了。如果再要添加删除用户，需要先取消上面的设置，等用户添加删除完成之后，再执行上面的操作chattr -i /etc/passwd #取消权限锁定设置 chattr -i /etc/shadow chattr -i /etc/group chattr -i /etc/gshadow chattr -i /etc/services #取消系统服务端口列表文件加锁现在可以进行添加删除用户了，操作完之后再锁定目录文件 限制不同文件的权限12345678910111213chattr +a .bash_history #避免删除.bash_history或者重定向到/dev/nullchattr +i .bash_historychmod 700 /usr/bin 恢复 chmod 555 /usr/binchmod 700 /bin/ping 恢复 chmod 4755 /bin/pingchmod 700 /usr/bin/vim 恢复 chmod 755 /usr/bin/vimchmod 700 /bin/netstat 恢复 chmod 755 /bin/netstatchmod 700 /usr/bin/tail 恢复 chmod 755 /usr/bin/tailchmod 700 /usr/bin/less 恢复 chmod 755 /usr/bin/lesschmod 700 /usr/bin/head 恢复 chmod 755 /usr/bin/headchmod 700 /bin/cat 恢复 chmod 755 /bin/catchmod 700 /bin/uname 恢复 chmod 755 /bin/unamechmod 500 /bin/ps 恢复 chmod 755 /bin/ps 禁止使用Ctrl+Alt+Del快捷键重启服务器123cp /etc/inittab /etc/inittabbakvi /etc/inittab #注释掉下面这一行#ca::ctrlaltdel:/sbin/shutdown -t3 -r now 不随意升级内核使用yum update更新系统时不升级内核，只更新软件包由于系统与硬件的兼容性问题，有可能升级内核后导致服务器不能正常启动，这是非常可怕的，没有特别的需要，建议不要随意升级内核。12345cp /etc/yum.conf /etc/yum.confbak1、修改yum的配置文件 vi /etc/yum.conf 在[main]的最后添加 exclude=kernel*2、直接在yum的命令后面加上如下的参数：yum --exclude=kernel* update查看系统版本 cat /etc/issue查看内核版本 uname -a 关闭Centos自动更新1234567chkconfig --list yum-updatesd #显示当前系统状态yum-updatesd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭service yum-updatesd stop #关闭 开启参数为start停止 yum-updatesd： [确定]service yum-updatesd status #查看是否关闭yum-updatesd 已停chkconfig --level 35 yum-updatesd off #禁止开启启动（系统模式为3、5）chkconfig yum-updatesd off #禁止开启启动（所有启动模式全部禁止）chkconfig --list yum-updatesd #显示当前系统状态yum-updatesd 0:关闭 1:关闭 2:启用 3:关闭 4:启用 5:关闭 6:关闭 关闭多余的虚拟控制台我们知道从控制台切换到 X 窗口，一般采用 Alt-F7 ，为什么呢？因为系统默认定义了 6 个虚拟控制台，所以 X 就成了第7个。实际上，很多人一般不会需要这么多虚拟控制台的，修改/etc/inittab ，注释掉那些你不需要的。123456789cp /etc/inittab /etc/inittabbakvi /etc/inittab# Run gettys in standard runlevels1:2345:respawn:/sbin/mingetty tty1#2:2345:respawn:/sbin/mingetty tty2#3:2345:respawn:/sbin/mingetty tty3#4:2345:respawn:/sbin/mingetty tty4#5:2345:respawn:/sbin/mingetty tty5#6:2345:respawn:/sbin/mingetty tty6 修改history命令记录123cp /etc/profile /etc/profilebakvi /etc/profile找到 HISTSIZE=1000 改为 HISTSIZE=50 隐藏服务器系统信息在缺省情况下，当你登陆到linux系统，它会告诉你该linux发行版的名称、版本、内核版本、服务器的名称。为了不让这些默认的信息泄露出来，我们要进行下面的操作，让它只显示一个”login:”提示符。删除/etc/issue和/etc/issue.net这两个文件，或者把这2个文件改名，效果是一样的。12mv /etc/issue /etc/issuebakmv /etc/issue.net /etc/issue.netbak 优化Linux内核参数1234567cp /etc/sysctl.conf /etc/sysctl.confbakvi /etc/sysctl.conf#在文件末尾添加以下内容net.ipv4.ip_forward = 1#修改为1net.core.somaxconn = 262144net.core.netdev_max_backlog = 262144net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.netfilter.ip_conntrack_max = 131072net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 180net.ipv4.route.gc_timeout = 20net.ipv4.ip_conntrack_max = 819200net.ipv4.ip_local_port_range = 10024 65535net.ipv4.tcp_retries2 = 5net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_len = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_keepalive_time = 120net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000/sbin/sysctl -p #使配置立即生效 十四、CentOS 系统优化1234cp /etc/profile /etc/profilebak2vi /etc/profile #在文件末尾添加以下内容ulimit -c unlimitedulimit -s unlimitedulimit -SHn 65535ulimit -S -c 0export LC_ALL=Csource /etc/profile #使配置立即生效ulimit -a #显示当前的各种用户进程限制 服务器禁止ping12cp /etc/rc.d/rc.local /etc/rc.d/rc.localbakvi /etc/rc.d/rc.local#在文件末尾增加下面这一行echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all参数0表示允许 1表示禁止]]></content>
      <categories>
        <category>服务器</category>
        <category>Linux常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux后台执行命令 &和nohup]]></title>
    <url>%2F2019%2F02%2F11%2FLinux%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-%E5%92%8Cnohup%2F</url>
    <content type="text"><![CDATA[当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。 使用&amp;当在前台运行某个作业时，终端被该作业占用；可以在命令后面加上&amp;实现后台运行，例如：1sh test.sh &amp; 适合在后台运行find、费时的排序及一些shell脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行（例如需要你去确认是否安装，是否overwrite之类的），否则机器会在哪里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业产生大量的输出，最好使用下面的方法把他重定向输出到某个文件中,具体的实例见下图，当成功提交进程后，会显示一个进程号，可以使用它来监控进程或者杀死进程（ps -ef|grep 查看进程；kill -9 杀死进程）：1command &gt; out.file 2&gt;&amp;1 &amp; 使用nohup使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一旦把当前控制台关掉（退出账户时），作业就会停止运行。nohup命令可以在你退出账号之后继续运行相应的进程。nohup就是不挂起的意思（no hang up），该命令的一般形式如下：1nohup command &amp; 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外制定了输出文件1nohup command &gt; myout.file 2&gt;&amp;1 &amp; 使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台执行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行 相关指令 Ctrl+z可以将一个正在执行的命令放到后台，并且处于暂停状态 jobs查看当前有多少在后台运行的命令，查看的结果是没有进程ID的，所以上面nohup打印进程ID的时候，一定要记下来，好用来结束 2&gt;&amp;12&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行 试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出]]></content>
      <categories>
        <category>服务器</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>后台执行</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10激活方法]]></title>
    <url>%2F2019%2F02%2F11%2FWin10%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法1：创建一个bat文件，里面输入以下命令，然后管理员权限执行以下 123slmgr /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJslmgr /skms kms.firadio.netslmgr /ato 方法二：管理员方式运行下面的bat 下载Win10_KMS_Activation.bat 方法三123456789101.打开“注册表编辑器”；（Windows + R然后输入 Regedit）修改SkipRearm 的值为1：（在HKEY_LOCAL_MACHINE–》SOFTWARE–》Microsoft–》Windows NT–》CurrentVersion–》SoftwareProtectionPlatform里面，将SkipRearm的值修改为1）重启电脑2.以管理员身份启动cmd，输入SLMGR -REARM，根据提示，再次重启电脑！3.slmgr /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ弹出窗口提示：“成功的安装了产品密钥”。4.slmgr /skms xykz.f3322.org密钥管理服务计算机名称成功设置为xykz.f3322.org5.slmgr /ato按回车键后将弹出窗口提示：“成功的激活了产品”。至此，Win10正式企业版系统激活成功。]]></content>
      <categories>
        <category>办公知识</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap-Treeview实现级联勾选]]></title>
    <url>%2F2019%2F02%2F11%2Fbootstrap-Treeview%E5%AE%9E%E7%8E%B0%E7%BA%A7%E8%81%94%E5%8B%BE%E9%80%89%2F</url>
    <content type="text"><![CDATA[实例化Tree123456$('#searchTree').treeview(&#123; showCheckbox:true, data:treeData, onNodeChecked:nodeChecked , onNodeUnchecked:nodeUnchecked &#125;); 核心方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var nodeCheckedSilent = false; function nodeChecked (event, node)&#123; if(nodeCheckedSilent)&#123; return; &#125; nodeCheckedSilent = true; checkAllParent(node); checkAllSon(node); nodeCheckedSilent = false; &#125; var nodeUncheckedSilent = false; function nodeUnchecked (event, node)&#123; if(nodeUncheckedSilent) return; nodeUncheckedSilent = true; uncheckAllParent(node); uncheckAllSon(node); nodeUncheckedSilent = false; &#125; //选中全部父节点 function checkAllParent(node)&#123; $('#searchTree').treeview('checkNode',node.nodeId,&#123;silent:true&#125;); var parentNode = $('#searchTree').treeview('getParent',node.nodeId); if(!("nodeId" in parentNode))&#123; return; &#125;else&#123; checkAllParent(parentNode); &#125; &#125; //取消全部父节点 function uncheckAllParent(node)&#123; $('#searchTree').treeview('uncheckNode',node.nodeId,&#123;silent:true&#125;); var siblings = $('#searchTree').treeview('getSiblings', node.nodeId); var parentNode = $('#searchTree').treeview('getParent',node.nodeId); if(!("nodeId" in parentNode)) &#123; return; &#125; var isAllUnchecked = true; //是否全部没选中 for(var i in siblings)&#123; if(siblings[i].state.checked)&#123; isAllUnchecked=false; break; &#125; &#125; if(isAllUnchecked)&#123; uncheckAllParent(parentNode); &#125; &#125; //级联选中所有子节点 function checkAllSon(node)&#123; $('#searchTree').treeview('checkNode',node.nodeId,&#123;silent:true&#125;); if(node.nodes!=null&amp;&amp;node.nodes.length&gt;0)&#123; for(var i in node.nodes)&#123; checkAllSon(node.nodes[i]); &#125; &#125; &#125; //级联取消所有子节点 function uncheckAllSon(node)&#123; $('#searchTree').treeview('uncheckNode',node.nodeId,&#123;silent:true&#125;); if(node.nodes!=null&amp;&amp;node.nodes.length&gt;0)&#123; for(var i in node.nodes)&#123; uncheckAllSon(node.nodes[i]); &#125; &#125; &#125;]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>treeview</tag>
        <tag>bootstrap</tag>
        <tag>前端开发框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui下拉及复选动态设置disabled、checked及onchange监听]]></title>
    <url>%2F2019%2F02%2F11%2Flayui%E4%B8%8B%E6%8B%89%E5%8F%8A%E5%A4%8D%E9%80%89%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEdisabled%E3%80%81checked%E5%8F%8Aonchange%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[layui是非模块化引入的12345&lt;link rel="stylesheet" href="plugins/layuiv-2.3.0/css/layui.css"&gt;**********************页面代码*********************&lt;script type="text/javascript" src="plugins/layuiv-2.3.0/layui.all.js"&gt;&lt;/script&gt; html代码1234567891011121314151617181920212223242526272829303132333435&lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;审批意见&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select name="APPVTYPE" lay-filter="appvtype" lay-verify="required" lay-search=""&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty appvTypeList&#125;"&gt; &lt;c:forEach items="$&#123;appvTypeList&#125;" var="appvType" varStatus="vs"&gt; &lt;option value="$&#123;appvType.APPR_CODE&#125;"&gt;$&#123;appvType.APPR_NAME&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;拒件理由&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select name="REFUSALREG" lay-verify="required" lay-search="" disabled=""&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty refusalRegList&#125;"&gt; &lt;c:forEach items="$&#123;refusalRegList&#125;" var="refusalReg" varStatus="vs"&gt; &lt;option value="$&#123;refusalReg.CODE_VALUE&#125;"&gt;$&#123;refusalReg.CODE_NAME&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="layui-inline"&gt; &lt;div class="layui-input-block"&gt; &lt;input type="checkbox" name="like1[write]" lay-skin="primary" title="加入黑名单" disabled="" id="BLACKLIST"&gt; &lt;/div&gt;&lt;/div&gt; js代码（一定要注意下面的重新渲染）1234567891011121314var form = layui.form;//初始化formform.on('select(appvtype)', function(data)&#123;//监听下拉框onchange if(data.value=="02")&#123; $("select[name^='REFUSALREG']").removeAttr("disabled");//设置下拉框为非只读 $("#BLACKLIST").removeAttr("disabled");//设置复选框为非只读 form.render();//重新渲染所有元素（必须得进行重新渲染，要不没法正常显示） &#125;else&#123; $("select[name^='REFUSALREG']").attr("disabled","disabled");//设置下拉框为只读 $("#BLACKLIST").attr("disabled","disabled");//设置复选框为只读 $("select[name^='REFUSALREG']").val("");//清空下拉框选中的值 $("#BLACKLIST").prop("checked",false);//清空复选框选中的值 form.render();//重新渲染所有元素（必须得重新渲染，要不没法正常显示） &#125;&#125;);]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>layui</category>
      </categories>
      <tags>
        <tag>前端开发框架</tag>
        <tag>layui</tag>
        <tag>下拉框、复选框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery模糊选择器及遍历]]></title>
    <url>%2F2019%2F02%2F01%2FJquery%E6%A8%A1%E7%B3%8A%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[JQuery常规选择器1. 首先是常规使用选择所有元素12345678910$("*")$("body *")$(document).ready(function()&#123; $("body *").css("background-color","#B2E0FF");&#125;);$(function()&#123; $("body *").css("background-color","red");&#125;) 根据id选择元素12345$("#id")$(document).ready(function()&#123; $("#choose").css("background-color","#B2E0FF");&#125;) 根据样式class选择元素该方法常用作选择多个元素123456789$(".class")$(document).ready(function()&#123; $(".className").css("background-color","red");&#125;)$(function()&#123; $(".className").css("background-color","red");&#125;) 获取第一个、最后一个元素12$("p:first")$("p:last") 所有偶数或者所有奇数标签这里的偶数和奇数是索引，索引是从0开始的，因此第一个偶数就是0123$("tr:even") //偶数$("tr:odd") //奇数$("tr:even").css("background-color","#B2E0FF"); 选择index&gt;n 或者小于n的所有对象123$("ul li:gt(3)")$("ul li:lt(3)")$("tr:lt(2)") 选择所有不为空的input123$("selector:not(selector)")$("input:not(:empty)")$("input:not(:empty)") 所有标题元素1$(":header") //所有标题元素 &lt;h1&gt; - &lt;h6&gt; 所有动画元素1$(":animated") 包含指定字符串的所有元素1234$(":contains('W3School')")$("p:contains(is)")$("p:contains(is)").css("background-color","#B2E0FF");$("div:contains(is)").css("background-color","red") 所有无子节点的所有元素1$(":empty") 所有隐藏的标签12$(":hidden")$("p:hidden") 所有可见表格1$("table:visible") 所有带匹配选择的元素1$("th,td,.intro") 所有带某个属性的元素123//公式$("[attribute]")$("[href]")$("li[name]").css("background-color","#B2E0FF");//li标签中带name属性的 所有带某个属性值等于或者不等于XXX的元素123456$("[href='#']")$("input[name='123123']")$("input[name^='123123']")$("[name!='123123']")$("[href!='#']") 包含以XXX开头 XXX结尾的元素12$("input[name^='aaa']")//以aaa开头的所有input元素$("input[name$='bbb']")//所有以bbb结尾的input元素 input的各种类型元素筛选器12345678910$(":input") // 所有 &lt;input&gt; 元素$(":text") //$(":password")//$(":radio")//$(":checkbox")//$(":submit")//$(":reset")//$(":button")//$(":image")//$(":file")// 所有激活或者禁用的元素12$(":enabled")$(":disabled") 下拉框选择中被选中的1$(":selected") 123456789 $(".btn1").click(function()&#123; $(":selected").hide(); &#125;);&lt;select multiple="multiple"&gt; &lt;option&gt;Volvo&lt;/option&gt; &lt;option selected="selected"&gt;Saab&lt;/option&gt; &lt;option&gt;Mercedes&lt;/option&gt; &lt;option&gt;Audi&lt;/option&gt; 单选框、复选框中被选中的1$(":checked").hide(); 2. 模糊选择器前后缀为XXX的选择器1234$("[name^='aaa']")//前缀$("input[name^='aaa']")//前缀$("[name$='aaa']")//后缀$("input[name$='aaa']")//后缀 name中包含XXX的选择器1$("input[name*='aaaa']") 1$("input:text[name='xx']") 3. 遍历12$("input[name^='aaa']").each(function(i)&#123;&#125;)]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>选择器</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery控制组合按钮及div下拉效果及鼠标悬浮显示div效果]]></title>
    <url>%2F2019%2F02%2F01%2FjQuery%E6%8E%A7%E5%88%B6%E7%BB%84%E5%90%88%E6%8C%89%E9%92%AE%E5%8F%8Adiv%E4%B8%8B%E6%8B%89%E6%95%88%E6%9E%9C%E5%8F%8A%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%98%BE%E7%A4%BAdiv%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[效果图 HTML代码1234567891011121314&lt;button id="searchTypeBtn" class="btn btn-default" type="button" style="padding: 2px;margin-left:2px;background-color: #000 !important"&gt; &lt;i class="glyphicon glyphicon-sort" style="margin-left:3px"&gt;&lt;/i&gt; &lt;div class="searchType" style="z-index:99;position: absolute;width: 97px;left: -70px;top: 25px;display: none;color:#000;background-color: #fff;border: 1px solid #eee"&gt; &lt;table class="layui-table" style="margin:0px"&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty moduleTypeList&#125;"&gt; &lt;c:forEach items="$&#123;moduleTypeList&#125;" var="moduleType" varStatus="vs"&gt; &lt;tr onclick="updateModuleList('$&#123;moduleType.CODE_VALUE&#125;')"&gt;&lt;td style="text-align: center;"&gt;$&#123;moduleType.CODE_NAME&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/table&gt; &lt;/div&gt;&lt;/button&gt; JS代码12345678910$(function()&#123; $("#searchTypeBtn").hover( function()&#123; $(".searchType").slideDown(400); &#125;, function()&#123; $(".searchType").slideUp(400); &#125; );&#125;);]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery获取input标签的值(text,radio,checkbox)]]></title>
    <url>%2F2019%2F02%2F01%2FjQuery%E8%8E%B7%E5%8F%96input%E6%A0%87%E7%AD%BE%E7%9A%84%E5%80%BC-text-radio-checkbox%2F</url>
    <content type="text"><![CDATA[本文章转自《jQuery获取input标签的值(text,radio,checkbox)》 这篇文章有个比较好的地方，就是遍历设置复选框的选中状态和获取复选框选中的值并拼装成对应的数据 获取页面上的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;/head&gt; &lt;script src="jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div&gt; &lt;input type="text" placeholder="账号" id="zh"/&gt; &lt;p/&gt; &lt;input type="radio" name="sex" value="0" /&gt;男 &lt;input type="radio" name="sex" value="1" checked="checked"/&gt;女 &lt;p/&gt; &lt;input type="checkbox" name="hobby" value="swim" /&gt;swim &lt;input type="checkbox" name="hobby" value="game" /&gt;game &lt;input type="checkbox" name="hobby" value="video" /&gt;video &lt;p/&gt; &lt;input type="button" id="submit" value="提交" /&gt; &amp;nbsp;&amp;nbsp; &lt;input type="button" id="look" value="查看注册用户信息" /&gt; &lt;div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;$("#submit").click(function()&#123; var zh = $("#zh").val(); var sex = $("[name='sex']:checked").val(); var hobbies = ""; //将hobby复选框的值 总和成 ,, 的形式 $("[name='hobby']:checked").each(function(index, element) &#123; hobbies += $(this).val()+","; &#125;); hobbies = hobbies.slice(0,-1); //用json传值 var user = new User(zh,sex,hobbies); var jsonUser = JSON.stringify(user); console.log(jsonUser); localStorage.setItem("user",jsonUser);&#125;);$("#look").click(function()&#123; window.location="用户信息.html";&#125;);&lt;/script&gt; 设置值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户信息&lt;/title&gt; &lt;style&gt; div&#123; margin:100px; font-size:24px; &#125; div input&#123; font-size:24px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;script src="jquery-2.1.1.min.js"&gt;&lt;/script&gt;&lt;script src="user.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div&gt; &lt;input type="text" placeholder="账号" id="zh"/&gt; &lt;p/&gt; &lt;input type="radio" name="sex" value="0" checked="checked"/&gt;男 &lt;input type="radio" name="sex" value="1" /&gt;女 &lt;p/&gt; &lt;input type="checkbox" name="hobby" value="swim" /&gt;swim &lt;input type="checkbox" name="hobby" value="game" /&gt;game &lt;input type="checkbox" name="hobby" value="video" /&gt;video &lt;p/&gt; &lt;input type="button" id="submit" value="修改" /&gt; &lt;div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;$(function()&#123; var jsonUser = localStorage.getItem("user"); var user = JSON.parse(jsonUser); var userClass = new User(); //当json中的key 与 定义类 User中的key (属性名)相同时 赋值 for(var userKey in user)&#123; for(var userClasskey in userClass)&#123; if(userKey == userClasskey)&#123; userClass[userClasskey]=user[userKey]; &#125; &#125; &#125; $("#zh").val(userClass.getName()); $("[name='sex'][value="+userClass.getSex()+"]").attr("checked","checked"); var hobbies = userClass.getHobby().split(","); for(var i=0;i&lt;hobbies.length;i++)&#123; $("[name='hobby'][value="+hobbies[i]+"]").attr("checked","checked"); &#125;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery获取标签的类型及input标签的类型]]></title>
    <url>%2F2019%2F02%2F01%2FJquery%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8Ainput%E6%A0%87%E7%AD%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[常规情况下一班是没有这种需求的，但最近在做页面数据反显，而且数据是反显在p标签里面和span标签里面，因此有了这方面的需求 首先列举一下标签的种类 标签 描述 &lt;a&gt; 定义锚 &lt;article&gt; 定义文章 &lt;b&gt; 定义粗字体 &lt;body&gt; 定义文档的主体 &lt;br&gt; 定义简单的折行 &lt;button&gt; 定义按钮 (push button) &lt;canvas&gt; 定义图形 &lt;code&gt; 定义计算机代码文本 &lt;del&gt; 定义被删除文本 &lt;em&gt; 定义强调文本 &lt;fotter&gt; 定义 section 或 page 的页脚 &lt;form&gt; 定义供用户输入的 HTML 表单 &lt;frame&gt; 定义框架集的窗口或框架 &lt;h1&gt;to&lt;h6&gt; 定义 HTML 标题 &lt;hr&gt; 定义水平线 &lt;i&gt; 定义斜体字 &lt;img&gt; 定义图像 &lt;input&gt; 定义输入控件 &lt;label&gt; 定义 input 元素的标注 &lt;p&gt; 定义段落 &lt;span&gt; 定义文档中的节 &lt;table&gt; 定义表格 &lt;tbody&gt; 定义表格中的主体内容 &lt;td&gt; 定义表格中的单元 &lt;textarea&gt; 定义多行的文本输入控件 &lt;thead&gt; 定义表格中的表头内容 &lt;tr&gt; 定义表格中的行 &lt;ul&gt; 定义无序列表 获取方法12//目前测试了几个p标签是p，span打印span$("#id")[0].tagName.toLowerCase() 问题那么问题来了，就是关于input中包含很多类型，比如说text、button、radio、checkbox等等，怎么获取这些类型进行区分呢？ 12//目前测试能够返回checkbox、radio等等$("#id")[0].type]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP知识点]]></title>
    <url>%2F2019%2F02%2F01%2FJSP%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[隐藏iframe提交功能1234//隐藏Iframe提交功能document.forms[0].target = "hiddenFrame";document.forms[0].action = url;document.forms[0].submit(); jsp调用servlet进行页面跳转12request.getRequestDispatcher("/Newpage.jsp").forward(request,response);主要的部分就是红字部分，由于跳转到的页面就在根目录下面，因此只需要跟到（“/Newpage.jsp”）就可以了！ JSP之间传递中文汉字A.jsp中keyword是中文的123456xyd.buttonClick("cms-search",function()&#123; var key = "keyword="+$("[data-out-name='cms-keyword']").val(); var url = "&lt;%=_basePath%&gt;/page/my-cms-search.jsp?"+key; // 这个地方是两遍（encodeURI），一定要记住 location.href = encodeURI(encodeURI(url));&#125;); B.jsp中接收传递的参数123//搜索String keyword = request.getParameter("keyword")==null ? "" : (String)request.getParameter("keyword");keyword = URLDecoder.decode(keyword);]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JSP</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识点]]></title>
    <url>%2F2019%2F02%2F01%2FCSS%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[CSS模糊筛选器12&lt;!--p是标签的类型，class是标签的属性，important是需要模糊查询的内容--&gt;p[class~="important"] &#123;color: red;&#125; 123div[id^="filePicker"]&#123; width: 200px;&#125; 123456img[title~="Figure"] &#123;border: 1px solid gray;&#125;``` ## JQuery 给样式添加important的样式```css$(".tab_close").css("cssText","display:none !important"); 类型 描述 [abc^=”def”] 选择 abc 属性值以 “def” 开头的所有元素 [abc$=”def”] 选择 abc 属性值以 “def” 结尾的所有元素 [abc*=”def”] 选择 abc 属性值中包含子串 “def” 的所有元素 CSS3实现一直旋转的图片使用方法：①新建一个DIV，class=”demo_div”,div里面放一个图片，就能让图片一直进行旋转了，很好玩123456789101112@-webkit-keyframes rotation&#123; from &#123;-webkit-transform: rotate(0deg);&#125; to &#123;-webkit-transform: rotate(360deg);&#125;&#125;.demo_div&#123; -webkit-transform: rotate(360deg); animation: rotation 3s linear infinite; -moz-animation: rotation 3s linear infinite; -webkit-animation: rotation 3s linear infinite; -o-animation: rotation 3s linear infinite;&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号 模板消息发送]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[前言微信公众号开发，其实很简单，这里是在微信公众号测试账号（公众号沙箱）上的开发流程，具体到生产环境的公众号开发，另行配置，比如说公众号主体信息认证、消息模板配置（审核很严，需要提前进行申请，防止影响业务） 名词介绍 appID：第三方用户唯一凭证 appsecret：第三方用户唯一凭证密钥，即appsecret access_token：公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token，通过接口传递appId和appsecret，而且目前的有效时间是7200s，所以需要定期进行数据再求，更改access_token opendId：用户与公众号对应关系的唯一ID，一个用户对多个公众号有多个不同的openId，一个公众号对不同的用户有不同的openId templete_id：模板ID，发送消息的时候是通过调用接口，传递模板ID和对应模板中的参数进行数据发送的 准备材料 打开微信公众号测试账号地址，登录之后，会显示对应的appID和appsecret，这个获取access_token的时候会用到，需要记录下来 扫描测试账号界面的二维码，关注自己的测试公众号，然后能获取一个opendId，具体界面如下 创建发送消息的模板，获取到一个templete_id（测试公众号的模板是可以随便创建，不需要申请流程，但是每个测试账号下面只能有最多10个测试模板），创建模板的时候，一定要注意规则要传递的变量是以，其中param是你的要传递的参数个人创建的模板为：1&#123;&#123;first.DATA&#125;&#125; 采购单编号：&#123;&#123;keyword1.DATA&#125;&#125; 采购类型：&#123;&#123;keyword2.DATA&#125;&#125; 订货日期：&#123;&#123;keyword3.DATA&#125;&#125; 要求送货日期：&#123;&#123;keyword4.DATA&#125;&#125; &#123;&#123;remark.DATA&#125;&#125; 代码工具类HttpUtils.java和ReadProperties.java HttpUtils类是用作发送网络请求 ReadProperties类是用作读取Properties中的appid和appsecret（因为这两个值一般不会发生变化，所以存在properties文件中） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ConnectException;import java.net.CookieHandler;import java.net.CookieManager;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.ProtocolException;import java.net.URL;import java.net.URLConnection;import java.util.Iterator;import java.util.Map;import com.alibaba.fastjson.JSONObject;public class HttpUtils &#123; /** * Do POST request * @param url * @param JsonObject * @return * @throws Exception */ public String doPostForJson(String url, JSONObject jsonObj) throws Exception &#123; System.out.println("POST parameter : " + jsonObj.toString()); URL localURL = new URL(url); URLConnection connection = localURL.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setDoOutput(true); httpURLConnection.setRequestMethod("POST"); httpURLConnection.setRequestProperty("Accept-Charset", "UTF-8"); httpURLConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); httpURLConnection.setRequestProperty("Content-Length", String.valueOf(jsonObj.toString().length())); OutputStream outputStream = null; OutputStreamWriter outputStreamWriter = null; InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; try &#123; outputStream = httpURLConnection.getOutputStream(); outputStreamWriter = new OutputStreamWriter(outputStream,"UTF-8"); outputStreamWriter.write(jsonObj.toString()); outputStreamWriter.flush(); if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception("HTTP Request is not success, Response code is " + httpURLConnection.getResponseCode()); &#125; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (outputStreamWriter != null) &#123; outputStreamWriter.close(); &#125; if (outputStream != null) &#123; outputStream.close(); &#125; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125; /** * 发送GET请求 * @param url * @return * @throws Exception */ public String doGet(String url) throws Exception &#123; URL localURL = new URL(url); URLConnection connection = localURL.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setRequestProperty("Accept-Charset", "utf-8"); httpURLConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception("HTTP Request is not success, Response code is " + httpURLConnection.getResponseCode()); &#125; try &#123; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream,"UTF-8"); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233import java.util.MissingResourceException;import java.util.ResourceBundle;public class ReadProperties &#123; private static final ResourceBundle bundle; static &#123; // 读取propertiest资源文件 bundle = ResourceBundle.getBundle("systemconfig"); &#125; /** * 根据name获得propertiest资源文件里字符串的名 * @param name * @return */ public static String getString(String name) &#123; String value = null; try &#123; value = bundle.getString(name); value = new String(value.getBytes("ISO8859-1"), "UTF-8"); &#125; catch (MissingResourceException e) &#123; System.err.println(e); &#125; catch (Exception ee) &#123; System.err.println(ee); &#125; if ("".equals(value)) &#123; return null; &#125; else &#123; return value; &#125; &#125;&#125; 微信返回消息实体类WeixinAccessTokenEntity.java1234567891011121314151617181920212223/** * 请求微信Token返回的实体类 */public class WeixinAccessTokenEntity &#123; private String accessToken; private long expirationTime; public WeixinAccessTokenEntity(String accessToken, long expirationTime) &#123; this.accessToken = accessToken; this.expirationTime = expirationTime; &#125; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpirationTime() &#123; return expirationTime; &#125; public void setExpirationTime(long expirationTime) &#123; this.expirationTime = expirationTime; &#125;&#125; 发送消息的公共方法类WeChatCommon.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.third.util;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletContext;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.WebApplicationContext;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.third.bean.common.WeixinAccessTokenEntity;/** * 微信公众号相关公共类 * @author zp */public class WeChatCommon &#123; public static JSONObject sendTempleteMsg(String openId,String templateId,Map&lt;String,Object&gt; msgContentMap) &#123; //返回的JSONObject JSONObject jsonObject = new JSONObject(); jsonObject.put("code",-1); //获取access_token String accessToken = ""; try &#123; //首先通过项目全局上下文判断access_token是否失效 WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext application = webApplicationContext.getServletContext(); Object wechatAccessTokenObj = application.getAttribute("tokenMap"); WeixinAccessTokenEntity wechatAccessTokenEntity = wechatAccessTokenObj == null ? null: (WeixinAccessTokenEntity)wechatAccessTokenObj; //如果超期，或者access_token没有的时候，重新生成，并设置到全局上下文中 if(wechatAccessTokenEntity == null || wechatAccessTokenEntity.getExpirationTime()&lt;System.currentTimeMillis()) &#123; accessToken = getAccseeToken(); &#125;else &#123; accessToken = wechatAccessTokenEntity.getAccessToken(); &#125; //如果还是获取失败，则走Exception if(accessToken == null || "".equals(accessToken)) &#123; throw new Exception("获取accessToken失败!"); &#125; //组装发送的JSON串信息 JSONObject sendInfoJsonObject = packSendTemplate(openId,templateId,msgContentMap); //发送网络请求 String urlStr = "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="+accessToken;//发送消息Url HttpUtils httpUtils = new HttpUtils(); String returnMsgInfoStr = httpUtils.doPostForJson(urlStr, sendInfoJsonObject); System.out.println(returnMsgInfoStr); JSONObject returnMsgInfoJSONObject = JSON.parseObject(returnMsgInfoStr); if(returnMsgInfoJSONObject!=null &amp;&amp; returnMsgInfoJSONObject.getInteger("errcode") == 0) &#123; jsonObject.put("code",0); &#125;else &#123; jsonObject.put("msg",returnMsgInfoJSONObject.get("errmsg")); &#125; &#125; catch (Exception e) &#123; jsonObject.put("msg",e.getMessage()); e.printStackTrace(); &#125; return jsonObject; &#125; /** * 获取access_token * @return */ public static String getAccseeToken() &#123; //首先获取appId和appSecret（这个是读取配置文件*.properties文件），当然你也可以写死成上面获取到的appId和appsecret String appId=ReadProperties.getString("appId"); String appSecret=ReadProperties.getString("appsecret"); WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext application = webApplicationContext.getServletContext(); String url="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="+appId+"&amp;secret="+appSecret; HttpUtils httpRequestor = new HttpUtils(); String returnData=""; try &#123; returnData = httpRequestor.doGet(url); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; JSONObject json=JSON.parseObject(returnData); if(json.containsKey("access_token"))&#123; if(json.get("access_token")!=null&amp;&amp;!json.get("access_token").equals(""))&#123; //如果获取成功了，设置到程序的全局变量中，当然如果是集群或者其他的话，可以直接放入Redis，并设置失效时间 application.setAttribute("tokenMap", new WeixinAccessTokenEntity(json.get("access_token").toString(), System.currentTimeMillis()+Long.parseLong(json.get("expires_in").toString())*1000)); return json.get("access_token").toString(); &#125; &#125; return null; &#125; /** * 组装微信消息模板JsonObject * @return */ private static JSONObject packSendTemplate(String openId,String templateId,Map&lt;String,Object&gt; msgContentMap) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("touser",openId); jsonObject.put("template_id",templateId); JSONObject dataJSONObject = new JSONObject(); for (Map.Entry&lt;String,Object&gt; entry : msgContentMap.entrySet()) &#123; JSONObject tempContentJSONObject = new JSONObject(); tempContentJSONObject.put("value", entry.getValue()); tempContentJSONObject.put("color", "#173177"); dataJSONObject.put(entry.getKey(),tempContentJSONObject); &#125; jsonObject.put("data",dataJSONObject); return jsonObject; &#125;//没写测试代码，直接写了个main方法进行的测试 public static void main(String args[]) &#123; Map&lt;String,Object&gt; msgContentMap = new HashMap&lt;String,Object&gt;(); msgContentMap.put("first", "欢迎欢迎!"); msgContentMap.put("keyword1", "你好啊123123123"); msgContentMap.put("keyword2", "欢迎欢迎!"); msgContentMap.put("keyword3", "欢迎欢迎!"); msgContentMap.put("keyword4", "欢迎欢迎!"); msgContentMap.put("remark", "欢迎欢迎!"); sendTempleteMsg("openId","templateId",msgContentMap);//这个地方需要修改成用户对应的openId和你自己创建的模板ID &#125;&#125; 总结 WeChatCommon 一定要记住修改openId和templateId为自己的 accsee_token的有效时间目前为两小时 模板中的参数一定要和模板中的参数名字保持一致 生产环境模板一定要尽快申请，防止到时申请（审核时间比较长）不下来影响业务 目前是用项目全局上下文存储的access_token，如果有redis，可以存储在redis中，并设置时间有效]]></content>
      <categories>
        <category>后端插件</category>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信公众号</tag>
        <tag>模板消息发送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ExecutorService限制线程数量]]></title>
    <url>%2F2019%2F01%2F30%2FJava-ExecutorService%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[本文引自使用JAVA的ExecutorService来限制线程数量 前言目前对于线程的了解还是比较少，今天碰到一个使用微信公众号发送微信消息的功能，会出现批量发送的问题，如果排队执行，肯定会需要很长的时间，因此需要起线程执行，但是线程又不可能无限制的一直起，肯定会造成内存溢出类似的问题，因此想到了限制线程数量的方法。查阅了一些文章，提到了ExecutorService能够实现，因此进行了如下记录 概念ExecutorService是什么ExecutorService是Java并行运行的计算库java.util.concurrent包里面的接口，封装原来的难以使用的Java线程，使其简单优化 测试代码线程代码根据给定的生命周期，记录生命周期前后的时间点并输出信息123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.Calendar;public class SampleThread implements Runnable &#123; private int no; private int time; SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss"); SampleThread(int no, int time) &#123; this.no = no; this.time = time; &#125; @Override public void run() &#123; //开始执行，显示当前的时间，用于计算进程执行的生命周期 System.out.println("No." + no + " start ID:" + Thread.currentThread().getId() + " 生命周期:" + time + " 现在时间:" + sdf.format(Calendar.getInstance().getTime())); try &#123; Thread.sleep(time * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //执行完毕之后，打印执行结束时的时间 System.out.println("No." + no + " end ID:" + Thread.currentThread().getId() + " 生命周期:" + time + " 现在时间:" + sdf.format(Calendar.getInstance().getTime())); &#125;&#125; 使用ExecutorService调用线程的代码12345678910111213141516171819202122import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123; public static void main(String[] args) &#123; final int MAX_THREADS = 3; //定义线程数最大值 ExecutorService executorService = Executors.newFixedThreadPool(MAX_THREADS); for (int i = 0; i &lt; 10; i++) &#123; int no = i; //随机一个线程能活多少秒 int lifeTime = (int)(Math.random() * 9 + 1); //将线程提交到executorService中，等待执行 executorService.submit(new SampleThread(no, lifeTime)); &#125; System.out.println("executor.shutdown();"); executorService.shutdown(); &#125;&#125; 执行的结果12345678910111213141516171819202122executor.shutdown();No.0 start ID:13 生命周期:4 现在时间:21:52:46No.2 start ID:15 生命周期:4 现在时间:21:52:46No.1 start ID:14 生命周期:1 现在时间:21:52:46No.1 end ID:14 生命周期:1 现在时间:21:52:47No.3 start ID:14 生命周期:2 现在时间:21:52:47No.3 end ID:14 生命周期:2 现在时间:21:52:49No.4 start ID:14 生命周期:6 现在时间:21:52:49No.0 end ID:13 生命周期:4 现在时间:21:52:50No.5 start ID:13 生命周期:2 现在时间:21:52:50No.2 end ID:15 生命周期:4 现在时间:21:52:50No.6 start ID:15 生命周期:6 现在时间:21:52:50No.5 end ID:13 生命周期:2 现在时间:21:52:52No.7 start ID:13 生命周期:2 现在时间:21:52:52No.7 end ID:13 生命周期:2 现在时间:21:52:54No.8 start ID:13 生命周期:7 现在时间:21:52:54No.4 end ID:14 生命周期:6 现在时间:21:52:55No.9 start ID:14 生命周期:5 现在时间:21:52:55No.6 end ID:15 生命周期:6 现在时间:21:52:56No.9 end ID:14 生命周期:5 现在时间:21:53:00No.8 end ID:13 生命周期:7 现在时间:21:53:01Disconnected from the target VM, address: '127.0.0.1:14207', transport: 'socket' 总结 同一个时间点执行的线程数量不会超过MAX_THREAD所定义的数量 从线程的ID可以看出，只有三个线程在跑 有点没搞明白的是：ExecutorService已经在主线程里面调用了shutdown了，但是在子线程还能在正常调度的问题？？？]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程数量控制</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 创建多模块Maven项目]]></title>
    <url>%2F2019%2F01%2F30%2FIDEA-%E5%88%9B%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97Maven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建父模块 依次点击打开File-&gt;New-&gt;Project，具体操作见下图 打开创建项目对话框后，左侧选择Maven，右侧不勾选Create from archetype，然后点击Next，具体操作见下图 输入项目的信息，GroupId和ArtifactId，然后点击Next，具体操作见下图 直接点Next，直接到Finish，最后生成完成之后，删除src文件夹（因为这个是父级模块，因此不需要src文件夹），如下图所示： 创建核心子模块 右键父级模块，点击New-&gt;Module，打开新增Module界面，具体操作见下图： 左侧选择Maven，因为要创建一个普通项目，右侧同样不选择Create from archetype，然后点击Next，如下图所示： GroupId和version继承自父模块，不需要修改，只需要修改ArtifactId，点击Next 输入Module name，模块的名称可以和ArtifactId保持一致即可，具体操作见下图 创建完成后的结构图如下： 创建子模块 第一步和创建核心子模块一样，只是在打开New Module的时候，选上Create from archetype，并选中maven-archetype-webapp 一路点击下去，中间会有一个选择Maven的地方，选择你自己的Maven以及配置文件，然后点到最后，创建的项目路径如下图所示：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>SSM框架搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>搭建</tag>
        <tag>多模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遍历Map的方法]]></title>
    <url>%2F2019%2F01%2F30%2Fjava%E9%81%8D%E5%8E%86Map%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言遍历Map在Java中有好几种方式，但各自方式都有优缺点，不同的方式应用在不同的应用场景中 遍历方法keySet values在使用的过程中只是用到了Map的key或者value，这种是最简单的方式123456789101112// KeySet 获取keypublic void testKeySet() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key); &#125;&#125;// values 获取valuepublic void testValues() &#123; for (Integer value : map.values()) &#123; System.out.println(value); &#125;&#125; keySet get(key)(不推荐使用)如果同时需要key和value，可以先获取key，然后通过key获取到value，但这种方法不推荐使用12345public void testKeySetAndGetKey() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key + ":" + map.get(key)); &#125;&#125; entrySet通过map的entrySet进行遍历，是可以同时拿到key和value的，性能上更好一点，一般是用这种方式获取12345public void testEntry() &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ":" + entry.getValue()); &#125;&#125; IteratorIterator的优势是可以在遍历过程中删除元素123456789// Iterator entrySet 获取key and value public void testIterator() &#123; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + ":" + entry.getValue()); // it.remove(); 删除元素 &#125; &#125; Lambda Lambda是从java1.8开始支持的，语法更简洁，可以拿到key和value，但性能稍微低点 12345public void testLambda() &#123; map.forEach((key, value) -&gt; &#123; System.out.println(key + ":" + value); &#125;);&#125; 总结 单纯获取key或者value，使用keySet 需要同时获取key和value，使用entrySet 遍历过程中如果需要删除操作，使用Iterator 遍历过程中需要添加元素，可以新建一个临时map，遍历完成后，把临时map塞到最终map当中]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>遍历</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 读取和保存properties文件内容]]></title>
    <url>%2F2019%2F01%2F29%2FJava-%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98properties%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[前言最近做微信公众号，需要读取配置文件中的appId等信息，鄙人将这些固定的信息放进了properties文件里面，因此才用到了这块读操作，顺道也把写操作在网上查了下 Properties类Properties类和properties配置文件Properties类继承自Hashtable，并实现了Map的接口，也就是properties文件在Properties类中是以键值对存在的，而且值都是字符串 Properties类的主要的方法 load(InputStream inStream)以文件流的形式加载文件中的信息到Properties类中，具体的代码如下： 1234567Properties pro = new Properties();//文件流读取文件信息FileInputStream inStrem = new FileInputStream("a.properties");//加载数据到Properties类中pro.load(in);//关闭文件流in.close(); store(OutputStream out, String comments)将Properties类中的内容输出保存到properties文件当中，具体的代码如下： 123FileOutputStream outFile = new FileOutputStream("a.properties",true);pro.store(outFile,"Comments");outFile.close(); 如果comments不为空，保存后文件的第一行回事#comments，表示注释信息；如果为空则没有注释信息 getProperty/setProperty这两个方法分别是用来获取和设置properties文件的属性的 代码实例 a.properties文件的内容如下123name=rootpass=liukey=value 读取a.properties文件和生成b.properties文件1234567891011121314151617181920212223242526272829303132import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.util.Iterator;import java.util.Properties;public class PropertyTest &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); try&#123; //读取属性文件a.properties InputStream in = new BufferedInputStream (new FileInputStream("a.properties")); prop.load(in); ///加载属性列表 Iterator&lt;String&gt; it=prop.stringPropertyNames().iterator(); while(it.hasNext())&#123; String key=it.next(); System.out.println(key+":"+prop.getProperty(key)); &#125; in.close(); ///保存属性到b.properties文件 FileOutputStream oFile = new FileOutputStream("b.properties", true);//true表示追加打开 prop.setProperty("phone", "10086"); prop.store(oFile, "The New properties file"); oFile.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; ResourceBundle该类是基于类读取属性：将属性文件当做类，意味着属性文件必须放在包中，使用属性文件的权限定性类名而非路径1234567891011121314151617181920/** * 基于类读取属性文件：该方法将属性文件当作类来处理，属性文件放在包中，使用属性文件的全限定性而非路径来指代文件 */ @Test public void test02() &#123; ResourceBundle bundle = ResourceBundle.getBundle("com.javase.properties.test01"); System.out.println("获取指定key的值"); System.out.println("driver=" + bundle.getString("jdbc.driver")); System.out.println("url=" + bundle.getString("jdbc.url")); System.out.println("username=" + bundle.getString("jdbc.username")); System.out.println("password=" + bundle.getString("jdbc.password")); System.out.println("-----------------------------"); System.out.println("遍历属性文件"); Enumeration&lt;String&gt; keys = bundle.getKeys(); while (keys.hasMoreElements()) &#123; String key = keys.nextElement(); System.out.println(key + "=" + bundle.getString(key)); &#125; &#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>properties文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA2018搭建SSM框架（一）前期搭建]]></title>
    <url>%2F2019%2F01%2F28%2FIDEA2018%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E6%9C%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建环境说明 JDK1.8 IDEA 2018 Maven 3.5.3 搭建步骤1. 首先创建Maven webapp项目 2. 搭建项目结构 搭建完成的文件目录如下 建设完目录的过程中需要设置文件的类型为Source,Test,Resources,设置完成后的效果图如下： 3. 配置文件内容 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.chatRobot&lt;/groupId&gt; &lt;artifactId&gt;ChatRobot&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;ChatRobot Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ChatRobot&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 设置JDK版本 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 记得设置左下角的自动引入 logback.xml选择logback比log4j好，具体原因自己百度 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="true"&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;/root&gt;&lt;/configuration&gt; jdbc.properties 1234567891011121314151617jdbc.driver=com.mysql.jdbc.Driver#数据库地址jdbc.url=jdbc:mysql://xxxxxxxxx:3306/ChatRobot?useUnicode=true&amp;characterEncoding=utf8#用户名jdbc.username=xxxx#密码jdbc.password=xxxxx#最大连接数c3p0.maxPoolSize=30#最小连接数c3p0.minPoolSize=10#关闭连接后不自动commitc3p0.autoCommitOnClose=false#获取连接超时时间c3p0.checkoutTimeout=10000#当获取连接失败重试次数c3p0.acquireRetryAttempts=2 spring-mybatis.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=&quot;com.chatRobot.service&quot;/&gt; &lt;!-- 配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;c3p0.maxPoolSize&#125;&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;$&#123;c3p0.minPoolSize&#125;&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;$&#123;c3p0.autoCommitOnClose&#125;&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;$&#123;c3p0.checkoutTimeout&#125;&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;$&#123;c3p0.acquireRetryAttempts&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.chatRobot.model&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.chatRobot.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.chatRobot.controller&quot;/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;ChatRobot&lt;/display-name&gt; &lt;description&gt;ChatRobot_Alpha_0.0.1&lt;/description&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求，此处也可以配置成 *.do 形式 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 4. 测试 首先导入一份数据库测试文件 1234567891011121314CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;, `email` varchar(255) NOT NULL COMMENT &apos;用户邮箱&apos;, `password` varchar(255) NOT NULL COMMENT &apos;用户密码&apos;, `username` varchar(255) NOT NULL COMMENT &apos;用户昵称&apos;, `role` varchar(255) NOT NULL COMMENT &apos;用户身份&apos;, `status` int(1) NOT NULL COMMENT &apos;用户状态&apos;, `regTime` datetime NOT NULL COMMENT &apos;注册时间&apos;, `regIp` varchar(255) NOT NULL COMMENT &apos;注册IP&apos;, PRIMARY KEY (`id`), UNIQUE KEY `email` (`email`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO `user` VALUES (&apos;1&apos;, &apos;xxx&apos;, &apos;xxxxx&apos;, &apos;xxxxx&apos;, &apos;root&apos;, &apos;0&apos;, &apos;2017-03-28 09:40:31&apos;, &apos;127.0.0.1&apos;);SET FOREIGN_KEY_CHECKS=1; 创建类 UserController.java 123456789101112131415161718192021222324252627282930313233package com.chatRobot.controller;import javax.servlet.http.HttpServletRequest;import com.chatRobot.model.User;import com.chatRobot.service.IUserService;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controller@RequestMapping("/user")public class UserController &#123; @Resource private IUserService userService; @RequestMapping("/showUser.do") public void selectUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); long userId = Long.parseLong(request.getParameter("id")); User user = this.userService.selectUser(userId); ObjectMapper mapper = new ObjectMapper(); response.getWriter().write(mapper.writeValueAsString(user)); response.getWriter().close(); &#125;&#125; IUserDao.java 123456789package com.chatRobot.dao;import com.chatRobot.model.User;public interface IUserDao &#123; User selectUser(long id);&#125; User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.chatRobot.model;import java.util.Date;public class User &#123; private long id; private String email; private String password; private String username; private String role; private int status; private Date regTime; private String regIp; public long getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getRole() &#123; return role; &#125; public void setRole(String role) &#123; this.role = role; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public Date getRegTime() &#123; return regTime; &#125; public void setRegTime(Date regTime) &#123; this.regTime = regTime; &#125; public String getRegIp() &#123; return regIp; &#125; public void setRegIp(String regIp) &#123; this.regIp = regIp; &#125;&#125; IUserService.java 123456789package com.chatRobot.service;import com.chatRobot.model.User;public interface IUserService &#123; public User selectUser(long userId);&#125; UserServiceImpl.java 1234567891011121314151617181920package com.chatRobot.service.impl;import com.chatRobot.dao.IUserDao;import com.chatRobot.model.User;import com.chatRobot.service.IUserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service("userService")public class UserServiceImpl implements IUserService &#123; @Resource private IUserDao userDao; public User selectUser(long userId) &#123; return this.userDao.selectUser(userId); &#125;&#125; UserDao.xml 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置为IUserDao接口方法提供sql语句配置 --&gt;&lt;mapper namespace="com.chatRobot.dao.IUserDao"&gt; &lt;select id="selectUser" resultType="User" parameterType="long"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建测试类IUserDaoTest.java 12345678910111213141516171819202122232425package com.chatRobot.dao;import com.chatRobot.model.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;// 加载spring配置文件@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-mybatis.xml"&#125;)public class IUserDaoTest &#123; @Autowired private IUserDao dao; @Test public void testSelectUser() throws Exception &#123; long id = 1; User user = dao.selectUser(id); System.out.println(user.getUsername()); &#125;&#125; 运行测试类，会在控制台输出上面sql文件中用户的名字 继续新建个页面来测试springmvc和mybatis 创建测试类index.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;script&gt; function selectUser() &#123; var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; document.getElementById(&quot;test&quot;).innerHTML = xmlhttp.responseText; &#125; &#125; xmlhttp.open(&quot;POST&quot;, &quot;user/showUser.do&quot;, true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;id=1&quot;); &#125;&lt;/script&gt;&lt;body&gt;&lt;p id=&quot;test&quot;&gt;Hello World!&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;selectUser()&quot;&gt;onclick test&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 新建完成后配置项目运行环境，点击Run-Edit Configurations…点击加号新建运行环境，选择Tomcat Server-Local 选中新建好的服务器，右边选择Deployment,点击加号-Atifact… 选择第二项 然后在右边Application context配置你的项目名 最后运行项目，在打开的页面中点击按钮测试，成功的话会在页面上显示id为1的用户信息]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>SSM框架搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 返回Map类型key改为小写]]></title>
    <url>%2F2019%2F01%2F28%2Fmybatis-%E8%BF%94%E5%9B%9EMap%E7%B1%BB%E5%9E%8Bkey%E6%94%B9%E4%B8%BA%E5%B0%8F%E5%86%99%2F</url>
    <content type="text"><![CDATA[当使用mybatis查询数据库的时候，会出现查询出来的Map中字段都是大写的，需要进行处理，处理的方法如下 添加别名 别名上添加双引号，查询出来的就是小写了 demo 1234&lt;select id="getStudentList" resultType="java.util.Map"&gt;select t.name as "sName",t.sex as "sSex" from student&lt;/select&gt;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>MyBatis</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>大小写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架DDL操作数据库表]]></title>
    <url>%2F2019%2F01%2F28%2FSSM%E6%A1%86%E6%9E%B6DDL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[创建表123&lt;update id="createTableWithColumn" parameterType="pd"&gt; CREATE TABLE $&#123;MODULE_CODE&#125; ( $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125; ) TABLESPACE USR_XYD_TBS STORAGE ( INITIAL 64K MINEXTENTS 1 MAXEXTENTS UNLIMITED )&lt;/update&gt; 给表添加备注123&lt;update id=&quot;addCommentOnTable&quot; parameterType=&quot;pd&quot;&gt; COMMENT ON TABLE $&#123;MODULE_CODE&#125; IS &apos;$&#123;MODULE_NAME&#125;&apos;&lt;/update&gt; 插入字段123&lt;update id="addItemByDdl" parameterType="pd"&gt; ALTER TABLE $&#123;MODULE_CODE&#125; ADD $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125;&lt;/update&gt; 修改字段123&lt;update id=&quot;editColumnByDdl&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; MODIFY $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125;&lt;/update&gt; 删除字段给字段添加备注123&lt;update id="addCommentOnColumn" parameterType="pd"&gt; COMMENT ON COLUMN $&#123;TABLE_COLUMN&#125; IS '$&#123;ITEM_NAME&#125;'&lt;/update&gt; 添加主键123&lt;update id=&quot;addUniquesOnTable&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; ADD CONSTRAINT $&#123;KEY_NAME&#125; PRIMARY KEY ($&#123;ALL_UNIQUES&#125;)&lt;/update&gt; 删除表上已有的主键123&lt;update id=&quot;dropUniquesOnTable&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; DROP CONSTRAINT $&#123;EXIST_UNIQUES&#125; CASCADE&lt;/update&gt;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>DDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Java接口上传下载文件]]></title>
    <url>%2F2019%2F01%2F28%2F%E9%80%9A%E8%BF%87Java%E6%8E%A5%E5%8F%A3%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Java后台上传文件代码12345678910111213@RequestMapping(value = "/importUserInfo",method = RequestMethod.POST)@ResponseBodypublic JSONObject importUserInfo(@RequestParam String isUpdateFlag,HttpServletRequest request) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("code","-1"); //转换HttpServletRequest为MultipartHttpServletRequest MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; MultipartFile file = multipartRequest.getFile("Fdata"); String fileName = file.getOriginalFilename(); String fileType = fileName.substring(fileName.indexOf(".")); InputStream is = file.getInputStream();&#125; Java后台的接口代码如下12345678910111213141516171819202122@RequestMapping(value = "/downloadExcel",method = RequestMethod.GET)@ResponseBodypublic void downloadExcel(HttpServletRequest request,HttpServletResponse response) &#123; response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=userExcle.xlsx"); try &#123; String path=PathUtil.getClasspath()+"templete/xlsx/userExcle.xlsx"; InputStream inputStream = new FileInputStream(new File(path)); OutputStream os = response.getOutputStream(); byte[] b = new byte[2048]; int length; while ((length = inputStream.read(b)) &gt; 0) &#123; os.write(b, 0, length); &#125; os.close(); inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 前端的接口代码如下直接使用window打开一个新窗口进行下载就可以了，当然也可以通过指向隐藏div进行文件的下载1window.open('http://localhost:8080/MCSForOracle/userManage/downloadExcel');]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA15搭建Maven环境]]></title>
    <url>%2F2019%2F01%2F28%2FIDEA15%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[配置Maven软件配置一次即可，所有Maven项目共享 如上图标注3 选择自己的仓库 如上图标注 2 所示，Import Maven projects automatically 表示 IntelliJ IDEA 会实时监控项目的 pom.xml 文件，进行项目变动设置 如上图标注3 所示，在 Maven 导入依赖包的时候是否自动下载源码和文档。默认是没有勾选的，也不建议勾选，原因是这样可以加快项目从外网导入依赖包的速度，如果我们需要源码和文档的时 候我们到时候再针对某个依赖包进行联网下载即可。IntelliJ IDEA 支持直接从公网下载源码和文档的 上图标注 3 所示，可以设置导入的 VM 参数。一般这个都不需要主动改，除非项目真的导入太慢了我们再增大此参数 Maven 骨架创建 Java Web 项目 File -&gt; New -&gt; Project… 如下图 如下图，GroupId和ArtifactId&lt;项目名&gt;还有Version，这三个属性目的是标识你的项目的唯一性 如下图 如下图 点Finish之后，Maven会根据刚才的配置创建一个基于Maven的Web App 创建结束，其Log如下： 创建结束，其代码结构如下 recources文件夹：一般用来存放一些资源文件webapp文件夹：用来存放web配置文件以及jsp页面等，这已经组成了一个原始的web应用启动 Java Web 项目 打开“Project Structure” 配置“Facets” 配置“Artifacts” 启动“Edit Configurations” Add New ‘Tomcat Server’ 配置 配置Deplyment 配置Server 其结果如下 启动Web Server 现在可以通过Browser访问WebServer的页面了。]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>搭建</tag>
        <tag>Maven</tag>
        <tag>Idea15</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz集成SpringMVC 的方案]]></title>
    <url>%2F2019%2F01%2F26%2FQuartz%E9%9B%86%E6%88%90springMVC-%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[废话不说，直接上干货 引入Jar包第一步，首当其冲是引jar包，当然目前我还没把项目弄成maven的，所以也就只能自己copy个jar包到自己的lib包下面 下载quartz-2.2.1.jar 新建spring-quartz.xml第二步,新建一个spring-quartz.xml文件，文件的位置放在和spingMVC的配置文件同级目录即可，spring-quartz.xml可以配置多个任务，列如quartzJobA、quartzJobB，并配置对应的方法和时间表达式（什么时间执行），具体的任务怎么定时，怎么执行都在此文件中 spring-quartz.xml下载链接 修改web.xml第三步，将spring-quartz.xml添加到配置中，配置文件中只需要启动的时候加载上面提到spring-quartz.xml文件 具体使用第四步，具体在Java中的使用方法下载StatisticsTimer 注：cronExpression值有几种如下：123456789101112131415"0 0 12 * * ?" 每天中午12点触发"0 15 10 ? * *" 每天上午10:15触发"0 15 10 * * ?" 每天上午10:15触发"0 15 10 * * ? *" 每天上午10:15触发"0 15 10 * * ? 2005" 2005年的每天上午10:15触发"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发"0 15 10 15 * ?" 每月15日上午10:15触发"0 15 10 L * ?" 每月最后一日的上午10:15触发"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Quart定时器</category>
      </categories>
      <tags>
        <tag>定时器</tag>
        <tag>Quartz</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 Shiro授权]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-Shiro%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[授权，访问控制，在应用中控制哪些用户能够访问哪些资源（如页面/编辑数据/页面操作）。授权需要了解几个关键对象：主题（Subject）、资源（Resource）、权限（Permission）、角色（Role） 主体访问应用的用户。用户只有授权后才允许访问对应的资源 资源在应用中用户可以访问的任何东西，比如JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等都是资源。用户只有首选后才能访问。 权限安全策略中的原子授权单位。通过权限我们可以表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增删改查）式权限控制）打印文档等等 角色角色代表操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较访问。典型的如：项目经理，技术总监、CTO等等，不同的角色拥有不同的权限。 隐式角色直接通过角色来验证用户有没有操作权限，需要在代码中进行维护，比较麻烦，粒度较粗 显示角色在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设某个角色不能访问某个资源，只需要从角色对应的权限集合中移除即可；无须修改多出代码，即粒度是以资源/实例为单位的；粒度较细 授权方式Shiro支持三种方式的授权编程式：通过if/else授权代码块方式123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole("admin"))&#123; //有权限&#125;else&#123; //无权限&#125; 注解式：通过在执行的Java方法上防止相应的注解完成1234@RequiresRoles("admin")public void hello()&#123; //有权限&#125; 没有权限将抛出相应的异常JSP/GSP标签：在JSP/GSP页面通过相应的标签完成：123&lt;shiro:hasRole name="admin"&gt;&lt;!--有权限--&gt;&lt;/shiro:hasRole&gt; 后续部分将详细介绍如何使用 授权基于角色的访问控制（隐式角色）1、在ini配置文件配置用户拥有的角色（shiro-role.ini）123[users]zhang=123,role1.role2wang=123,role1 规则即：“用户名=密码,角色1,角色2”，如果需要在应用中判断用户是否拥有相应的角色，就需要在相应的Realm中返回角色信息，也就是说Shiro不负责维护用户-角色信息，需要应用提供，Shiro只是提供相应的接口方便验证，后续会介绍如何动态的获取用户角色。2、测试用例1234567891011121314151617181920212223242526/** * @ClassName RoleTest * @Description TODO * @Author zp * @Date 2018/11/615:11 * @Version 1.0 **/public class RoleTest extends BaseTest&#123; @Test public void testHasRole()&#123; login("classpath:shiro-role.ini","zhang","123"); //判断拥有角色：role1 Assert.assertTrue(subject().hasRole("role1")); //判断拥有角色：role1 and role2 Assert.assertTrue(subject().hasAllRoles(Arrays.asList("role1","role2"))); //判断拥有角色：role1 and role2 and !role3 boolean[] result = subject().hasRoles(Arrays.asList("role1","role2","role3")); Assert.assertEquals(true,result[0]); Assert.assertEquals(true,result[1]); Assert.assertEquals(false,result[2]); &#125;&#125; Shiro提供了hasRole/hasRoles用于判断用户是否拥有角色/某些权限；但是没有提供如hasAnyRole用于判断是否有某些权限中的一个。12345678@Test(expected = UnauthorizedException.class)public void testCheckRole() &#123; login("classpath:shiro-role.ini", "zhang", "123"); //断言拥有角色：role1 subject().checkRole("role1"); //断言拥有角色：role1 and role3 失败抛出异常 subject().checkRoles("role1", "role3");&#125; Shiro 提供的checkRole/checkRole和hasRole/hasAllRoles不同的地方是他在判断为假的情况下会抛出UnauthorizedException异常。到此基于角色的访问控制（隐式角色）就完成了，这种方式的缺点就是如果很多地方进行角判断，但是有一天不需要了，那么久需要修改相应代码把所有相关的地方进行删除，这就是粗粒度造成的问题。 基于资源的访问控制（显示角色）1、在ini配置文件配置用户拥有的角色角色-权限关系（shiro-permission.ini）12345678zhang=123,role1,role2wang=123,role1[roles]#对资源user拥有create、update权限role1=user:create,user:update#对资源user拥有create、delete权限role2=user:create,user:delete 规则：“用户名=密码，角色1，角色2” “角色=权限1，权限2”，即首先根据用户名找到角色，然后根据角色再找到权限；即角色时权限的集合；Shiro同样不进行权限的额维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户-角色”之间的关系即可。 2、测试用例1234567891011@Testpublic void testPermitted()&#123; login("classpath:shiro-permission.ini","zhang","123"); //判断拥有权限：user:create Assert.assertTrue(subject().isPermitted("user:create")); //判断拥有权限：user:update and user:delete Assert.assertTrue(subject().isPermittedAll("user:update","user:delete")); //断言没有权限user:view Assert.assertFalse(subject().isPermitted("user:view"));&#125; Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或者所有权限，也就是没有提供如isPermittedAny用于判断拥有某一个权限的接口12345678910111213@Test(expected = UnauthorizedException.class)public void testCHeckPermission()&#123; login("classpath:shiro-permission.ini","zhang","123"); subject().checkPermission("user:create"); subject().checkPermissions("user:delete","user:update"); try &#123; subject().checkPermissions("user:view"); &#125; catch (AuthorizationException e) &#123; e.printStackTrace(); &#125;&#125; 到此基于资源的访问控制（显示角色）就完成了，也就是基于权限的访问控制，这种方法一般规则是“资源标识符：操作”。即是资源级别的粒度；这种方式的好处是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户-角色，角色-权限（资源：操作）”之间的关系 Permission字符串通配符权限规则：“资源标识符：操作：对象实例ID”即对那个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“：”表示资源/操作/实例的分割；“，”表示操作的分割；“*”表示任意资源/操作/实例1、单个资源单个权限1subject().checkPermissions("system:user:update"); 拥护拥有资源“system:user”的update权限2、单个资源多个权限ini配置文件1role41=system:user:update,system:user:delete 通过如下代码进行判断1subject().checkPermissions("system:user:update","system:user:delete"); 用户拥有资源“system:user”的update和delete权限。如上可以简写成：ini配置文件（表示角色4拥有system:user资源的update和delete权限）1role42="system:user:update,delete" 接着可以通过如下代码判断：1subject().checkPermissions("system:user:update,delete"); 通过“system:user:update,delete”验证“system:user:update,system:user:delete”是没有问题的，但是反过来是规则不成立的。 3、单个资源全部权限ini配置1role51="system:user:create,update,delete,view" 然后通过如下代码判断1subject().checkPermissions("system:user:create,delete,update,view"); 用户拥有资源“system:user”的“create”、“update”、“delete”和“view”所有权限。如上可以简写成：ini配置文件（表示角色5拥有system:user的所有权限）1role52=system:user:* 也可以简写成（推荐上边的写法）：1role53=system:user 然后通过如下代码判断：12subject().checkPermissions("system:user:*");subject().checkPermissions("system:user"); 通过“system:user:*”验证“system:user:create,delete,update:view”可以，但是反过来是不成立的。 4、所有资源全部权限ini配置1role61=*:view 代码1subject().checkPermissions("user:view"); 用户拥有所有资源的“view”所有权限。假设判断的权限是“system:user:view”，那么需要“role5=::view”这样写才行。 5、实例级别的权限5.1、单个实例单个权限ini配置1role71=user:view:1 对资源user的1实例拥有view权限。通过下面的代码判断1subject().checkPermissions("user:view:1") 5.2、单个实例多个权限ini配置1role72=&quot;user:update,delete:1&quot; 对资源user的1实例拥有update、delete权限然后通过如下代码判断12subject().checkPermissions("user:delete,update:1");subject().checkPermissions("user:update:1","user:delete:1"); 5.3、单个实例所有权限ini配置1role73=user:*:1 对资源user的1实例拥有所有权限然后通过如下代码判断1subject().checkPermissions("user:update:1","user:delete:1","user:view:1"); 5.4、所有实例单个权限ini配置1role74=user:auth:* 对资源user的1实例拥有所有的权限然后通过如下代码判断：1subject().checkPermissions("user:auth:1","user:auth:2"); 5.5、所有实例所有权限ini配置1role75=user:*:* 对资源user的1实例拥有所有权限判断代码1subject().checkPermissions("user:view:1","user:auth:2"); 6、Shiro对权限字符串却是部分的处理如user:view等价于user:view:*；而organization等价于organization:*或者organization:*:*,这种方式实现了前缀匹配。另外如user:*可以匹配user:delete、user:delete可以匹配user:delete:1`user::1,可以匹配如user:view:1、user可以匹配user:view或user:view:1`等。即可以匹配所有，不加可以进行前缀匹配；但是如`:view不能匹配system:user:view，需要::view`，即后缀匹配必须制定前缀（多个冒号就需要多个来匹配）。7、WildcardPermission如下面两种方式是等价的：12subject().checkPermission("menu:view:1")subject.checkPermission(new WildcardPermission("menu:view:1")) 因此没什么必要的话使用字符串更方便。 8、性能问题通配符匹配方式比字符串相等的陪陪来说是更复杂，因此需要花费更长时间，但是一般系统的权限不会太多，且乐意配合缓存来提供其性能，如果这样性能还打不到要求我们可以实现操作算法实现吸能你更好的权限匹配。另外实力级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如sql查询时加上权限字符串之类的方式在查询时就完成权限匹配。 授权流程 流程如下：1、首先调用Subject.isPermitted*/hasROle*接口，其会委托给SecurityManager,而SecurityManager接着会委托给Authorizer;2、Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”),其首先会通过PermissionResolver把字符串转换成相应的Permission实例；3、在进行授权之前，其会调用相应的Real获取Subject相应的角色/权限用于匹配传入的角色/权限。4、Authorizer会判断Realm的角色/权限是否和传入的匹配，如果多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败 ModularRealmAuthorizer进行多Realm匹配流程：1、首先检查相应的Realm是否实现了Authorizer；2、如果实现了Authorizer，那么接着调用其他相应的isPermitted/hasRole接口进行匹配3、如果有一个Realm匹配那么僵返回true，否则返回false； 如果Realm进行授权的话，应该继承AuthorizingRealm，起流程是：1.1、如果调用hasRole*,则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可；1.2、首先调用如isPermitted(“user:view”),首先通过PermissionResolver，即转换为通配符的WildcardPermission；2、通过AuthoricationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo.getStringPermission得到字符串合并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）3、接着调用Permission.implies(Permission p )诸葛与传入的权限比较，如果有匹配的则返回true，否则返回false。 Authorizer、PermissionResolver及RolePermissionResolverAuthorizer的职责是进行授权（访问控制），是ShiroAPI中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其JavaDoc。SecurityManager集成了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例，而RolePermissionResolver用于根据角色解析相应的权限集合。我们可以通过如下ini配置更改Authorizer实现：12authorizer=org.apache.shiro.authz.ModularRealmAuthorizersecurityManager.authorizer=$authorizer 对于ModularRealmAuthorizer，相应的AuthorizingSecurityManager会在初始化完成后自动将相应的realm设置进去，我们也可以通过调用其setRealm()方法进行设置。对于实现自己的authorizer可以参考ModularRealmAuthorizer实现即可，再次不提供示例了。设置ModularRealmAuthorizer的permissionResolver，其会自动设置到相应的Realm上（其实现了PermissionResolverAware接口），如：12permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverauthorizer.permissionResolver=$permissionResolver 设置ModularRealmAuthorizer的rolePermissionResolver,其会自动设置到相应的Realm上（其实现了RolePermissionResolverAware接口），如：12rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolver 示例1、ini配置(shiro-authorizer.ini)12345678910111213141516[main]#自定义authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer#自定义permissionResolver#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverpermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver#自定义rolePermissionResolverrolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer#自定义realm 一定要放在securityManager.authorizer赋值之后（因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver）realm=com.github.zhangkaitao.shiro.chapter3.realm.MyRealmsecurityManager.realms=$realm 设置securityManager的realms一定要放在最后，因为在调用SecurityManager.setRealms的时候会将realms设置给authorizer，并为各个Realm设置permissionResolver和rolePermissionResolver。另外，不能使用IniSecurityManagerFactory创建IniRealm，因为其初始化顺序的问题可能会造成后续初始化Permission造成影响。 2、定义BitAndWildPermissionResolver及BitPermissionBitPermission用于实现位移方式权限，规则是：权限字符串格式：+资源字符串+权限位+实例ID；以+开头，中间通过+分割；权限：0表示所有权限；1表示新增（二级制0001）、2表示修改（二级制0010）、4删除（二进制0100）、8查看（二进制1000）；如+user+10表示对资源user拥有修改/查看权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.alibaba.druid.util.StringUtils;import org.apache.shiro.authz.Permission;/** * @ClassName BitPermission * @Description TODO * @Author zp * @Date 2018/11/2716:46 * @Version 1.0 **/public class BitPermission implements Permission &#123; private String resourceIdentify; private int permissionBit; private String instanceId; public BitPermission(String permissionString) &#123; String[] array = permissionString.split("\\+"); if(array.length &gt; 1) &#123; resourceIdentify = array[1]; &#125; if(StringUtils.isEmpty(resourceIdentify)) &#123; resourceIdentify = "*"; &#125; if(array.length &gt; 2) &#123; permissionBit = Integer.valueOf(array[2]); &#125; if(array.length &gt; 3) &#123; instanceId = array[3]; &#125; if(StringUtils.isEmpty(instanceId)) &#123; instanceId = "*"; &#125; &#125; public boolean implies(Permission p) &#123; if(!(p instanceof BitPermission)) &#123; return false; &#125; BitPermission other = (BitPermission) p; if(!("*".equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123; return false; &#125; if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123; return false; &#125; if(!("*".equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123; return false; &#125; return true; &#125; public String toString() &#123; return "BitPermission&#123;" + "resourceIdentify='" + resourceIdentify + '\'' + ", permissionBit=" + permissionBit + ", instanceId='" + instanceId + '\'' + '&#125;'; &#125;&#125; Permission接口提供了boolean implies(Permission p)方法，用于判断权限匹配的123456789101112131415161718192021import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.permission.PermissionResolver;import org.apache.shiro.authz.permission.WildcardPermission;/** * @ClassName BitAndWildPermissionResolver * @Description TODO * @Author zp * @Date 2018/11/2716:49 * @Version 1.0 **/public class BitAndWildPermissionResolver implements PermissionResolver &#123; public Permission resolvePermission(String s) &#123; if(s.startsWith("+"))&#123; return new BitPermission(s); &#125; return new WildcardPermission(s); &#125;&#125; BitAndWildPermissionResolver实现了PermissionResolver接口，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission 3、定义MyRolePermissionResolverPermissionResolver用于根据角色字符串来解析得到权限集合12345678910111213141516171819202122import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.permission.RolePermissionResolver;import org.apache.shiro.authz.permission.WildcardPermission;import java.util.Arrays;import java.util.Collection;/** * @ClassName MyRolePermissionResolver * @Description TODO * @Author zp * @Date 2018/11/2716:53 * @Version 1.0 **/public class MyRolePermissionResolver implements RolePermissionResolver &#123; public Collection&lt;Permission&gt; resolvePermissionsInRole(String s) &#123; if("role1".equals(s))&#123; return Arrays.asList((Permission)new WildcardPermission("menu:*")); &#125; return null; &#125;&#125; 此处的逻辑很简单，如果用户拥有role1，那么就返回“menu:*”的权限4、自定义Realm1234567891011121314151617181920212223242526272829303132333435363738394041import com.smartcore.permission.BitPermission;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.authz.permission.WildcardPermission;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @ClassName MyRealm * @Description TODO * @Author zp * @Date 2018/11/2716:43 * @Version 1.0 **/public class MyRealm extends AuthorizingRealm &#123; protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRole("role1"); authorizationInfo.addRole("role2"); authorizationInfo.addObjectPermission(new BitPermission("+user1+10")); authorizationInfo.addObjectPermission(new WildcardPermission("user1:*")); authorizationInfo.addStringPermission("+user2+10"); authorizationInfo.addStringPermission("user2:*"); return authorizationInfo; &#125; protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String username = (String)token.getPrincipal(); //得到用户名 String password = new String((char[])token.getCredentials()); //得到密码 if(!"zhang".equals(username)) &#123; throw new UnknownAccountException(); //如果用户名错误 &#125; if(!"123".equals(password)) &#123; throw new IncorrectCredentialsException(); //如果密码错误 &#125; //如果身份认证验证成功，返回一个AuthenticationInfo实现； return new SimpleAuthenticationInfo(username, password, getName()); &#125;&#125; 此时我们继承 AuthorizingRealm而不是实现Realm接口；推荐使用 AuthorizingRealm ，因为： AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)：表示获取身份验证信息 AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)：表示根据用户身份获取身份信息这种方式的好处是当需要身份验证时只需要获取身份验证信息而不需要获取授权信息。另外我们还可以使用JdbcRealm，需要如下操作： 执行 sql/ shiro-init-data.sql 插入相关的权限数据 使用shiro-jdbc-authorizer.ini 的配置文件，需要设置jdbcRealm.permissionsLookupEnabled为true来开启权限查询 此次还要注意就是不能把我们自定义的如“+user+10”配置到ini文件中即使有IniRealm完成，IniRealm在new完成后就会解析这些权限字符串，默认使用WildCardPermissionResolver，即此处是一个设计权限，如果采用生命周期（如使用初始化方法）的方式进行加载就可以解决我们自定义permissionResolver的问题。5、测试用例123456789101112131415161718192021222324252627282930import org.junit.Assert;import org.junit.Test;/** * @ClassName AuthorizerTest * @Description TODO * @Author zp * @Date 2018/11/288:47 * @Version 1.0 **/public class AuthorizerTest extends BaseTest&#123; @Test public void testIsPermitted()&#123; login("classpath:shiro-authorizer.ini", "zhang", "123"); //判断拥有权限：user:create Assert.assertTrue(subject().isPermitted("user1:update")); Assert.assertTrue(subject().isPermitted("user2:update")); //通过二级制方式表示权限 Assert.assertTrue(subject().isPermitted("+user1+2"));//新增权限 Assert.assertTrue(subject().isPermitted("+user1+8"));//查看权限 Assert.assertTrue(subject().isPermitted("+user2+10"));//新增及查看权限 Assert.assertTrue(subject().isPermitted("+user1+4"));//没有删除权限 Assert.assertTrue(subject().isPermitted("menu:view"));//通过MyRolePermissionResolver解析得到权限 &#125;&#125; 通过上面的步骤可以实现自定义验证了。另外因为不支持hasAnyRole/isPermittedAny这种方法的授权，可以参考shiro扩展实现NOT、AND、OR权限验证进行简单的扩展完成这个需求，在这篇文章中通过重写 AuthorizingRealm 里面的验证逻辑实现的。 本章节亮点BaseTest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.apache.shiro.util.ThreadContext;import org.junit.After;/** * @ClassName BaseTest * @Description TODO * @Author zp * @Date 2018/11/615:20 * @Version 1.0 **/public abstract class BaseTest &#123; @After public void tearDown() throws Exception &#123; ThreadContext.unbindSubject();//退出时请解除绑定Subject到线程 否则对下次测试造成影响 &#125; protected void login(String configFile,String username,String password)&#123; Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(configFile); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; &#125; public Subject subject() &#123; return SecurityUtils.getSubject(); &#125;&#125;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 身份认证]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[身份认证: 在应用中证明自己是谁；一般提供用户自己的ID证明自己是谁，比如用户名和密码在Shiro中，用户需要提供principals(身份)和credentials（证明）给shiro，从而验证用户的身份principals: 身份，主体的标识属性，可以是任何东西：邮箱，用户名等等，但必须唯一。一个主体可以有多个principals，但只有一个Primary principalscredentials: 证明，凭据，即主体对应的安全值，如密码/数字证书等。 环境准备Maven配置1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0-RC2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 登录/退出 用户身份凭据（shior.ini）在shiro-test\src\test\resources下创建文件shiro.ini，用来保存用户信息,通过[users]制定了两个主体 123[users]zhang=123wang=123 测试用例 123456789101112131415161718192021222324252627282930313233343536373839import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Assert;import org.junit.Test;public class LoginLogoutTest &#123; @Test public void testHelloworld()&#123; //1、获取SecurityManager工厂，此处使用ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro.ini"); //2、得到SecurityManager实例 并绑定SecurityUtil org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（用户身份证/凭据） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; //4、登录，即身份验证成功 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份认证失败 e.printStackTrace(); &#125; Assert.assertEquals(true,subject.isAuthenticated());//断言用户已经登录 //6、退出 subject.logout(); &#125;&#125; 代码解析 1、首先通过new IniSecurityManagerFactory并制定一个ini文件来创建一个SecurityManager工厂；2、接着获取SecurityManager并绑定到SecurityUtils, 这是一个全局设置，设置一次即可3、通过SecurityUtil得到Subject,其会自动绑定到当前线程；如果web环境在请求结束，需要解除绑定；然后获取身份认证的Token，如用户名/密码4、调用subject.log方法进行登录，其会自动委托给SecurityManager.login方法进行登录5、如果身份验证失败请捕获AuthenticationException或其子类，常见如：DiabledAccountExceprion(禁用的账号)、LockedAccountException(锁定的账号)、UnKnownAccountException（未知的账号）、、ExcessiveAttemptsException(登录失败次数过多)、IncorrectCredentialsException（错误凭证）、ExpiredCredentialsException(过期凭证)，对于错误消息的展示，最好使用“用户名或密码不正确”，防止提示太过详细，容易出现恶意扫描账号6、最后可以调用subject.logout退出如上代码可总结出身份验证的步骤：1、收集用户身份凭据，如用户名和密码2、调用Subject.login()进行登录，如果失败，得到相应的AuthenticationException异常；否则登录成功3、调用Subject.logout进行退出操作 身份认证的流程 首先调用Subject.login(token)进行登录，其会自动委托给SecurityManager，调用之前必须通过SecurityUtil.setSecurityManger()设置 SecurityManager负责真正的身份验证逻辑；他会委托给Authenticator进行身份验证 Authenticator才是真正的身份验证者， 可以自定义自己的实现 Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator 会把相应的token传入Realm，从Realm中获取身份验证信息，如果没有返回或者抛出异常表明身份验证失败。可以自定义多个Realm，将按照相应的顺序和策略进行访问 RealmRealm： 域,Shiro从Realm中获取安全数据（用户、角色、权限），可以理解为Realm是DataSource，安全数据源，如上面配置的ini文件使用的org.apache.shiro.realm.text.IniRealm org.apache.shiro.realm.Realm接口如下1234String getName();//返回一个唯一的Realm的名字boolean supports(AuthenticationToken token)//判断此Realm是否支持此TokenAuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;//根据Token获取认证信息 单Realm配置 自定义Realm实现 123456789101112131415161718192021222324252627import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;public class MyRealm1 implements Realm &#123; public String getName() &#123; return "myrealm1"; &#125; public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken;//仅支持UsernamePasswordToken类型的Token &#125; public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials());//得到密码 if(!"zhang".equals(userName))&#123; throw new UnknownAccountException();//用户名错误 &#125; if(!"123".equals(password))&#123; throw new IncorrectCredentialsException();//密码错误 &#125; return new SimpleAuthenticationInfo(userName,password,getName()); &#125;&#125; ini配置文件指定自定义的Realm（shiro-realm.ini） 1234# 声明一个realmmyRealm1=com.shirotest.realm.MyRealm1# 指定securityManager的realms实现securityManager.realms=$myRealm1 测试代码 123456789101112131415161718192021222324252627@Testpublic void testCustomRealm()&#123; //1、获取SecurityManager工厂，此处使用ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;); //2、得到SecurityManager实例，绑定SecurityUtil SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名和密码对应的Token Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;); try &#123; //4、登录，即身份验证成功 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份认证失败 e.printStackTrace(); &#125; Assert.assertEquals(true,subject.isAuthenticated());//断言用户已经登录 //6、退出 subject.logout();&#125; 多Realm实现1、myRealm2代码12345678910111213141516171819202122232425262728293031import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;public class MyRealm2 implements Realm &#123; @Override public String getName() &#123; return &quot;myrealm2&quot;; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials()); if(!&quot;wang&quot;.equals(userName))&#123; throw new UnknownAccountException();//账号错误 &#125; if(!&quot;123&quot;.equals(password))&#123; throw new IncorrectCredentialsException();//密码错误 &#125; //如果认证通过，返回一个AuthenticationInfo实现 return new SimpleAuthenticationInfo(userName,password,getName()); &#125;&#125; 2、ini配置文件（shiro-multi-realm.ini）12345# 声明一个realmmyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2# 指定securityManager的realms实现securityManager.realms=$myRealm1,$myRealm2 security按照realm指定的顺序进行身份认证。 此处我们使用显示指定顺序的方式指定了Realm的顺序，如果删除掉securityManager.realms=$myRealm1,$myRealm2，那么securityManager会按照realm声明的顺序进行使用（即无需声明顺序，系统会自动查找Realm），当我们显示指定realm后，其他没有指定的realm会被忽略，如securityManager.realms=$myRealm1,myRealm2会被自动忽略 3、测试代码12345678910111213141516171819@Testpublic void testCustomMultiRealm()&#123; Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro-multi-realm.ini"); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; subject.logout();&#125; Shiro默认提供的Realm 以后一般集成AuthorizingRealm(授权)即可；其集成了AuthenticatingRealm（即身份认证），而且间接集成了CachingRealm(带缓存实现)。其中主要默认实现如下：org.apache.shiro.realm.text.IniRealm: [users]部分指定用户名/密码及对应角色；[roles]部分指定角色即角色授权信息；org.apache.shiro.realm.text.PropertiesRealm: user.username=password,role1,role2指定用户/密码及角色；role.role1=permission1,permission2指定角色对应即权限；org.apache.shiro.realm.jdbc.JdbcRealm:通过sql查询相应的信息，如select password from users where username = ? 获取用户密码;select password,password_salt from users where username = ?获取用户密码及盐；select permission from role_permissions where role_name = ?获取角色对应权限；也可以调用相应的api进行自定义sql； JDBC Realm使用1、数据库及依赖(pom.xml)12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0-RC2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、数据库shiro创建三张表：users（用户名/密码）、user_roles(用户/角色)、roles_permissions(角色权限)，并添加一个用户名/密码为zhang/123;123456789101112131415161718192021222324252627282930drop database if exists shiro;create database shiro;use shiro;create table users ( id bigint auto_increment, username varchar(100), password varchar(100), password_salt varchar(100), constraint pk_users primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_users_username on users(username);create table user_roles( id bigint auto_increment, username varchar(100), role_name varchar(100), constraint pk_user_roles primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_user_roles on user_roles(username, role_name);create table roles_permissions( id bigint auto_increment, role_name varchar(100), permission varchar(100), constraint pk_roles_permissions primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_roles_permissions on roles_permissions(role_name, permission);insert into users(username,password)values('zhang','123'); 3、ini配置（shiro-jdbc.realm.ini）123456789[main]jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://192.168.2.62:3306/shirodataSource.username=rootdataSource.password=mcprdjdbcRealm.dataSource=$dataSourcesecurityManager.realms=$jdbcRealm Authenticator及AuthenticationStrategyAuthenticator的职责是验证用户账号，是Shiro API中身份验证核心的入口点：1public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException 如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败抛出相应的AuthenticationException实现。SecurityManager接口集成了Authenticator，另外还有一个ModularRealAuthenticator实现，其委托了多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：FirstSuccessfulStrategy：只要有一个Realm验证通过即可，只返回第一个Realm身份验证成功的认证信息，其他忽略AtLeastOneSuccessfulStrategy:只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同点载于，返回所有Realm身份验证成功的认证信息AllSuccessfulStrategy:所有Realm验证成功，且返回所有的Realm验证成功信息，如果有一个失败就整个失败。 ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。假设有三个Realm： myRealm1：用户名和密码分别为zhang/123的时候登录成功，并返回登录信息zhang/123 myRealm2：用户名和密码分别为wang/123的时候登录成功，并返回登录信息wang/123 myRealm3：用户名和密码分别为zhang/123的时候登录成功，并返回登录信息zhang@163.com/123myRealm3和myRealm1基本上一样，但是返回时的身份变了 1、ini配置文件（shiro-authenticator-all-success.ini）12345678910111213[main]# 指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator# 指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2myRealm3=com.shirotest.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3 2、MyRealm3的代码12345678910111213141516171819202122232425262728293031323334353637import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;/** * @ClassName MyRealm3 * @Description TODO * @Author zp * @Date 2018/11/313:47 * @Version 1.0 **/public class MyRealm3 implements Realm &#123; @Override public String getName() &#123; return "myrealm3"; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials()); if(!"zhang".equals(userName))&#123; throw new UnknownAccountException(); &#125; if(!"123".equals(password))&#123; throw new IncorrectCredentialsException(); &#125; return new SimpleAuthenticationInfo(userName+"@163.com",password,getName()); &#125;&#125; 3、测试代码3.1、测试全部验证成功并返回多条成功验证结果记录（ AllSuccessfulStrategy ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Assert;import org.junit.Test;/** * @ClassName AuthenticatorTest * @Description TODO * @Author zp * @Date 2018/11/313:59 * @Version 1.0 **/public class AuthenticatorTest &#123; @Test public void testAllSuccessfulStrategyWithSuccess()&#123; login("shiro-authenticator-all-success.ini"); Subject subject = SecurityUtils.getSubject(); //得到一个身份集合，其包含了Realm验证成功的身份信息 PrincipalCollection principalCollection = subject.getPrincipals(); Assert.assertEquals(2,principalCollection.asList().size()); &#125; /** *@Description 常规测试登录代码 *@param [configFile] *@return void *@author zp *@date 2018/11/3 15:56 **/ private void login(String configFile)&#123; Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:"+configFile); org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); subject.login(token); &#125;&#125; 3.2、测试不能通过所有验证，返回失败代码（AllSuccessfulStrategy）12345678910111213[main]# 指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator#指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2myRealm3=com.shirotest.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm2 1234@Test(expected = UnknownAccountException.class)public void testAllSucessfulStrategyWithFail()&#123; login("shior-authenticator-all-fail.ini");&#125; shiro-authenticator-all-fail.ini 与 shiro-authenticator-all-success.ini不同的配置是使用了securityManager.realms=$myRealm1,$myRealm2；即myRealm2验证失败。 对于AtLeastOneSuccessfulStrategy和FirstSuccessfulStrategy的区别，在与第一个是至少有一个满足就可以验证通过，第二个是只要找到一个就可以通过验证，并且返回第一个验证通过的Realm信息。 自定义AuthenticationStrategy实现：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 Shiro简介]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Shiro%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介 Shiro不仅可以应用在JavaSE环境，也可以用在JavaEE环境。 Shiro能够完成的任务： 认证 授权 加密 会话管理 Web集成 缓存 Authentication:身份认证/登录，验证用户是否拥有相应的身份 Authorization:授权，权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户是否对某个资源是否具有某个权限 Session Manager:会话管理，用户登录后就是一次会话，在没有退出之前，他的所有信息都会在会话中 Cryptography:加密，保护数据的安全性，如密码加密存储到数据库，而不是铭文存储 Web Support:Web支持，可以非常容易的集成到Web环境 Caching:缓存，比如用户登录后，其用户信息，拥有的角色/授权信息不必每次去查询，这样可以提高效率 Concurrency:shiro支持多线程应用的并发验证，即如果在一个线程中开一另一个线程，能够把权限自动传播过去 Testing:提供测试支持 Run As:允许一个用户假装为另一个用户的身份访问 Remember Me:记住我，下次再来不用登陆了 Shiro是不会去维护权限、用户的数据的；这些需要我们自己去设计/提供；然后通过相应的接口注入到Shiro 从上图可以看出应用程序代码直接交互的对象是Subject，也就是Shiro的对外核心API是Subject： Subject:主体，代表当前用户，不一定是具体的人，与当前应用交互的所有对象都可以使Subject；所有的Subject都是绑定到SecurityManager的，也就是最终干活的都是SecurityManager，Subject只是一个门面 SecurityManager:安全管理器，所有与安全有关的操作都会与SecurityManager交互，而且它管理着所有的Subject。它同时负责着与后面其他的组件的交互。 Realm:域，Shiro从Realm获取安全数据（用户，角色，权限）；SecurityManager验证用户的时候，需要从Realm中读取数据，验证用户数据的合法性，同时还需要从Realm中读取用户的权限和角色验证用户是否能够操作。简单的来说可以从认为Realm为一个DataSource，即安全数据源 最简单的Shiro应用设计思路： 应用通过Subject来进行认证和授权，而Subject委托给SecurityManager进行处理 我们需要给SecurityManager注入Realm，从而让SecurityManager获取到相应的用户及权限进行判断 Subject:主体，可以看到主体是任何可以与应用交互的“用户” SecurityManager:Shiro的心脏，具体的交互都通过Securitymanager进行控制；管理所有的Subject，进行权限、授权、会话及缓存的管理 Authenticator:认证器，负责主体认证，可自定义实现；其需认证策略（Authentication Strategy），即什么情况下算是用户通过了 Authrizer:授权器，用来决定主体是否有权限进行相应的操作 Realm:可以有一个或者多个，安全实体数据源，用于获取安全实体，一般是自己实现Realm SessionManager:Session的管理组件，可以通过专门的Session管理服务器实现分布式会话 SessionDao:当需要把Session存储到数据库的时候使用的工具 CacheManager:缓存控制器，来管理用户、角色、权限的缓存 Cryptograpy:密码模块，Shiro提供了一些常见的加密组件用于密码加密和解密]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS正则表达式校验手机号、邮箱、网址、日期、身份证]]></title>
    <url>%2F2019%2F01%2F25%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%A1%E9%AA%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%E3%80%81%E9%82%AE%E7%AE%B1%E3%80%81%E7%BD%91%E5%9D%80%E3%80%81%E6%97%A5%E6%9C%9F%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%2F</url>
    <content type="text"><![CDATA[常规正则表达式1234567891011121314151617181920212223验证手机号：/^1\d&#123;10&#125;$/验证邮箱：/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/验证url：/(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/日期：/^(\d&#123;4&#125;)[-\/](\d&#123;1&#125;|0\d&#123;1&#125;|1[0-2])([-\/](\d&#123;1&#125;|0\d&#123;1&#125;|[1-2][0-9]|3[0-1]))*$/证身份证：/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(x|X|\d)$)/中文：[\u4e00-\u9fa5]电话号码（国内）：[0-9-()（）]&#123;7,18&#125;邮政编码：\d&#123;6&#125;IP地址：(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)正整数：[1-9]\d*负整数：-[1-9]\d*用户名：[A-Za-z0-9_\-\u4e00-\u9fa5]+ 使用方法12345var reg=/(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/;if(!reg.test(data.field.link))&#123; layer.msg(&apos;外链格式错误，请输入以http://或https://开头的完整url！&apos;,&#123;icon: 5&#125;); return false;&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>正则校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Url中传递JSONObject、JSONArray对象]]></title>
    <url>%2F2019%2F01%2F25%2FUrl%E4%B8%AD%E4%BC%A0%E9%80%92JSONObject%E3%80%81JSONArray%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Url中传递JSONObject 首先说明下项目背景，要求用layer.open打开一个页面，但是传递的主键字段是不确定的，因此需要组装一个JSONObject，里面放入动态的主键，从而让后台通过JSON遍历得到主键，然后进行数据的查询 首先想到的是通过JSON.stringify()方法(不可行)但是发现上面的思路是不可行的，以为会出现json中的双引号，造成只能传递一个{到后台，不能传递整个JSON 第二种方法是使用encodeURI()方法(可行)12345678layer.open(&#123; 'title': '编辑数据', // 弹出框标题 'shade': [0.8, '#393D49'], // 遮盖罩 'type': 2, // 打开类型 'area': ['80%', '80%'], // 弹出框大小 'maxmin': true, // 最大化 content: basePath + 'customManage/openListChildPage.do?TYPE_ID='+ encodeURI(jsonObj) &#125;); 多扯两句，关于ajax传递json对象到后台的问题这个问题相对简单，是可以直接使用ajax的data内置参数，直接传递json对象到后台的]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSONObject</tag>
        <tag>JSONArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS setInterval()方法]]></title>
    <url>%2F2019%2F01%2F25%2FJS-setInterval-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[定义和用法setInterval是按照指定周期（毫秒）调用函数或计算表达式，会不停的调用函数，直到调用clearInterval或者窗口关闭。其中setinterval返回的ID可以用作clearInterval方法的参数 语法1setInterval(code,millisec[,"lang"]) 参数 是否必须 描述 code 是 循环调用的代码或者需要执行的代码穿 millisec 是 执行的周期，毫秒为单位 返回值可以用作clearInterval()从而取消code循环执行的ID 实例123456789101112131415161718&lt;html&gt;&lt;body&gt;&lt;input type="text" id="clock" size="35" /&gt;&lt;script language=javascript&gt;var int=self.setInterval("clock()",50)function clock() &#123; var t=new Date() document.getElementById("clock").value=t &#125;&lt;/script&gt;&lt;/form&gt;&lt;button onclick="int=window.clearInterval(int)"&gt;Stop interval&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>setInterval</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS字符串转JSON对象]]></title>
    <url>%2F2019%2F01%2F25%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACJSON%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS字符串转换成JSON对象目前发现了四种方法 1. Jquery方法示例代码:123//将json字符串转换成json对象$.parseJSON(jsonStr);jQuery.parseJSON(jsonStr) 2. 浏览器支持转换的方法（Firefox、Chrome、opera、safari、ie）1JSON.parse(jsonstr)//可以将json字符串转换成json对象 1JSON.stringify(jsonOjb)//可以将JSONObject转换成json字符串 3. Javascript支持的转换方式（不建议）1eval(&apos;(&apos; + jsonstr + &apos;)&apos;); 4. JSON官方的转换方式JSON官网提供的Github上的关于JSON转换的方法 当然还有很多方法，在官网下面有很多各个语言的处理方法，具体的链接可以查看]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态创建a标签并添加事件]]></title>
    <url>%2F2019%2F01%2F25%2Fjs%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAa%E6%A0%87%E7%AD%BE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目中有一个新需求，前后台分离，然后前台需要拿到数据后动态的创建a标签，并且给a标签上添加上事件，而且事件的参数是不一样的 下面是一种方法，可以尝试下12345678910111213for(var i=0;i &lt; datalist.length;i++)&#123; (function(i)&#123; var a=document.createElement('a'); var innerText = datalist[i].DOC_NAME a.innerHTML=innerText; a.addEventListener('click',function(e)&#123; e.preventDefault(); //取消默认事件，指a标签 alert(121); &#125;); $("#all-items").append(a); &#125;)(i);&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>动态添加事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webuploader同一页面多实例上传图片及回显]]></title>
    <url>%2F2019%2F01%2F25%2Fwebuploader%E5%90%8C%E4%B8%80%E9%A1%B5%E9%9D%A2%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%8F%8A%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[1. 业务页面JSP(goods_detail_edit.jsp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;overview &amp; stats&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;link href=&quot;static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;static/css/bootstrap-responsive.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/font-awesome.min.css&quot; /&gt;&lt;!-- 下拉框 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/chosen.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace-responsive.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace-skins.min.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;!--提示框--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery.tips.js&quot;&gt;&lt;/script&gt;&lt;!-- 上传图片 --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;plugins/webuploader/webuploader.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;plugins/webuploader/style.css&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;td input &#123; width: 97%;&#125;tr th &#123; font-size: 13px; font-weight: bold; vertical-align: middle;&#125;#wrapper &#123; margin: 0;&#125;#uploader .placeholder &#123; background: url(plugins/webuploader/image.png) center 23px no-repeat; padding-top: 88px; min-height: 110px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;goodsDetail/$&#123;msg &#125;.do&quot; name=&quot;goodsForm&quot; id=&quot;goodsForm&quot; method=&quot;post&quot;&gt; &lt;div id=&quot;zhongxin&quot;&gt; &lt;table id=&quot;table_report&quot; class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品编码:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;hidden&quot; id=&quot;checkGoodsCode&quot; value=&quot;$&#123;pd.goods_code&#125;&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;GOODS_CODE&quot; id=&quot;GOODS_CODE&quot; value=&quot;$&#123;pd.goods_code&#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入商品编码&quot; title=&quot;商品编码&quot; onblur=&quot;checkHasCode()&quot; /&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品类型:&lt;/th&gt; &lt;td&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;GOODS_TYPE&quot; id=&quot;GOODS_TYPE&quot; data-placeholder=&quot;请选择商品类型&quot; style=&quot;vertical-align:top;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;cateGoryList&#125;&quot; var=&quot;cateGory&quot;&gt; &lt;option value=&quot;$&#123;cateGory.GOODS_TYPE&#125;&quot; &lt;c:if test=&quot;$&#123;pd.goods_type==cateGory.GOODS_TYPE&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;$&#123;cateGory.DESCRIPTION &#125; &lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品名称:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;GOODS_NAME&quot; id=&quot;GOODS_NAME&quot; value=&quot;$&#123;pd.goods_name &#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入商品名称&quot; title=&quot;商品名称&quot; /&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品别名:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;GOODS_ABBR_NAME&quot; id=&quot;GOODS_ABBR_NAME&quot; value=&quot;$&#123;pd.goods_abbr_name &#125;&quot; maxlength=&quot;64&quot; placeholder=&quot;请输入商品别名&quot; title=&quot;商品别名&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;特殊商品:&lt;/th&gt; &lt;td style=&quot;vertical-align:top;&quot;&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;IS_SPECIAL&quot; id=&quot;IS_SPECIAL&quot; data-placeholder=&quot;是否特殊商品&quot; style=&quot;vertical-align:top;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Y&quot; &lt;c:if test=&quot;$&#123;pd.is_special==&apos;Y&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;特殊商品&lt;/option&gt; &lt;option value=&quot;N&quot; &lt;c:if test=&quot;$&#123;pd.is_special==&apos;N&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;非特殊商品&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;是否有效:&lt;/th&gt; &lt;td style=&quot;vertical-align:top;&quot;&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;IS_VALID&quot; id=&quot;IS_VALID&quot; data-placeholder=&quot;是否有效&quot; style=&quot;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Y&quot; &lt;c:if test=&quot;$&#123;pd.is_valid==&apos;Y&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;有效&lt;/option&gt; &lt;option value=&quot;N&quot; &lt;c:if test=&quot;$&#123;pd.is_valid==&apos;N&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;无效&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;菜单编码:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;MENU_CODE&quot; id=&quot;MENU_CODE&quot; value=&quot;$&#123;pd.menu_code &#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入菜单编码&quot; title=&quot;菜单编码&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;textarea name=&quot;GOODS_DESC&quot; id=&quot;GOODS_DESC&quot; rows=&quot;5&quot; cols=&quot;50&quot; style=&quot;width:99%;&quot; placeholder=&quot;请选输入商品描述&quot; title=&quot;请选输入商品描述&quot;&gt;$&#123;pd.goods_desc&#125;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;FILE_PATH&quot; id=&quot;FILE_PATH&quot; value=&quot;$&#123;pd.FILE_PATH&#125;&quot; /&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;container&quot; class=&quot;uploadFile&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePicker&quot;&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选5张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;detail_image_url&quot; id=&quot;detail_image_url&quot; value=&quot;$&#123;pd.detail_image_url&#125;&quot; /&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;container&quot; class=&quot;uploadFile&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePickerDetail&quot;&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选5张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align: center;&quot; colspan=&quot;4&quot;&gt; &lt;a class=&quot;btn btn-mini btn-primary&quot; onclick=&quot;save();&quot;&gt;保存&lt;/a&gt; &lt;a class=&quot;btn btn-mini btn-danger&quot; onclick=&quot;top.Dialog.close();&quot;&gt;取消&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=&quot;zhongxin2&quot; class=&quot;center&quot; style=&quot;display:none&quot;&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;img src=&quot;static/images/jiazai.gif&quot; /&gt;&lt;br /&gt; &lt;h4 class=&quot;lighter block green&quot;&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 引入 --&gt; &lt;script type=&quot;text/javascript&quot;&gt;window.jQuery || document.write(&quot;&lt;script src=&apos;static/js/jquery-1.9.1.min.js&apos;&gt;\x3C/script&gt;&quot;);&lt;/script&gt; &lt;script src=&quot;static/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/ace-elements.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/ace.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;static/js/chosen.jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 下拉框 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;plugins/webuploader/webuploader.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/goods/goods_detail_edit.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //单选框 $(&quot;.chzn-select&quot;).chosen(); $(&quot;.chzn-select-deselect&quot;).chosen(&#123;allow_single_deselect:true&#125;); &#125;); $(top.hangge()); $(document).ready(function()&#123; if($(&quot;#user_id&quot;).val()!=&quot;&quot;)&#123; $(&quot;#loginname&quot;).attr(&quot;readonly&quot;,&quot;readonly&quot;); $(&quot;#loginname&quot;).css(&quot;color&quot;,&quot;gray&quot;); &#125; &#125;); //保存 function save()&#123; //验证商品编码是否为空 if($(&quot;#GOODS_CODE&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_CODE&quot;).tips(&#123; side:3, msg:&apos;请输入商品编码&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_CODE&quot;).focus(); return false; &#125; if($(&quot;#GOODS_NAME&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_NAME&quot;).tips(&#123; side:3, msg:&apos;请输入商品名称&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_NAME&quot;).focus(); return false; &#125; if($(&quot;#GOODS_ABBR_NAME&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_ABBR_NAME&quot;).tips(&#123; side:3, msg:&apos;请输入商品别名&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_ABBR_NAME&quot;).focus(); return false; &#125; //保存之前处理图片数据 var lbfiles = uploader[0].getFiles(&quot;complete&quot;);//轮播图 var lbFilesUrl=&quot;&quot;; $(lbfiles).each(function(index,item)&#123; lbFilesUrl = lbFilesUrl+&quot;;&quot;+item.url; &#125;); $(&quot;#FILE_PATH&quot;)[0].value = lbFilesUrl; //保存之前处理图片数据 var detailfiles = uploader[1].getFiles(&quot;complete&quot;);//商品详情图 var detailFilesUrl=&quot;&quot;; $(detailfiles).each(function(index,item)&#123; detailFilesUrl = detailFilesUrl+&quot;;&quot;+item.url; &#125;); $(&quot;#detail_image_url&quot;)[0].value = detailFilesUrl; $(&quot;#goodsForm&quot;).submit(); $(&quot;#zhongxin&quot;).hide(); $(&quot;#zhongxin2&quot;).show(); &#125; //校验编码是否存在 function checkHasCode()&#123; var goodsCode = $(&quot;#GOODS_CODE&quot;)[0].value; var checkGoodsCode = $(&quot;#checkGoodsCode&quot;)[0].value; if(goodsCode == checkGoodsCode)return; $.ajax(&#123; type: &quot;GET&quot;, url: &apos;&lt;%=basePath%&gt;goodsDetail/hasCode.do?tm=&apos;+new Date().getTime() + &apos;&amp;GOODS_CODE=&apos; + goodsCode, data : &apos;&apos;, dataType : &apos;json&apos;, cache : false, success : function(data) &#123; if (data.result == &quot;error&quot;) &#123; alert(&quot;编码重复，请重新输入&quot;); $(&quot;#GOODS_CODE&quot;)[0].value = checkGoodsCode; &#125;; &#125; &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.1 对应上传的js(goods_detail_edit.js)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621(function($)&#123; // 当domReady的时候开始初始化 $(function() &#123; uploader = new Array();//创建 uploader数组 // 判断浏览器是否支持图片的base64 var isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125;; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(); if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;); break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;); break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; $(&apos;.uploadFile&apos;).each(function(index)&#123; var $wrap = $(&apos;#uploader&apos;)[index], // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ).appendTo( $(this).find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $(this).find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $(this).find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $(this).find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;; var locat = (window.location+&apos;&apos;).split(&apos;/&apos;); if(&apos;pictures&apos;== locat[3])&#123;locat = locat[0]+&apos;//&apos;+locat[2];&#125;else&#123;locat = locat[0]+&apos;//&apos;+locat[2]+&apos;/&apos;+locat[3];&#125;; uploader[index] = WebUploader.create(&#123; pick: &#123; id: index==0?&apos;#filePicker&apos;:&apos;#filePickerDetail&apos;, label: &apos;点击选择图片&apos; &#125;, dnd: &apos;#dndArea&apos;, swf: &apos;./Uploader.swf&apos;, chunked: false, chunkSize: 512 * 1024, //server: &apos;http://127.0.0.1:8080/pictures/save.do&apos;, server: &apos;goodsDetail/uploadImg.do?&apos;, //runtimeOrder: &apos;flash&apos;, accept: &#123; title: &apos;Images&apos;, extensions: &apos;gif,jpg,jpeg,bmp,png&apos;, mimeTypes: &apos;image/*&apos; &#125;, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 disableGlobalDnd: true, fileNumLimit: index==0?5:1, fileSizeLimit: 200 * 1024 * 1024, // 200 M fileSingleSizeLimit: 50 * 1024 * 1024 // 50 M &#125;); // 拖拽时不接受 js, txt 文件。 uploader[index].on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); // uploader.on(&apos;filesQueued&apos;, function() &#123; // uploader.sort(function( a, b ) &#123; // if ( a.name &lt; b.name ) // return -1; // if ( a.name &gt; b.name ) // return 1; // return 0; // &#125;); // &#125;); // 添加“添加文件”的按钮， if(index==0)&#123; uploader[index].addButton(&#123; id: &apos;#filePicker2&apos;, label: &apos;继续添加&apos; &#125;); &#125; var getFileBlob = function(url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.addEventListener(&apos;load&apos;, function() &#123; cb(xhr.response); &#125;); xhr.send(); &#125;; var blobToFile = function(blob, name) &#123; blob.lastModifiedDate = new Date(); blob.name = name; return blob; &#125;; var getFileObject = function(filePathOrUrl, cb) &#123; getFileBlob(filePathOrUrl, function(blob) &#123; cb(blobToFile(blob, &apos;test.jpg&apos;)); &#125;); &#125;; //回显图片 uploader[index].on(&apos;ready&apos;, function() &#123; window.uploader = uploader; var filePathArg = index==0?$(&quot;#FILE_PATH&quot;)[0].value.split(&apos;;&apos;):$(&quot;#detail_image_url&quot;)[0].value.split(&apos;;&apos;); var files=new Array(); var i=0; if(filePathArg.length&gt;0)&#123; $.each(filePathArg, function(tempindex,item) &#123; //如果图片是空值，就直接返回 if(item==&apos;&apos;||item==&quot;undefined&quot;||item==undefined)&#123; return true; &#125; getFileObject(item, function(fileObject) &#123; var wuFile = new WebUploader.Lib.File(WebUploader.guid(&apos;rt_&apos;), fileObject); var tempfile = new WebUploader.File(wuFile); tempfile.url=item; tempfile.setStatus(&apos;complete&apos;); uploader[index].addFiles(tempfile); &#125;); &#125;); &#125;; &#125;); uploader[index].on( &apos;uploadSuccess&apos;, function( file,response ) &#123; file.url=response.path; if(index==0)&#123; $(&quot;#FILE_PATH&quot;)[0].value = $(&quot;#FILE_PATH&quot;)[0].value+&quot;;&quot;+response.path; &#125;else&#123; $(&quot;#detail_image_url&quot;)[0].value = $(&quot;#detail_image_url&quot;)[0].value+&quot;;&quot;+response.path; &#125; &#125;); // 当有文件添加进来时执行，负责view的创建 function addFile( file ) &#123; var $li = $( &apos;&lt;li id=&quot;&apos; + file.id + &apos;&quot;&gt;&apos; + &apos;&lt;p class=&quot;title&quot;&gt;&apos; + file.name + &apos;&lt;/p&gt;&apos; + &apos;&lt;p class=&quot;imgWrap&quot;&gt;&lt;/p&gt;&apos;+ &apos;&lt;p class=&quot;progress&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;/li&gt;&apos; ), $btns = $(&apos;&lt;div class=&quot;file-panel&quot;&gt;&apos; + &apos;&lt;span class=&quot;cancel&quot;&gt;删除&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateRight&quot;&gt;向右旋转&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateLeft&quot;&gt;向左旋转&lt;/span&gt;&lt;/div&gt;&apos;).appendTo( $li ), $prgress = $li.find(&apos;p.progress span&apos;), $wrap = $li.find( &apos;p.imgWrap&apos; ), $info = $(&apos;&lt;p class=&quot;error&quot;&gt;&lt;/p&gt;&apos;), showError = function( code ) &#123; switch( code ) &#123; case &apos;exceed_size&apos;: text = &apos;文件大小超出&apos;; break; case &apos;interrupt&apos;: text = &apos;上传暂停&apos;; break; default: text = &apos;上传失败，请重试&apos;; break; &#125; $info.text( text ).appendTo( $li ); &#125;; if ( file.getStatus() === &apos;invalid&apos; ) &#123; showError( file.statusText ); &#125; else &#123; // @todo lazyload $wrap.text( &apos;预览中&apos; ); uploader[index].makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( &apos;不能预览&apos; ); return; &#125; if( isSupportBase64 ) &#123; img = $(&apos;&lt;img src=&quot;&apos;+src+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $.ajax(&apos;../../server/preview.php&apos;, &#123; method: &apos;POST&apos;, data: src, dataType:&apos;json&apos; &#125;).done(function( response ) &#123; if (response.result) &#123; img = $(&apos;&lt;img src=&quot;&apos;+response.result+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $wrap.text(&quot;预览出错&quot;); &#125; &#125;); &#125; &#125;, thumbnailWidth, thumbnailHeight ); percentages[ file.id ] = [ file.size, 0 ]; file.rotation = 0; &#125; file.on(&apos;statuschange&apos;, function( cur, prev ) &#123; if ( prev === &apos;progress&apos; ) &#123; $prgress.hide().width(0); &#125; else if ( prev === &apos;queued&apos; ) &#123; $li.off( &apos;mouseenter mouseleave&apos; ); $btns.remove(); &#125; // 成功 if ( cur === &apos;error&apos; || cur === &apos;invalid&apos; ) &#123; console.log( file.statusText ); showError( file.statusText ); percentages[ file.id ][ 1 ] = 1; &#125; else if ( cur === &apos;interrupt&apos; ) &#123; showError( &apos;interrupt&apos; ); &#125; else if ( cur === &apos;queued&apos; ) &#123; percentages[ file.id ][ 1 ] = 0; &#125; else if ( cur === &apos;progress&apos; ) &#123; $info.remove(); $prgress.css(&apos;display&apos;, &apos;block&apos;); &#125; else if ( cur === &apos;complete&apos; ) &#123; $li.append( &apos;&lt;span class=&quot;success&quot;&gt;&lt;/span&gt;&apos; ); &#125; $li.removeClass( &apos;state-&apos; + prev ).addClass( &apos;state-&apos; + cur ); &#125;); $li.on( &apos;mouseenter&apos;, function() &#123; $btns.stop().animate(&#123;height: 30&#125;); &#125;); $li.on( &apos;mouseleave&apos;, function() &#123; $btns.stop().animate(&#123;height: 0&#125;); &#125;); $btns.on( &apos;click&apos;, &apos;span&apos;, function() &#123; var tempIndex = $(this).index(), deg; switch ( tempIndex ) &#123; case 0: uploader[index].removeFile( file ); return; case 1: file.rotation += 90; break; case 2: file.rotation -= 90; break; &#125; if ( supportTransition ) &#123; deg = &apos;rotate(&apos; + file.rotation + &apos;deg)&apos;; $wrap.css(&#123; &apos;-webkit-transform&apos;: deg, &apos;-mos-transform&apos;: deg, &apos;-o-transform&apos;: deg, &apos;transform&apos;: deg &#125;); &#125; else &#123; $wrap.css( &apos;filter&apos;, &apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=&apos;+ (~~((file.rotation/90)%4 + 4)%4) +&apos;)&apos;); // use jquery animate to rotation // $(&#123; // rotation: rotation // &#125;).animate(&#123; // rotation: file.rotation // &#125;, &#123; // easing: &apos;linear&apos;, // step: function( now ) &#123; // now = now * Math.PI / 180; // var cos = Math.cos( now ), // sin = Math.sin( now ); // $wrap.css( &apos;filter&apos;, &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&quot; + cos + &quot;,M12=&quot; + (-sin) + &quot;,M21=&quot; + sin + &quot;,M22=&quot; + cos + &quot;,SizingMethod=&apos;auto expand&apos;)&quot;); // &#125; // &#125;); &#125; &#125;); $li.appendTo( $queue ); &#125; // 负责view的销毁 function removeFile( file ) &#123; var $li = $(&apos;#&apos;+file.id); delete percentages[ file.id ]; updateTotalProgress(); $li.off().find(&apos;.file-panel&apos;).off().end().remove(); &#125; function updateTotalProgress() &#123; var loaded = 0, total = 0, spans = $progress.children(), percent; $.each( percentages, function( k, v ) &#123; total += v[ 0 ]; loaded += v[ 0 ] * v[ 1 ]; &#125; ); percent = total ? loaded / total : 0; spans.eq( 0 ).text( Math.round( percent * 100 ) + &apos;%&apos; ); spans.eq( 1 ).css( &apos;width&apos;, Math.round( percent * 100 ) + &apos;%&apos; ); updateStatus(); &#125; function updateStatus() &#123; var text = &apos;&apos;, stats; if ( state === &apos;ready&apos; ) &#123; text = &apos;选中&apos; + fileCount + &apos;张图片，共&apos; + WebUploader.formatSize( fileSize ) + &apos;。&apos;; &#125; else if ( state === &apos;confirm&apos; ) &#123; stats = uploader[index].getStats(); if ( stats.uploadFailNum ) &#123; text = &apos;已成功上传&apos; + stats.successNum+ &apos;张照片至XX相册，&apos;+ stats.uploadFailNum + &apos;张照片上传失败，&lt;a class=&quot;retry&quot; href=&quot;#&quot;&gt;重新上传&lt;/a&gt;失败图片或&lt;a class=&quot;ignore&quot; href=&quot;#&quot;&gt;忽略&lt;/a&gt;&apos;; &#125; &#125; else &#123; stats = uploader[index].getStats(); text = &apos;共&apos; + fileCount + &apos;张（&apos; + WebUploader.formatSize( fileSize ) + &apos;），已上传&apos; + stats.successNum + &apos;张&apos;; if ( stats.uploadFailNum ) &#123; text += &apos;，失败&apos; + stats.uploadFailNum + &apos;张&apos;; &#125; &#125; $info.html( text ); &#125; function setState( val ) &#123; var file, stats; if ( val === state ) &#123; return; &#125; $upload.removeClass( &apos;state-&apos; + state ); $upload.addClass( &apos;state-&apos; + val ); state = val; switch ( state ) &#123; case &apos;pedding&apos;: $placeHolder.removeClass( &apos;element-invisible&apos; ); $queue.hide(); $statusBar.addClass( &apos;element-invisible&apos; ); uploader[index].refresh(); break; case &apos;ready&apos;: $placeHolder.addClass( &apos;element-invisible&apos; ); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos;); $queue.show(); $statusBar.removeClass(&apos;element-invisible&apos;); uploader[index].refresh(); break; case &apos;uploading&apos;: $( &apos;#filePicker2&apos; ).addClass( &apos;element-invisible&apos; ); $progress.show(); $upload.text( &apos;暂停上传&apos; ); break; case &apos;paused&apos;: $progress.show(); $upload.text( &apos;继续上传&apos; ); break; case &apos;confirm&apos;: $progress.hide(); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos; ); $upload.text( &apos;开始上传&apos; ); stats = uploader[index].getStats(); if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( &apos;finish&apos; ); return; &#125; break; case &apos;finish&apos;: stats = uploader[index].getStats(); if ( stats.successNum ) &#123; //alert( &apos;上传成功&apos; ); &#125; else &#123; // 没有成功的图片，重设 state = &apos;done&apos;; location.reload(); &#125; break; &#125; updateStatus(); &#125; uploader[index].onUploadProgress = function( file, percentage ) &#123; var $li = $(&apos;#&apos;+file.id), $percent = $li.find(&apos;.progress span&apos;); $percent.css( &apos;width&apos;, percentage * 100 + &apos;%&apos; ); percentages[ file.id ][ 1 ] = percentage; updateTotalProgress(); &#125;; uploader[index].onFileQueued = function( file ) &#123; fileCount++; fileSize += file.size; if ( fileCount === 1 ) &#123; $placeHolder.addClass( &apos;element-invisible&apos; ); $statusBar.show(); &#125; addFile( file ); setState( &apos;ready&apos; ); updateTotalProgress(); &#125;; uploader[index].onFileDequeued = function( file ) &#123; fileCount--; fileSize -= file.size; debugger; if ( !fileCount ) &#123; setState( &apos;pedding&apos; ); &#125; removeFile(file); updateTotalProgress(); &#125;; uploader[index].on( &apos;all&apos;, function( type ) &#123; var stats; switch( type ) &#123; case &apos;uploadFinished&apos;: setState( &apos;confirm&apos; ); break; case &apos;startUpload&apos;: setState( &apos;uploading&apos; ); break; case &apos;stopUpload&apos;: setState( &apos;paused&apos; ); break; &#125; &#125;); uploader[index].onError = function( code ) &#123; if(code == &apos;F_DUPLICATE&apos;)&#123; alert( &apos;图片重复&apos; ); &#125;else&#123; alert( &apos;Eroor: &apos; + code ); &#125; &#125;; $upload.on(&apos;click&apos;, function() &#123; if ( $(this).hasClass( &apos;disabled&apos; ) ) &#123; return false; &#125; if ( state === &apos;ready&apos; ) &#123; uploader[index].upload(); &#125; else if ( state === &apos;paused&apos; ) &#123; uploader[index].upload(); &#125; else if ( state === &apos;uploading&apos; ) &#123; uploader[index].stop(); &#125; &#125;); $info.on( &apos;click&apos;, &apos;.retry&apos;, function() &#123; uploader[index].retry(); &#125; ); $info.on( &apos;click&apos;, &apos;.ignore&apos;, function() &#123; alert( &apos;todo&apos; ); &#125; ); $upload.addClass( &apos;state-&apos; + state ); updateTotalProgress(); &#125;); &#125;);&#125;)( jQuery ); 2.后台代码上传图片12345678910111213141516171819202122232425262728 /** * 上传图片 */ @RequestMapping(value=&quot;/uploadImg&quot;) @ResponseBody public Object save(@RequestParam(required=false) MultipartFile file,String goodsCode) throws Exception&#123; logBefore(logger, &quot;GoodsDetail上传图片&quot;); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();// String ffile = DateUtil.getDays(), fileName = &quot;&quot;; PageData pd = new PageData(); String imageUrls = &quot;&quot;; if(Jurisdiction.buttonJurisdiction(menuUrl, &quot;add&quot;))&#123; if (null != file &amp;&amp; !file.isEmpty()) &#123; //上传图片到FastDFS MultipartFile[] files = new MultipartFile[1]; files[0] = file; imageUrls = fastDFSService.upload(files);// String filePath = PathUtil.getClasspath() + Const.FILEPATHIMG + ffile; //文件上传路径// fileName = FileUpload.fileUp(file, filePath, this.get32UUID()); //执行上传 &#125;else&#123; System.out.println(&quot;上传失败&quot;); &#125; &#125; map.put(&quot;result&quot;, &quot;ok&quot;);// map.put(&quot;path&quot;, ffile + &quot;/&quot; + fileName); map.put(&quot;path&quot;, imageUrls); return AppUtil.returnObject(pd, map); &#125; 保存图片路径1234567891011121314151617181920212223242526272829303132333435363738394041/** * 保存商品基础信息 */ @RequestMapping(value=&quot;/save&quot;) public ModelAndView save() throws Exception&#123; ModelAndView mv = this.getModelAndView(); PageData pd = new PageData(); pd = this.getPageData(); DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //首先判断是否有主键goods_code String goodsCode = pd.getString(&quot;GOODS_CODE&quot;); if(goodsCode!=null &amp;&amp; !&quot;&quot;.equals(goodsCode))&#123;//如果不为空，走update语句 String filePath = pd.getString(&quot;FILE_PATH&quot;)==null?&quot;&quot;:pd.getString(&quot;FILE_PATH&quot;).toString();//图片路径 String[] filePathArg = filePath.split(&quot;;&quot;); String imageUrl1 = filePathArg!=null&amp;&amp;filePathArg.length&gt;1?filePathArg[1]:&quot;&quot;; String imageUrl2 = filePathArg!=null&amp;&amp;filePathArg.length&gt;2?filePathArg[2]:&quot;&quot;; String imageUrl3 = filePathArg!=null&amp;&amp;filePathArg.length&gt;3?filePathArg[3]:&quot;&quot;; String imageUrl4 = filePathArg!=null&amp;&amp;filePathArg.length&gt;4?filePathArg[4]:&quot;&quot;; String imageUrl5 = filePathArg!=null&amp;&amp;filePathArg.length&gt;5?filePathArg[5]:&quot;&quot;; String updatedTime = df.format(new Date()); pd.put(&quot;imageUrl1&quot;, imageUrl1); pd.put(&quot;imageUrl2&quot;, imageUrl2); pd.put(&quot;imageUrl3&quot;, imageUrl3); pd.put(&quot;imageUrl4&quot;, imageUrl4); pd.put(&quot;imageUrl5&quot;, imageUrl5); pd.put(&quot;updatedTime&quot;, updatedTime); String detailImageUrl = pd.getString(&quot;detail_image_url&quot;)==null?&quot;&quot;:pd.getString(&quot;detail_image_url&quot;).toString();//商品详情 String[] detailImageUrlArg = detailImageUrl.split(&quot;;&quot;); String detailImage = detailImageUrlArg!=null&amp;&amp;detailImageUrlArg.length&gt;1?detailImageUrlArg[1]:&quot;&quot;; pd.put(&quot;detail_image_url&quot;, detailImage); &#125;else&#123;//如果为空，那就是新增数据 &#125; if(Jurisdiction.buttonJurisdiction(menuUrl, &quot;edit&quot;))&#123;goodsDetailService.save(pd);&#125; mv.addObject(&quot;msg&quot;,&quot;success&quot;); mv.setViewName(&quot;save_result&quot;); return mv; &#125;]]></content>
      <categories>
        <category>前端插件</category>
        <category>Webuploader</category>
      </categories>
      <tags>
        <tag>Webuploader</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webuploader多图上传及回显]]></title>
    <url>%2F2019%2F01%2F25%2FWebuploader%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[goods_detail_uploader.js 这个是图片上传的js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612(function($)&#123; // 当domReady的时候开始初始化 $(function() &#123; var $wrap = $(&apos;#uploader&apos;), // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ).appendTo( $wrap.find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $wrap.find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $wrap.find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $wrap.find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;, // 判断浏览器是否支持图片的base64 isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125;; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(), // WebUploader实例 uploader; if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;); break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;); break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; var locat = (window.location+&apos;&apos;).split(&apos;/&apos;); if(&apos;pictures&apos;== locat[3])&#123;locat = locat[0]+&apos;//&apos;+locat[2];&#125;else&#123;locat = locat[0]+&apos;//&apos;+locat[2]+&apos;/&apos;+locat[3];&#125;; uploader = WebUploader.create(&#123; pick: &#123; id: &apos;#filePicker&apos;, label: &apos;点击选择图片&apos; &#125;, formData: &#123; uid: 123 &#125;, dnd: &apos;#dndArea&apos;, paste: &apos;#uploader&apos;, swf: &apos;./Uploader.swf&apos;, chunked: false, chunkSize: 512 * 1024, //server: &apos;http://127.0.0.1:8080/pictures/save.do&apos;, server: &apos;goodsDetail/uploadImg.do?&apos;, //runtimeOrder: &apos;flash&apos;, accept: &#123; title: &apos;Images&apos;, extensions: &apos;gif,jpg,jpeg,bmp,png&apos;, mimeTypes: &apos;image/*&apos; &#125;, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 disableGlobalDnd: true, fileNumLimit: 5, fileSizeLimit: 200 * 1024 * 1024, // 200 M fileSingleSizeLimit: 50 * 1024 * 1024 // 50 M &#125;); // 拖拽时不接受 js, txt 文件。 uploader.on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); // uploader.on(&apos;filesQueued&apos;, function() &#123; // uploader.sort(function( a, b ) &#123; // if ( a.name &lt; b.name ) // return -1; // if ( a.name &gt; b.name ) // return 1; // return 0; // &#125;); // &#125;); // 添加“添加文件”的按钮， uploader.addButton(&#123; id: &apos;#filePicker2&apos;, label: &apos;继续添加&apos; &#125;); var getFileBlob = function(url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.addEventListener(&apos;load&apos;, function() &#123; cb(xhr.response); &#125;); xhr.send(); &#125;; var blobToFile = function(blob, name) &#123; blob.lastModifiedDate = new Date(); blob.name = name; return blob; &#125;; var getFileObject = function(filePathOrUrl, cb) &#123; getFileBlob(filePathOrUrl, function(blob) &#123; cb(blobToFile(blob, &apos;test.jpg&apos;)); &#125;); &#125;; //回显图片 uploader.on(&apos;ready&apos;, function() &#123; debugger; window.uploader = uploader; var filePathArg = $(&quot;#FILE_PATH&quot;)[0].value.split(&apos;;&apos;); var files=new Array(); var i=0; if(filePathArg.length&gt;0)&#123; $.each(filePathArg, function(index,item) &#123; //如果图片是空值，就直接返回 if(item==&apos;&apos;||item==&quot;undefined&quot;||item==undefined)&#123; return true; &#125; getFileObject(item, function(fileObject) &#123; var wuFile = new WebUploader.Lib.File(WebUploader.guid(&apos;rt_&apos;), fileObject); var tempfile = new WebUploader.File(wuFile); tempfile.url=item; tempfile.setStatus(&apos;complete&apos;); uploader.addFiles(tempfile); &#125;); &#125;); &#125;; &#125;); uploader.on( &apos;uploadSuccess&apos;, function( file,response ) &#123; file.url=response.path; $(&quot;#FILE_PATH&quot;)[0].value = $(&quot;#FILE_PATH&quot;)[0].value+&quot;;&quot;+response.path; &#125;); // 当有文件添加进来时执行，负责view的创建 function addFile( file ) &#123; var $li = $( &apos;&lt;li id=&quot;&apos; + file.id + &apos;&quot;&gt;&apos; + &apos;&lt;p class=&quot;title&quot;&gt;&apos; + file.name + &apos;&lt;/p&gt;&apos; + &apos;&lt;p class=&quot;imgWrap&quot;&gt;&lt;/p&gt;&apos;+ &apos;&lt;p class=&quot;progress&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;/li&gt;&apos; ), $btns = $(&apos;&lt;div class=&quot;file-panel&quot;&gt;&apos; + &apos;&lt;span class=&quot;cancel&quot;&gt;删除&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateRight&quot;&gt;向右旋转&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateLeft&quot;&gt;向左旋转&lt;/span&gt;&lt;/div&gt;&apos;).appendTo( $li ), $prgress = $li.find(&apos;p.progress span&apos;), $wrap = $li.find( &apos;p.imgWrap&apos; ), $info = $(&apos;&lt;p class=&quot;error&quot;&gt;&lt;/p&gt;&apos;), showError = function( code ) &#123; switch( code ) &#123; case &apos;exceed_size&apos;: text = &apos;文件大小超出&apos;; break; case &apos;interrupt&apos;: text = &apos;上传暂停&apos;; break; default: text = &apos;上传失败，请重试&apos;; break; &#125; $info.text( text ).appendTo( $li ); &#125;; if ( file.getStatus() === &apos;invalid&apos; ) &#123; showError( file.statusText ); &#125; else &#123; // @todo lazyload $wrap.text( &apos;预览中&apos; ); uploader.makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( &apos;不能预览&apos; ); return; &#125; if( isSupportBase64 ) &#123; img = $(&apos;&lt;img src=&quot;&apos;+src+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $.ajax(&apos;../../server/preview.php&apos;, &#123; method: &apos;POST&apos;, data: src, dataType:&apos;json&apos; &#125;).done(function( response ) &#123; if (response.result) &#123; img = $(&apos;&lt;img src=&quot;&apos;+response.result+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $wrap.text(&quot;预览出错&quot;); &#125; &#125;); &#125; &#125;, thumbnailWidth, thumbnailHeight ); percentages[ file.id ] = [ file.size, 0 ]; file.rotation = 0; &#125; file.on(&apos;statuschange&apos;, function( cur, prev ) &#123; if ( prev === &apos;progress&apos; ) &#123; $prgress.hide().width(0); &#125; else if ( prev === &apos;queued&apos; ) &#123; $li.off( &apos;mouseenter mouseleave&apos; ); $btns.remove(); &#125; // 成功 if ( cur === &apos;error&apos; || cur === &apos;invalid&apos; ) &#123; console.log( file.statusText ); showError( file.statusText ); percentages[ file.id ][ 1 ] = 1; &#125; else if ( cur === &apos;interrupt&apos; ) &#123; showError( &apos;interrupt&apos; ); &#125; else if ( cur === &apos;queued&apos; ) &#123; percentages[ file.id ][ 1 ] = 0; &#125; else if ( cur === &apos;progress&apos; ) &#123; $info.remove(); $prgress.css(&apos;display&apos;, &apos;block&apos;); &#125; else if ( cur === &apos;complete&apos; ) &#123; $li.append( &apos;&lt;span class=&quot;success&quot;&gt;&lt;/span&gt;&apos; ); &#125; $li.removeClass( &apos;state-&apos; + prev ).addClass( &apos;state-&apos; + cur ); &#125;); $li.on( &apos;mouseenter&apos;, function() &#123; $btns.stop().animate(&#123;height: 30&#125;); &#125;); $li.on( &apos;mouseleave&apos;, function() &#123; $btns.stop().animate(&#123;height: 0&#125;); &#125;); $btns.on( &apos;click&apos;, &apos;span&apos;, function() &#123; var index = $(this).index(), deg; switch ( index ) &#123; case 0: uploader.removeFile( file ); return; case 1: file.rotation += 90; break; case 2: file.rotation -= 90; break; &#125; if ( supportTransition ) &#123; deg = &apos;rotate(&apos; + file.rotation + &apos;deg)&apos;; $wrap.css(&#123; &apos;-webkit-transform&apos;: deg, &apos;-mos-transform&apos;: deg, &apos;-o-transform&apos;: deg, &apos;transform&apos;: deg &#125;); &#125; else &#123; $wrap.css( &apos;filter&apos;, &apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=&apos;+ (~~((file.rotation/90)%4 + 4)%4) +&apos;)&apos;); // use jquery animate to rotation // $(&#123; // rotation: rotation // &#125;).animate(&#123; // rotation: file.rotation // &#125;, &#123; // easing: &apos;linear&apos;, // step: function( now ) &#123; // now = now * Math.PI / 180; // var cos = Math.cos( now ), // sin = Math.sin( now ); // $wrap.css( &apos;filter&apos;, &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&quot; + cos + &quot;,M12=&quot; + (-sin) + &quot;,M21=&quot; + sin + &quot;,M22=&quot; + cos + &quot;,SizingMethod=&apos;auto expand&apos;)&quot;); // &#125; // &#125;); &#125; &#125;); $li.appendTo( $queue ); &#125; // 负责view的销毁 function removeFile( file ) &#123; var $li = $(&apos;#&apos;+file.id); delete percentages[ file.id ]; updateTotalProgress(); $li.off().find(&apos;.file-panel&apos;).off().end().remove(); &#125; function updateTotalProgress() &#123; var loaded = 0, total = 0, spans = $progress.children(), percent; $.each( percentages, function( k, v ) &#123; total += v[ 0 ]; loaded += v[ 0 ] * v[ 1 ]; &#125; ); percent = total ? loaded / total : 0; spans.eq( 0 ).text( Math.round( percent * 100 ) + &apos;%&apos; ); spans.eq( 1 ).css( &apos;width&apos;, Math.round( percent * 100 ) + &apos;%&apos; ); updateStatus(); &#125; function updateStatus() &#123; var text = &apos;&apos;, stats; if ( state === &apos;ready&apos; ) &#123; text = &apos;选中&apos; + fileCount + &apos;张图片，共&apos; + WebUploader.formatSize( fileSize ) + &apos;。&apos;; &#125; else if ( state === &apos;confirm&apos; ) &#123; stats = uploader.getStats(); if ( stats.uploadFailNum ) &#123; text = &apos;已成功上传&apos; + stats.successNum+ &apos;张照片至XX相册，&apos;+ stats.uploadFailNum + &apos;张照片上传失败，&lt;a class=&quot;retry&quot; href=&quot;#&quot;&gt;重新上传&lt;/a&gt;失败图片或&lt;a class=&quot;ignore&quot; href=&quot;#&quot;&gt;忽略&lt;/a&gt;&apos;; &#125; &#125; else &#123; stats = uploader.getStats(); text = &apos;共&apos; + fileCount + &apos;张（&apos; + WebUploader.formatSize( fileSize ) + &apos;），已上传&apos; + stats.successNum + &apos;张&apos;; if ( stats.uploadFailNum ) &#123; text += &apos;，失败&apos; + stats.uploadFailNum + &apos;张&apos;; &#125; &#125; $info.html( text ); &#125; function setState( val ) &#123; var file, stats; if ( val === state ) &#123; return; &#125; $upload.removeClass( &apos;state-&apos; + state ); $upload.addClass( &apos;state-&apos; + val ); state = val; switch ( state ) &#123; case &apos;pedding&apos;: $placeHolder.removeClass( &apos;element-invisible&apos; ); $queue.hide(); $statusBar.addClass( &apos;element-invisible&apos; ); uploader.refresh(); break; case &apos;ready&apos;: $placeHolder.addClass( &apos;element-invisible&apos; ); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos;); $queue.show(); $statusBar.removeClass(&apos;element-invisible&apos;); uploader.refresh(); break; case &apos;uploading&apos;: $( &apos;#filePicker2&apos; ).addClass( &apos;element-invisible&apos; ); $progress.show(); $upload.text( &apos;暂停上传&apos; ); break; case &apos;paused&apos;: $progress.show(); $upload.text( &apos;继续上传&apos; ); break; case &apos;confirm&apos;: $progress.hide(); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos; ); $upload.text( &apos;开始上传&apos; ); stats = uploader.getStats(); if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( &apos;finish&apos; ); return; &#125; break; case &apos;finish&apos;: stats = uploader.getStats(); if ( stats.successNum ) &#123; //alert( &apos;上传成功&apos; ); &#125; else &#123; // 没有成功的图片，重设 state = &apos;done&apos;; location.reload(); &#125; break; &#125; updateStatus(); &#125; uploader.onUploadProgress = function( file, percentage ) &#123; var $li = $(&apos;#&apos;+file.id), $percent = $li.find(&apos;.progress span&apos;); $percent.css( &apos;width&apos;, percentage * 100 + &apos;%&apos; ); percentages[ file.id ][ 1 ] = percentage; updateTotalProgress(); &#125;; uploader.onFileQueued = function( file ) &#123; fileCount++; fileSize += file.size; if ( fileCount === 1 ) &#123; $placeHolder.addClass( &apos;element-invisible&apos; ); $statusBar.show(); &#125; addFile( file ); setState( &apos;ready&apos; ); updateTotalProgress(); &#125;; uploader.onFileDequeued = function( file ) &#123; fileCount--; fileSize -= file.size; if ( !fileCount ) &#123; setState( &apos;pedding&apos; ); &#125; removeFile(file); updateTotalProgress(); &#125;; uploader.on( &apos;all&apos;, function( type ) &#123; var stats; switch( type ) &#123; case &apos;uploadFinished&apos;: setState( &apos;confirm&apos; ); break; case &apos;startUpload&apos;: setState( &apos;uploading&apos; ); break; case &apos;stopUpload&apos;: setState( &apos;paused&apos; ); break; &#125; &#125;); uploader.onError = function( code ) &#123; if(code == &apos;F_DUPLICATE&apos;)&#123; alert( &apos;图片重复&apos; ); &#125;else&#123; alert( &apos;Eroor: &apos; + code ); &#125; &#125;; $upload.on(&apos;click&apos;, function() &#123; if ( $(this).hasClass( &apos;disabled&apos; ) ) &#123; return false; &#125; if ( state === &apos;ready&apos; ) &#123; uploader.upload(); &#125; else if ( state === &apos;paused&apos; ) &#123; uploader.upload(); &#125; else if ( state === &apos;uploading&apos; ) &#123; uploader.stop(); &#125; &#125;); $info.on( &apos;click&apos;, &apos;.retry&apos;, function() &#123; uploader.retry(); &#125; ); $info.on( &apos;click&apos;, &apos;.ignore&apos;, function() &#123; alert( &apos;todo&apos; ); &#125; ); $upload.addClass( &apos;state-&apos; + state ); updateTotalProgress(); &#125;);&#125;)( jQuery ); 图片上传页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name="description" content="overview &amp; stats" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;link href="static/css/bootstrap.min.css" rel="stylesheet" /&gt;&lt;link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" /&gt;&lt;link rel="stylesheet" href="static/css/font-awesome.min.css" /&gt;&lt;!-- 下拉框 --&gt;&lt;link rel="stylesheet" href="static/css/chosen.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace.min.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace-responsive.min.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace-skins.min.css" /&gt;&lt;script type="text/javascript" src="static/js/jquery-1.7.2.js"&gt;&lt;/script&gt;&lt;!-- 上传图片 --&gt;&lt;link rel="stylesheet" type="text/css" href="plugins/webuploader/webuploader.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="plugins/webuploader/style.css" /&gt;&lt;style type="text/css"&gt;#wrapper &#123; margin: 0;&#125;#uploader .placeholder &#123; background: url(plugins/webuploader/image.png) center 23px no-repeat; padding-top: 88px; min-height: 110px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="goodsDetail/$&#123;msg &#125;.do" name="goodsForm" id="goodsForm" method="post"&gt; &lt;div id="zhongxin"&gt; &lt;table id="table_report" class="table table-striped table-bordered table-hover"&gt; &lt;tr&gt; &lt;th style="vertical-align: middle"&gt;轮播图:&lt;/th&gt; &lt;td colspan="3"&gt;&lt;input type="hidden" name="FILE_PATH" id="FILE_PATH" value="$&#123;pd.FILE_PATH&#125;" /&gt; &lt;div id="wrapper"&gt; &lt;div id="container"&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id="uploader"&gt; &lt;div class="queueList"&gt; &lt;div id="dndArea" class="placeholder"&gt; &lt;div id="filePicker"&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选1张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="statusBar" style="display:none;"&gt; &lt;div class="progress"&gt; &lt;span class="text"&gt;0%&lt;/span&gt; &lt;span class="percentage"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="info"&gt;&lt;/div&gt; &lt;div class="btns"&gt; &lt;div id="filePicker2"&gt;&lt;/div&gt; &lt;div class="uploadBtn"&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="text-align: center;" colspan="4"&gt; &lt;a class="btn btn-mini btn-primary" onclick="save();"&gt;保存&lt;/a&gt; &lt;a class="btn btn-mini btn-danger" onclick="top.Dialog.close();"&gt;取消&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id="zhongxin2" class="center" style="display:none"&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;img src="static/images/jiazai.gif" /&gt;&lt;br /&gt; &lt;h4 class="lighter block green"&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 引入 --&gt; &lt;script type="text/javascript"&gt;window.jQuery || document.write("&lt;script src='static/js/jquery-1.9.1.min.js'&gt;\x3C/script&gt;");&lt;/script&gt; &lt;script src="static/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script src="static/js/ace-elements.min.js"&gt;&lt;/script&gt; &lt;script src="static/js/ace.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="static/js/chosen.jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 下拉框 --&gt; &lt;script type="text/javascript" src="plugins/webuploader/webuploader.js"&gt;&lt;/script&gt; &lt;script src="static/js/goods/goods_detail_edit.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var tempqueue; $(function() &#123; //单选框 $(".chzn-select").chosen(); $(".chzn-select-deselect").chosen(&#123;allow_single_deselect:true&#125;); &#125;); //保存 function save()&#123; //获取所有在图片列表中的URL传给后台 var files = uploader.getFiles(); var filePath = ""; files.forEach(function(e)&#123; if(e.getStatus()=="complete")&#123; filePath = filePath+";"+e.url; &#125; &#125;); $("#FILE_PATH")[0].value = filePath; $("#goodsForm").submit(); $("#zhongxin").hide(); $("#zhongxin2").show(); &#125; //校验编码是否存在 function checkHasCode()&#123; var goodsCode = $("#GOODS_CODE")[0].value; var checkGoodsCode = $("#checkGoodsCode")[0].value; if(goodsCode == checkGoodsCode)return; $.ajax(&#123; type: "GET", url: '&lt;%=basePath%&gt;goodsDetail/hasCode.do?tm='+new Date().getTime() + '&amp;GOODS_CODE=' + goodsCode, data : '', dataType : 'json', cache : false, success : function(data) &#123; if (data.result == "error") &#123; alert("编码重复，请重新输入"); $("#GOODS_CODE")[0].value = checkGoodsCode; &#125;; &#125; &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; java后台上传图片代码12345678910111213141516171819202122232425262728 /** * 上传图片 */ @RequestMapping(value="/uploadImg") @ResponseBody public Object save(@RequestParam(required=false) MultipartFile file,String goodsCode) throws Exception&#123; logBefore(logger, "GoodsDetail上传图片"); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();// String ffile = DateUtil.getDays(), fileName = ""; PageData pd = new PageData(); String imageUrls = ""; if(Jurisdiction.buttonJurisdiction(menuUrl, "add"))&#123; if (null != file &amp;&amp; !file.isEmpty()) &#123; //上传图片到FastDFS MultipartFile[] files = new MultipartFile[1]; files[0] = file; imageUrls = fastDFSService.upload(files);// String filePath = PathUtil.getClasspath() + Const.FILEPATHIMG + ffile; //文件上传路径// fileName = FileUpload.fileUp(file, filePath, this.get32UUID()); //执行上传 &#125;else&#123; System.out.println("上传失败"); &#125; &#125; map.put("result", "ok");// map.put("path", ffile + "/" + fileName); map.put("path", imageUrls); return AppUtil.returnObject(pd, map); &#125;]]></content>
      <categories>
        <category>前端插件</category>
        <category>Webuploader</category>
      </categories>
      <tags>
        <tag>Webuploader</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中显示MarkDown，并且进行代码高亮]]></title>
    <url>%2F2019%2F01%2F25%2FHTML%E4%B8%AD%E6%98%BE%E7%A4%BAMarkDown%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[简述 临时个人兴趣，做一个类似API的东西，要显示具体对应的代码，因此用到了页面中显示代码插件（showdown）和高亮代码插件（highligt），两个插件的官网分别是：showdown、highlight 使用方法showdown 首先在官网下载showdown 下载完成后，引入项目，解压找到showdown.min.js文件 js代码1234567891011$('li a').click(function()&#123; $.get(this.href,function(data)&#123; var converter = new showdown.Converter();//1.首先定义converter data = "``` \n"+data+" \n ```";//转换成markdown格式的代码 var html = converter.makeHtml(data);//2. 使用convert转换成html代码 document.getElementById("code").innerHTML = html;//3. 将转换好的markdown放入对应的div $('pre code').each(function(i, block) &#123; hljs.highlightBlock(block); &#125;); &#125;)&#125;) highlight 首先官网下载highlight 下载完成后，引入项目 需要注意点： highlight提供好几种样式，可以在style文件夹下面自行查找 js代码123456789101112//展示和高亮代码 $(&apos;li a&apos;).click(function()&#123; $.get(this.href,function(data)&#123; var converter = new showdown.Converter(); data = &quot;``` \n&quot;+data+&quot; \n ```&quot;; var html = converter.makeHtml(data); document.getElementById(&quot;code&quot;).innerHTML = html; $(&apos;pre code&apos;).each(function(i, block) &#123;//这一行一定要有，否则高亮代码不生效 hljs.highlightBlock(block);//使代码高亮 &#125;); &#125;) &#125;) 这个页面有一个很巧妙的地方，是通过get请求获取到未经js和css渲染的纯html页面代码，方法的代码如下：123$.get(url,function(data)&#123; console.log(data);//这里面的data就是未经渲染的html代码内容&#125;)]]></content>
      <categories>
        <category>前端插件</category>
        <category>showdown&amp;highlight</category>
      </categories>
      <tags>
        <tag>前端插件</tag>
        <tag>showdown</tag>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageView图片预览的使用方法及代码]]></title>
    <url>%2F2019%2F01%2F25%2FImageView%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在做一个项目上图片预览的功能，常规情况下都是简单的一个类型下的图片，但目前的需求是左侧展示一个用户下的图片类型，右边显示这个用户下这个类型的图片的列表，点击列表上的图片还能看大图进行预览操作 下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;预览影像资料&lt;/title&gt; &lt;link rel="stylesheet" href="../../../main/scripts/bootstrap-3.3.7/css/bootstrap.css"/&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/main.css"&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/mine.css"&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/viewer.css"&gt; &lt;!-- Scripts --&gt; &lt;script src="../../../main/scripts/imagesview/js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script src="../../../main/scripts/imagesview/js/viewer.js"&gt;&lt;/script&gt; &lt;style&gt; .menu &#123; position: absolute; left: 0; top: 0; bottom: 0; width: 200px; padding-top: 100px; font-family: Consolas, arial, "宋体"; background-color: #ccc; &#125; .menu a &#123; display: block; height: 40px; margin: 0 0 1px 2px; padding-left: 10px; line-height: 40px; font-size: 14px; color: #333; text-decoration: none; &#125; .menu a.cur &#123; background-color: #eee; &#125; .menu a:hover &#123; background-color: #eee; &#125; /* .menu .cur &#123; color: #000; background-color: #fff !important;&#125; */ #jq22 &#123; width: 700px; margin: 0 auto; font-size: 0; &#125; #jq22 li &#123; display: inline-block; width: 32%; height: 150px; margin-left: 1%; padding-top: 1%; &#125; #jq22 li img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;!-- 左边内容 --&gt; &lt;div class="menu"&gt; &lt;a id="all-items" class="cur menu-item" href="javascript:;" onclick="initImages('')"&gt;&amp;nbsp&amp;nbsp全部影像&lt;/a&gt; &lt;a class="menu-item" href="#"&gt;&lt;/a&gt; &lt;/div&gt; &lt;!-- 右边内容 --&gt; &lt;div class="right" id="right"&gt; &lt;!--&lt;h1 style="text-align: center"&gt; &lt;p id="hname"&gt;全部影像&lt;/p&gt; &lt;/h1&gt;--&gt; &lt;ul class="docs-pictures clearfix" id="jq22"&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var viewer; var applyId = mini.getParams().applyId;//申请ID $(function () &#123; //初始化左侧的资料类型 initImageType(); initImages('');//初始化的时候加载所有的图片 //初始化viewer viewer = new Viewer(document.getElementById('jq22'), &#123; show: function () &#123; viewer.update(); &#125; &#125;); &#125;) //加载左侧的资料类型 function initImageType()&#123; $.ajax(&#123; url:eg.getRequestUrl()+'/imgManage/getImageType', type:'GET', data:&#123;applyId:applyId&#125;, async:true, dataType:'json', success:function(data)&#123; if(data.code == 0)&#123;//如果查询成功，加载遍历左侧的数据 for(var dataIndex=0;dataIndex &lt; data.datalist.length;dataIndex++)&#123; (function(dataIndex)&#123; var a=document.createElement('a'); var innerText = data.datalist[dataIndex].DOC_NAME a.innerHTML=innerText; a.addEventListener('click',function(e)&#123; e.preventDefault(); //取消默认事件，指a标签 initImages(data.datalist[dataIndex].DOC_CODE); &#125;); $("#all-items").append(a); &#125;)(dataIndex); &#125; &#125;else&#123; mini.alert(data.msg); &#125; &#125; &#125;) &#125; //加载右侧的图片信息 function initImages(docCode)&#123; $.ajax(&#123; url:eg.getRequestUrl()+'/imgManage/getImagesByApplyIdAndDocCode', type:'GET', data:&#123;applyId:applyId,docCode:docCode&#125;, dataType:'json', success:function(data)&#123; if(data.code == 0)&#123;//遍历显示图片 var imageList = data.datalist; $(this).addClass('cur').siblings('a').removeClass('cur'); //$.trim($("#hname").text($(this).text())); var li = ''; for (var i = 0, l = imageList.length; i &lt; l; i++)&#123; li += "&lt;li class='catImg'&gt;&lt;img data-original='"+eg.getRequestUrl()+imageList[i].FILE_PATH+imageList[i].FILE_ID+imageList[i].FILE_TYPE+"' src='"+eg.getRequestUrl()+imageList[i].FILE_PATH+imageList[i].FILE_ID+imageList[i].FILE_TYPE+"'&gt;&lt;/li&gt;"; &#125; $("#jq22").html(li); viewer.update(); &#125;else&#123; mini.alert(data.msg,"温馨提示"); &#125; &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端插件</category>
        <category>imageview</category>
      </categories>
      <tags>
        <tag>imageview</tag>
        <tag>图片预览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不重复随机数的产生]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BA%A7%E7%94%9F%2F</url>
    <content type="text"><![CDATA[123456int a[100]=0;for(i=0;i=99;i++)&#123;while(a[m=rand()0])a[m]=i;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP GET POST请求]]></title>
    <url>%2F2019%2F01%2F25%2FHTTP-GET-POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.oemp.common; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; /** * @author Post Method */ public class HttpPostUrl &#123; /** * 向指定URL发送POST请求 * @param url * @param paramMap * @return 响应结果 */ public static String sendPost(String url, Map&lt;String, String&gt; paramMap) &#123; PrintWriter out = null; BufferedReader in = null; String result = ""; try &#123; URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty("accept", "*/*"); conn.setRequestProperty("connection", "Keep-Alive"); conn.setRequestProperty("user-agent","Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)"); // conn.setRequestProperty("Charset", "UTF-8"); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 设置请求属性 String param = ""; if (paramMap != null &amp;&amp; paramMap.size() &gt; 0) &#123; Iterator&lt;String&gt; ite = paramMap.keySet().iterator(); while (ite.hasNext()) &#123; String key = ite.next();// key String value = paramMap.get(key); param += key + "=" + value + "&amp;"; &#125; param = param.substring(0, param.length() - 1); &#125; // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123; System.err.println("发送 POST 请求出现异常！" + e); e.printStackTrace(); &#125; // 使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125; /** * 数据流post请求 * @param urlStr * @param xmlInfo */ public static String doPost(String urlStr, String strInfo) &#123; String reStr=""; try &#123; URL url = new URL(urlStr); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setRequestProperty("Pragma:", "no-cache"); con.setRequestProperty("Cache-Control", "no-cache"); con.setRequestProperty("Content-Type", "text/xml"); OutputStreamWriter out = new OutputStreamWriter(con.getOutputStream()); out.write(new String(strInfo.getBytes("utf-8"))); out.flush(); out.close(); BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), "utf-8")); String line = ""; for (line = br.readLine(); line != null; line = br.readLine()) &#123; reStr += line; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return reStr; &#125; /** * 测试主方法 * @param args */ public static void main(String[] args) &#123; Map&lt;String, String&gt; mapParam = new HashMap&lt;String, String&gt;(); mapParam.put("name", "张三"); mapParam.put("validation","test"); String pathUrl = "http://localhost/testPost.action"; String result = sendPost(pathUrl, mapParam); System.out.println(result); &#125; &#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>公共类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP请求</tag>
        <tag>GET</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json树组装TreeBuilder(适用在bootstrap_treeview)]]></title>
    <url>%2F2019%2F01%2F25%2FJson%E6%A0%91%E7%BB%84%E8%A3%85TreeBuilder-%E8%AF%95%E7%94%A8%E5%9C%A8bootstrap-treeview%2F</url>
    <content type="text"><![CDATA[数据的结构如下： 节点ID 父节点ID 显示的内容 其他内容 01 “” 01 “” 02 “” 02 “” 0101 01 0101 “” 0102 01 0102 “” 010101 0101 010101 “” 12345SELECT ID, ORG_NO, ORG_NAME, P_LEVEL, PARENT_ID FROM SYS_ORG START WITH PARENT_ID = '0'CONNECT BY PRIOR ID = PARENT_IDORDER SIBLINGS BY LEVEL_SORT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package com.ms.module.fw.biki;import java.util.*;import net.sf.json.JSONArray;public class TreeBuilder &#123; List&lt;TreeBuilder.Node&gt; nodes = new ArrayList&lt;TreeBuilder.Node&gt;(); public TreeBuilder(List&lt;Node&gt; nodes) &#123; super(); this.nodes = nodes; &#125; /** * 构建JSON树形结构 * @return */ public String buildJSONTree() &#123; List&lt;Node&gt; nodeTree = buildTree(); JSONArray jsonArray = JSONArray.fromObject(nodeTree); return jsonArray.toString(); &#125; /** * 构建树形结构 * @return */ public List&lt;Node&gt; buildTree() &#123; List&lt;Node&gt; treeNodes = new ArrayList&lt;Node&gt;(); List&lt;Node&gt; rootNodes = getRootNodes(); for (Node rootNode : rootNodes) &#123; buildChildNodes(rootNode); treeNodes.add(rootNode); &#125; return treeNodes; &#125; /** * 递归子节点 * @param node */ public void buildChildNodes(Node node) &#123; List&lt;Node&gt; children = getChildNodes(node); if (!children.isEmpty()) &#123; for (Node child : children) &#123; buildChildNodes(child); &#125; node.setMenus(children); &#125; &#125; /** * 获取父节点下所有的子节点 * @param nodes * @param pnode * @return */ public List&lt;Node&gt; getChildNodes(Node pnode) &#123; List&lt;Node&gt; childNodes = new ArrayList&lt;Node&gt;(); for (Node n : nodes) &#123; if (pnode.getId().equals(n.getPid())) &#123; childNodes.add(n); &#125; &#125; return childNodes; &#125; /** * 判断是否为根节点 * 遍历所有节点，如果能找到他们的节点ID = 当前节点的父节点ID，说明不是root节点 * @param nodes * @param inNode * @return */ public boolean rootNode(Node node) &#123; boolean isRootNode = true; for (Node n : nodes) &#123; if (node.getPid().equals(n.getId())) &#123; isRootNode = false; break; &#125; &#125; return isRootNode; &#125; /** * 获取集合中所有的根节点 * @param nodes * @return */ public List&lt;Node&gt; getRootNodes() &#123; List&lt;Node&gt; rootNodes = new ArrayList&lt;Node&gt;(); for (Node n : nodes) &#123; if (rootNode(n)) &#123; rootNodes.add(n); &#125; &#125; return rootNodes; &#125; public static class Node &#123; private String id; private String pid; private String text; private String url; private List&lt;Node&gt; menus; public Node() &#123; &#125; public Node(String id, String pid, String text, String url) &#123; super(); this.id = id; this.pid = pid; this.text = text; this.url = url; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getPid() &#123; return pid; &#125; public void setPid(String pid) &#123; this.pid = pid; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public List&lt;Node&gt; getMenus() &#123; return menus; &#125; public void setMenus(List&lt;Node&gt; menus) &#123; this.menus = menus; &#125; &#125; public static void main(String[] args) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); Node p1 = new Node("01", "", "01", ""); Node p6 = new Node("02", "", "02", ""); Node p7 = new Node("0201", "02", "0201", ""); Node p2 = new Node("0101", "01", "0101", ""); Node p3 = new Node("0102", "01", "0102", ""); Node p4 = new Node("010101", "0101", "010101", ""); Node p5 = new Node("010102", "0101", "010102", ""); nodes.add(p1); nodes.add(p2); nodes.add(p3); nodes.add(p4); nodes.add(p5); nodes.add(p6); nodes.add(p7); TreeBuilder treeBuilder = new TreeBuilder(nodes); System.out.println(treeBuilder.buildJSONTree()); &#125;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>公共类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TreeBuilder</tag>
        <tag>bootstrap_treeview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据request获取用户IP地址公共方法]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%A0%B9%E6%8D%AErequest%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7IP%E5%9C%B0%E5%9D%80%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获取用户真实IP地址，不使用request.getRemoteAddr();的原因是有可能用户使用了代理软件方式避免真实IP地址,可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值，究竟哪个才是真正的用户端的真实IP呢？答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。如：X-Forwarded-For：192.168.1.110, 192.168.1.120, 192.168.1.130,192.168.1.100用户真实IP为： 192.168.1.110 具体的代码如下：12345678910111213141516171819public static String getIpAddress(HttpServletRequest request) &#123; String ip = request.getHeader("x-forwarded-for"); if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("Proxy-Client-IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("WL-Proxy-Client-IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("HTTP_CLIENT_IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("HTTP_X_FORWARDED_FOR"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return ip;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>用户IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA小知识点]]></title>
    <url>%2F2019%2F01%2F24%2FJAVA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[创建List的技巧方法,简单高效、暴力1List&lt;String&gt; list = Arrays.asList("role1","role2","role3"); 数据类型…的使用（不确定参数数量的方法使用）当出现方法的参数不确定个数的时候（参数的类型一样）可以使用数据类型...目前测试了String、int是可以使用的12345678910@Testpublic void testString()&#123; testStrings(&quot;123123&quot;,&quot;123234234&quot;,&quot;asdasd&quot;);&#125;protected void testStrings(String... strargs)&#123; for(String tempStr:strargs)&#123; System.out.println(tempStr); &#125;&#125; 数字数据格式化有些需要格式化为001、002的需求1new DecimalFormat("000").format(123) Java后台获取项目路径(classpath和resourcepath)123456789101112131415public static String getClasspath()&#123; String path = (String.valueOf(Thread.currentThread().getContextClassLoader().getResource(""))+"../../").replaceAll("file:/", "").replaceAll("%20", " ").trim(); if(path.indexOf(":") != 1)&#123; path = File.separator + path; &#125; return path;&#125;public static String getClassResources()&#123; String path = (String.valueOf(Thread.currentThread().getContextClassLoader().getResource(""))).replaceAll("file:/", "").replaceAll("%20", " ").trim(); if(path.indexOf(":") != 1)&#123; path = File.separator + path; &#125; return path;&#125; 将含有英文逗号的字符串转成JSONArrayString tempStr = “1,2,3,4,5”;JSON.parseArray(“[“+tempStr+”]”)]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片验证码，解决了Session不同步的问题]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86Session%E4%B8%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package cn.gov.csrc.servlet; import java.awt.Color; import java.awt.Font; import java.awt.Graphics; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGImageEncoder; public class CodeServlet extends HttpServlet &#123; /** * 产生验证码图片 */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("image/jpeg"); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "No-cache"); response.setDateHeader("Expires", 0L); int width = 80; int height = 30; BufferedImage image = new BufferedImage(width, height, 1); Graphics g = image.getGraphics(); Random random = new Random(); g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font("Arial", 0, 25)); g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width + 100); int y = random.nextInt(height + 100); int xl = random.nextInt(10); int yl = random.nextInt(12); g.drawOval(x, y, x + xl, y + yl); &#125; String code = request.getParameter("code"); String sRand = code; for (int i = 0; i &lt; sRand.length(); i++) &#123; String rand = sRand.substring(i, i + 1); g.setColor(new Color(20 + random.nextInt(110), 20 + random .nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 14 * i + 5, 25); &#125; g.dispose(); javax.servlet.ServletOutputStream imageOut = response.getOutputStream(); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(imageOut); encoder.encode(image); &#125; private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; &#125; Web.xml文件： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.gov.csrc.servlet.CodeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/CodeServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; index.jsp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/"; %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;验证码测试&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;script language="javascript" type="text/javascript"&gt; var code ; //在全局 定义验证码 function createCode()&#123; code = ""; var codeLength = 5;//验证码的长度 //所有候选组成验证码的字符，可以用中文 var selectChar = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C', 'D','E','F','G','H','I','J','K','L','M','N','O','P', 'Q','R','S','T','U','V','W','X','Y','Z','a','b','c', 'd','e','f','g','h','i','j','k','l','m','n','o','p', 'q','r','s','t','u','v','w','x','y','z'); for(var i=0;i&lt;codeLength;i++)&#123; var charIndex = Math.floor(Math.random()*60); code +=selectChar[charIndex]; &#125; return code; &#125; function validate ()&#123; var inputCode = document.getElementById("vcode").value.toLowerCase(); if(inputCode.length &lt;=0)&#123; alert("请输入验证码！"); return false; &#125; else if(inputCode != code.toLowerCase())&#123; alert("验证码输入错误！"); show();//刷新验证码 return false; &#125;else&#123; alert("^-^ OK"); return true; &#125; &#125; function show()&#123; //显示验证码 document.getElementById("code").src="CodeServlet?code="+createCode(); &#125; window.onload = function() &#123; //document.onload=show(); show();//页面加载时加载验证码 //这时无论在ie还是在firefox中，js没有加载完，页面的东西是不会被执行的； &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form onsubmit="return validate();" action="" method="post"&gt; &lt;h3&gt;jsp+js+servlet实现验证码&lt;/h3&gt; &lt;br /&gt; 用户名：&lt;input type="text" name="" /&gt;&lt;br /&gt; 请输入验证码： &lt;input type="text" id="vcode" style="width: 60;" maxLength="5" /&gt; &lt;img src="" id="code" /&gt; &lt;a href="#" mce_href="#" onclick="javascript:show();return false;"&gt;看不清,换一张!&lt;/a&gt;&lt;br /&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>功能相关</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat错误信息界面版本信息泄露]]></title>
    <url>%2F2019%2F01%2F24%2FTomcat%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%95%8C%E9%9D%A2%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[问题描述Tomcat报错页面出现Tomcat版本信息的泄露，具体的效果图见下图 解决方案 进入tomcat/lib下，使用电脑自带的软件解压开文件夹下面的catalina.jar文件，然后找到路径\org\apache\catalina\util路径下的ServerInfo.properties 编辑ServerInfo.properties文件，修改最后三行代码，去掉对应的版本信息，修改后的效果如下图所示 改完后保存，替换到lib包下面的jar包，重启Tomcat，查看报错页面显示的错误信息]]></content>
      <categories>
        <category>安全测评</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx版本信息泄露漏洞解决]]></title>
    <url>%2F2019%2F01%2F24%2Fnginx%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题描述 nginx版本信息的泄露有可能会造成攻击者获取更多的信息 nginx在curl的时候是能看到nginx版本信息的，具体的界面显示如下图所示,可以看到其中有个Server:nginx/1.15.8： 解决方案 修改nginx主配置文件：nginx.conf,取消注释或添加配置语句 12345http &#123; # ...省略一些配置 server_tokens off; #默认是注释掉的 # ...省略一些配置&#125; 编辑php-fpm配置文件，如fastcgi.conf或fcgi.conf（这个配置文件名也可以自定义的，根据具体文件名修改） 12345# 找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;# 修改为fastcgi_param SERVER_SOFTWARE nginx; 重新加载nginx配置文件 12# /etc/init.d/nginx reload 或# service nginx reload 验证是否生效1234567# curl -v -X 192.168.31.7HTTP/1.1 200 OKServer: nginxDate: Tue, 13 Jul 2010 14:26:56 GMTContent-Type: text/html; charset=UTF-8Connection: keep-aliveVary: Accept-Encoding]]></content>
      <categories>
        <category>安全测评</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread 基础使用方法]]></title>
    <url>%2F2019%2F01%2F24%2FJava-Thread-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[线程运行状态的几个方法 start方法 用来启动一个线程，当调用start方法的时候，系统才会开启一个新的线程来执行用户定义的子任务，并为线程分配需要的资源 run方法 run()方法不需要用户调用，当通过start启动一个线程的时候，当线程或得了CPU执行时间，便会自动进入到run方法去执行具体的任务。*继承Thread类必须要重写run方法，在run中定义具体要执行的任务。 sleep方法 12sleep(long millis) //参数为毫秒sleep(long millis,int nanoseconds) // 第一个参数为毫秒，第二个参数为纳秒 sleep相当于让线程睡眠，交出CPU，去执行其他任务。 但是sleep方法不会释放锁，某个对象加锁，则即使调用sleep方法，其他线程也无法访问这个对象： 123456789101112131415161718192021222324252627282930313233public class Test &#123; private int i = 10; private Object object = new Object(); public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; synchronized (object) &#123; i++; System.out.println("i:"+i); try &#123; System.out.println("线程"+Thread.currentThread().getName()+"进入睡眠状态"); Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println("线程"+Thread.currentThread().getName()+"睡眠结束"); i++; System.out.println("i:"+i); &#125; &#125; &#125;&#125; 输出结果如下： 123456789i:11线程Thread-0进入睡眠状态线程Thread-0睡眠结束i:12i:13线程Thread-1进入睡眠状态Disconnected from the target VM, address: '127.0.0.1:13332', transport: 'socket'线程Thread-1睡眠结束i:14 *从上面的输出结果可以看出，当Thread0进入睡眠状态之后，Thread1并没有去执行具体的任务，只有当Thread0执行完成后，此时Thread0释放了对象锁，Thread1才开始执行 yield方法 调用yield方法会让当前线程交出CPU权限，让CPU去执行其他线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体交出的CPU时间，另外yield方法只能让拥有相同优先级的线程获取CPU执行时间的机会。 * 调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点和sleep方法不一样的 join方法 123join()join(long millis) //参数为毫秒join(long millis,int nanoseconds) //第一个参数为毫秒，第二个参数为纳秒 假如在main线程中，调用thread.join方法,则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread方法执行完毕，如果调用的是指定时间join方法，则等待一定的时间 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; System.out.println("进入线程"+Thread.currentThread().getName());//执行顺序① Test test = new Test(); MyThread thread1 = test.new MyThread(); thread1.start(); try &#123; System.out.println("线程"+Thread.currentThread().getName()+"等待");//执行顺序② thread1.join(); System.out.println("线程"+Thread.currentThread().getName()+"继续执行");//执行顺序⑤ &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println("进入线程"+Thread.currentThread().getName());//执行顺序③ try &#123; Thread.currentThread().sleep(5000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println("线程"+Thread.currentThread().getName()+"执行完毕");//执行顺序④ &#125; &#125;&#125; 输出结果如下： 12345①进入线程main②线程main等待③进入线程Thread-0④线程Thread-0执行完毕⑤线程main继续执行 可以看出，当调用thread1.join()方法后，main线程会进入等待，然后等待thread1执行完之后再继续执行。 interrupt方法 中断方法，单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就是说，它可以用来中断一个正处在阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("进入睡眠状态"); Thread.currentThread().sleep(10000); System.out.println("睡眠完毕"); &#125; catch (InterruptedException e) &#123; System.out.println("得到中断异常"); &#125; System.out.println("run方法执行完毕"); &#125; &#125;&#125; 输出结果如下： 123进入睡眠状态得到中断异常run方法执行完毕 从上面的结果输出可以看出： 当线程调用interrupt的时候，中断处于阻塞状态的线程。12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; &#125;&#125; 上面的程序会一直执行下去，执行到Int的最大值，说明了一点interrupt方法不能中断正在运行中的线程 但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志置为true，那么可以通过调用isInterrupted()判断中断标志是否被置为中断。1234567891011121314151617181920212223242526272829package com.xydtech.controller.prdman.prdconfig;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(!isInterrupted()&amp;&amp;i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; &#125;&#125; 上面这段代码中，设置thread为interrupt之后，内部while循环的时候查询到不满足条件了，自然退出了循环，但是一般不建议通过这种方式来中断线程，一般会在Thread中添加一个属性isStop来指标是否结束while循环，然后再在while循环中判断isStop的值123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); thread.setStop(true); &#125; catch (InterruptedException e) &#123; &#125; &#125; class MyThread extends Thread&#123; boolean isStop = false; @Override public void run() &#123; int i = 0; while(!isStop &amp;&amp; i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; public void setStop(boolean stop) &#123; isStop = stop; &#125; &#125; stop方法destroy方法这两个方法基本上被废弃了，基本上不会被使用到 线程相关属性的方法 getId() 得到线程的IDgetName()和setName() 用来得到或者设置线程的名称getPriority和setPriority 用来获取和设置线程的优先级setDaemon和isDaemon用来设置线程为守护线程和判断线程是否为守护线程。 *重点：守护线程和用户线程的却别是，守护线程依赖于创建它的线程，而用户线程不依赖于创建它的线程，当mian方法运行完毕后，守护线程会随之消亡。但是用户线程不会消失，直至其运行完毕。在JVM中，垃圾收集器线程就是守护线程。Thread类中有一个比较常用的静态类方法currentThread用来获取当前线程。 方法调用和Thread的生命周期关系]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java子线程执行完毕之后，主线程继续执行]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[业务说明：项目中经常会出现将一个庞大的业务拆分成多个小部分，独自在分内运行，但前后任务之间又需要一定的执行顺序，所以就用到了标题中的“主线程执行过程中等待子线程都异步执行完成后才继续执行的问题” 第一个简单的例子123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); &#125; System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程在执行!"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面这段代码输出如下结果，很明显，这个是主线程执行完成之后，子线程又执行的，这个先后顺序不确定，因为有可能若干个子线程执行完后，主线程才执行到执行结束1234567891011主线程已经执行结束了!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行! 能解决问题的第一个例子12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); try &#123; for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); myThread.join(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程在执行!"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面这段代码是能够实现子线程执行完毕之后，再执行主线程，但是存在一个问题就是子线程是一个一个顺序执行的，也就没有了意义，所以可以看下下面的异步执行的代码1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); long beginTime = System.currentTimeMillis(); Vector&lt;MyThread&gt; myThreadVector = new Vector&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); myThreadVector.add(myThread); &#125; for(MyThread tempMyThread : myThreadVector)&#123; try &#123; tempMyThread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("一共执行了"+(System.currentTimeMillis() - beginTime)+"ms"); System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程开始执行！"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 简单解析一下上面的代码：首先上面的代码输出如下：12345678910111213子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！Disconnected from the target VM, address: &apos;127.0.0.1:14413&apos;, transport: &apos;socket&apos;一共执行了1027ms主线程已经执行结束了! 首先创建一个Vector，然后通过创建Thread塞入到Vector中，然后再遍历Vector进行join动作，这样就可以不需要考虑子线程中sleep，动态的启动所有的线程]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编码规范]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[版权说明：本文档摘抄自《阿里巴巴Java开发手册（详尽版）》 摘抄不意味着单纯的Copy，而是对别人知识汲取和吸收的同时添加自己的个人理解 Java 编码规则手册 版本号 更新时间 备注 V1.0 2018-11-22 初始化版本 一、编程规约（一）命名风格 【强制】代码中的命名不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例：_name/__name/$name/name_/name$/name__ 【强制】代码中命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式 说明：正确的英文拼写和语法可以让阅读者易于理解，便面歧义 反例：DaZhePromotion()[打折]/getPingFenByName()[获取评分]/int 某变量=3 【强制】类名使用UpperCameCase风格，但以下情况例外DO/BO/DTO/VO/AO/PO/UID等 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCameCase风格，必须遵从驼峰形式。 正例：localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，尽量将语义表达清楚，不要害怕变量长度太长。 正例：MAX_STOCK_COUNT 反例：MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾 【强制】类型与中括号紧挨相连来表示数组 正例：定义整形数组 int[] arrayDemo 反例：在 main 参数中，使用 String args[]来定义 【强制】POJO 类中布尔类型的变量，都不要加 is前缀，否则部分框架解析会引起序列化错误 反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式 正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils 【强制】杜绝完全不规范的缩写，避免望文不知义 反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【强制】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意 正例：在JDK中，表达原子更新的类名为：AtomicReferenceFieldUpdater 反例：变量 int a 的随意命名方式 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念 正例：public class OrderFactory;,public class LoginProxy;,public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量 正例：接口方法签名void commit();接口基础常量 String COMPANY = &quot;alibaba&quot;; 反例：接口方法定义 public abstract void f(); 说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现 接口和实现类的命名有两套规则 1）【强制】对于 Service和DAO类，基于 SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别 正例：CacheServiceImpl 实现 CacheService接口 2）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形式） 正例：AbstractTranslator 实现 Translatable接口 【参考】枚举类名建议带上 Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开 说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有 正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON 【参考】 Service/DAO层方法命名规则 获取单个对象的方法用 get做前缀 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects 获取统计值的方法用 count 做前缀 插入的方法用 save/insert做前缀 删除的方法用 remove/delete 做前缀 修改的方法用 update做前缀 领域模型命名规约 数据对象：xxxDO，xxx 即为数据表名 数据传输对象：xxxDTO，xxx为业务领域相关的名称 展示对象：xxxVO，xxx一般为网页名称 POJO是 DO/DTO/BO/VO的统称，禁止命名成 xxxPOJO （二）常量定义 【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中反例： 1234//Magic values, except for predefined, are forbidden in coding.if (key.equals("Id#taobao_1")) &#123; //...&#125; 正例： 1234String KEY_PRE = "Id#taobao_1"; if (KEY_PRE.equals(key)) &#123; //...&#125; 【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护 说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护 正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下 反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量 ​ 类 A 中：public static final String YES = &quot;yes&quot;; ​ 类 B 中：public static final String YES = &quot;y&quot;; ​ A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题 子工程内部共享常量：即在当前子工程的 constant 目录下 包内共享常量：即在当前包下单独的constant目录下 类内共享常量：直接在类内部 private static final 定义 【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义（扩展enmu的使用方法）说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节正例： 12345678public enum SeasonEnum &#123; SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4); private int seq; SeasonEnum(int seq) &#123; this.seq = seq; &#125;&#125; （三）代码格式 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则 左大括号前不换行 左大括号后换行 右大括号前换行 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行 【强制】左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。详见第 5 条下方正例提示 反例：if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格 【强制】任何二目、三目运算符的左右两边都需要加一个空格 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等 【强制】采用 4 个空格缩进，禁止使用 tab 字符说明：如果使用tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character（扩展IDEA设置按TAB时输入四个空格的方法）；而在 eclipse 中，必须勾选 insert spaces for tabs正例： 12345678910111213141516171819public static void main(String[] args) &#123; // 缩进 4 个空格 String say = "hello"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println("world"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println("ok"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 【强制】注释的双斜线与注释内容之间有且仅有一个空格正例： 12// 这是示例注释，请注意在双斜线之后有一个空格String ygb = new String(); 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则- 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例- 运算符与下文一起换行- 方法调用的点符号与下文一起换行- 方法调用中的多个参数需要换行时，在逗号后进行- 在括号前不要换行，见反例正例： 123456StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append("zi").append("xin") .append("huang") .append("huang") .append("huang"); 反例： 1234567StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，不要在括号前换行sb.append("zi").append("xin")...append("huang");// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行method(args1, args2, args3, ..., argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格 正例：下例中实参的args1，后边必须要有一个空格 method(args1, args2, args3); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows格式 【推荐】单个方法的总行数不超过 80 行 说明：包括方法签名、结束右大括号、方法内代码、注释、空行、回车及任何不可见字符的总行数不超过 80 行 正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐正例： 1234int one = 1;long two = 2L;float three = 3F;StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情 【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性 说明：任何情形，没有必要插入多个空行进行隔开 （四）OOP规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可 【强制】所有的覆写方法，必须加@Override 注解 说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）正例： 1public List&lt;User&gt; listUsers(String type, Long... ids) &#123;...&#125; 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么正例： 1234@Deprecatedpublic static String toJson(Object obj) &#123; return toJson(getAttributes(obj));&#125; 【强制】不能使用过时的类或方法 说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么 【强制】Object 的 equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 正例：&quot;test&quot;.equals(object); 反例：object.equals(&quot;test&quot;) 说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断 关于基本数据类型与包装数据类型的使用标准如下 【强制】所有的 POJO 类属性必须使用包装数据类型 【强制】RPC 方法的返回值和参数必须使用包装数据类型 【推荐】所有的局部变量使用基本数据类型 说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE(空指针异常)问题，或者入库检查，都由使用者来保证 正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险 反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出 【强制】定义 DO/DTO/VO 等 POJO类时，不要设定任何属性默认值 反例：POJO 类的 gmtCreate 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中 【强制】POJO 类必须写toString 方法。使用 IDE 中的工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题 【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和getXxx()方法 说明：框架在调用属性 xxx的提取方法时，并不能确定哪个方法一定是被优先调用到 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险说明： 1234String str = "a,b,c,,";String[] ary = str.split(",");// 预期大于 3，结果是 3System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 16 条规则 【推荐】类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度反例： 1234567public Integer getData() &#123; if (condition) &#123; return this.data + 100; &#125; else &#123; return this.data - 100; &#125;&#125; 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费(扩展Java中的String，StringBuilder，StringBuffer三者的区别)反例： 1234String str = "start";for (int i = 0; i &lt; 100; i++) &#123; str = str + "hello";&#125; 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字 不允许被继承的类，如：String 类 不允许修改引用的域对象 不允许被重写的方法，如：POJO 类的 setter 方法 不允许运行过程中重新赋值的局部变量 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构 【推荐】慎用 Object 的 clone方法来拷贝对象 说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现域对象的深度遍历式拷贝 【推荐】类成员与方法访问控制从严 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private 工具类不允许有 public 或 default 构造方法 类非 static 成员变量并且与子类共享，必须是 protected 类非 static成员变量并且仅在本类使用，必须是 private 类 static 成员变量如果仅在本类使用，必须是 private 若是 static成员变量，考虑是否为 final 类成员方法只供类内部调用，必须是 private 类成员方法只对继承类公开，那么限制为 protected 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的 （五）集合处理 【强制】关于 hashCode 和 equals的处理，遵循如下规则 只要重写 equals，就必须重写 hashCode 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals 说明：String重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用 【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList 说明：subList 返回的是ArrayList 的内部类SubList，并不是 ArrayList 而是ArrayList的一个视图，对于 SubList子列表的所有操作最终会反映到原列表上 【强制】在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()说明：使用toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致正例： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add("guan");list.add("bao");String[] array = new String[list.size()];array = list.toArray(array); 反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常 说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组 12String[] str = new String[] &#123; "you", "wu" &#125;;List list = Arrays.asList(str) 第一种情况：list.add(&quot;yangguanbao&quot;); 运行时异常 第二种情况：str[0] = &quot;gujin&quot;; 那么 list.get(0)也会随之修改 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而&lt;? super T&gt;不能使用 get 方法，作为接口调用赋值时易出错 说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt; 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁正例： 12345678910List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("1");list.add("2");Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 反例： 12345for (String item : list) &#123; if ("1".equals(item)) &#123; list.remove(item); &#125;&#125; 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗 【强制】在 JDK7 版本及以上，Comparator（扩展Java] 用 Comparator 实现排序） 实现类要满足如下三个条件，不然Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常 说明：三个条件如下 x，y 的比较结果和 y，x 的比较结果相反 x&gt;y，y&gt;z，则 x&gt;z x=y，则 x，z 比较结果和 y，z 比较结果相同 反例：下例中没有处理相等的情况，实际使用中可能会出现异常 123456new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125;; 【推荐】集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略说明：菱形泛型，即 diamond，直接使用&lt;&gt;来指代前边已经指定的类型正例： 1234// &lt;&gt; diamond 方式HashMap&lt;String, String&gt; userCache = new HashMap&lt;&gt;(16);// 全省略方式ArrayList&lt;User&gt; users = new ArrayList(10); 【推荐】集合初始化时，指定集合初始值大小 说明：HashMap使用 HashMap(int initialCapacity)初始化 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法 正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合 【推荐】高度注意 Map 类集合K/V能不能存储null 值的情况，如下表格 | 集合类 | Key | Value | Super | 说明 || —————– | ————————————– | ————————————– | ———– | ———————- || Hashtable | 不允许为 null | 不允许为 null | Dictionary | 线程安全 || ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 锁分段技术（JDK8:CAS） || TreeMap | 不允许为 null | 允许为 null | AbstractMap | 线程不安全 || HashMap | 允许为 null | 允许为 null | AbstractMap | 线程不安全 | 反例：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常 【推荐】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响 说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是order/sort 【推荐】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List的contains 方法进行遍历、对比、去重操作 （六）并发处理 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全 说明：资源驱动类、工具类、单例工厂类都需要注意 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯正例： 123456public class TimerTaskThread extends Thread &#123; public TimerTaskThread() &#123; super.setName("TimerTaskThread"); ... &#125;&#125; 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程（扩展Java并发编程：线程池的使用） 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 说明：Executors返回的线程池对象的弊端如下 FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类 正例：注意线程安全，使用 DateUtils。亦推荐如下处理： 123456private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat("yyyy-MM-dd"); &#125;&#125;; 说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次 【强制】多线程并行处理定时任务时，Timer运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService则没有这个问题 【强制】禁止在循环中调用synchronized（同步）方法说明：方法的同步需要消耗相当大的资源，不要在循环中调用同步方法反例： 1234567891011import java.util.Vector;public class SYN &#123; public synchronized void method (Object o) &#123; &#125; private void test () &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; method (vector.elementAt(i)); // violation &#125; &#125; private Vector vector = new Vector (5, 5);&#125; 正例： 12345678910111213import java.util.Vector;public class SYN &#123; public void method (Object o) &#123; &#125;private void test () &#123;synchronized&#123;//在一个同步块中执行非同步方法 for (int i = 0; i &lt; vector.size(); i++) &#123; method (vector.elementAt(i)); &#125; &#125; &#125; private Vector vector = new Vector (5, 5);&#125; 【强制】禁止在循环中使用表达式说明：在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快反例： 1234567import java.util.Vector;class CEL &#123; void method (Vector vector) &#123; for (int i = 0; i &lt; vector.size (); i++) // Violation ; // ... &#125;&#125; 正例： 1234567class CEL_fixed &#123; void method (Vector vector) &#123; int size = vector.size () for (int i = 0; i &lt; size; i++) ; // ... &#125;&#125; 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果 说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降（扩展多线程下生成随机数） 说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式 正例：在 JDK7 之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型反例： 1234567891011class LazyInitDemo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125;// other methods and fields...&#125; （七）控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件 说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替 反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止 【强制】在 if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成 12345 if (condition) &#123; ... return obj; &#125;// 接着写 else 的业务逻辑代码; 说明：如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层 正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下 123456789101112public void today() &#123; if (isBusy()) &#123; System.out.println(“change time.”); return; &#125; if (isFree()) &#123; System.out.println(“go to travel.”); return; &#125; System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return;&#125; 【推荐】除常用方法（如getXxx/isXxx等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢正例： 12345// 伪代码如下final boolean existed = (file.open(fileName, "w") != null) &amp;&amp; (...) || (...);if (existed) &#123; ...&#125; 反例： 123if ((file.open(fileName, "w") != null) &amp;&amp; (...) || (...)) &#123; ...&#125; 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外） 【推荐】避免采用取反逻辑运算符 说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法 正例：使用if (x &lt; 628)来表达 x 小于 628 反例：使用 if (!(x &gt;= 628)) 来表达 x 小于 628 【推荐】接口入参保护，这种场景常见的是用作批量操作的接口 【推荐】下列情形，需要进行参数校验： 调用频次低的方法 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失 需要极高稳定性和可用性的方法 对外提供的开放接口，不管是 RPC/API/HTTP 接口 敏感权限入口 【推荐】下列情形，不需要进行参数校验 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO的参数校验，可以省略 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数 （八）注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容\/格式，不得使用// xxx 方式 说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：对子类的实现要求，或者调用注意事项，请一并说明 【强制】所有的类都必须添加创建者和创建日期 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可 反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义 【推荐】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除 说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码） 【推荐】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 【推荐】核心代码注释量不得低于文件总行数的30%，非核心代码注释量不得低于文件总行数的20% （九）其他 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”) 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法 说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime() 说明：如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类 【强制】删除未引用类，避免使用以”.*”结尾的引用，引用的顺序如下： JDK标准包（例如：import java.io.IOException等） 第三方的包（例如：import org.dom4j.Node等） 项目的公共包 【强制】禁止在循环体中生命并实例化变量说明：在循环体中声明并实例化临时变量将会增加内存消耗，增加垃圾回收的次数；尤其是大对象，严格禁止在循环体内声明并实例化对象反例： 123456789import java.util.Vector;public class LOOP &#123; void method (Vector v) &#123; for (int i=0;i &lt; v.size();i++) &#123; Object o = new Object(); // 不建议 o = v.elementAt(i); &#125; &#125;&#125; 正例： 123456789import java.util.Vector;public class LOOP &#123; void method (Vector v) &#123; Object o; for (int i=0;i&lt;v.size();i++) &#123; o = v.elementAt(i); &#125; &#125;&#125; 【推荐】不要在视图模板中加入任何复杂的逻辑 说明：根据 MVC理论，视图的职责是展示，不要抢模型和控制器的活 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存 【推荐】及时清理不再使用的代码段或配置信息 说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余 正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由 二、异常日志（一）异常处理 【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过 catch NumberFormatException 来实现 正例：if (obj != null) {...} 反例：try { obj.method(); } catch (NullPointerException e) {…} 【强制】异常不要用来做流程控制，条件控制 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多 【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理 说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch 说明：如果 JDK7 及以上，可以使用 try-with-resources 方式（扩展Java进阶知识点3：更优雅地关闭资源 - try-with-resource及其异常抑制） 【强制】不要在 finally 块中使用 return 说明：finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值 说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null 的情况 【强制】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE 数据库的查询结果可能为 null 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null 远程调用返回对象时，一律要求进行空指针判断，防止 NPE 对于 Session 中获取的数据，建议 NPE 检查，避免空指针 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE 正例：使用JDK8 的 Optional 类来防止 NPE 问题。（扩展Java8 如何正确使用 Optional） 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等 【推荐】对于公司外的 http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息” 说明：关于 RPC 方法返回方式使用 Result 方式的理由 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题 【推荐】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化 正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {...} （二）日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式 appName_logType_logName.log logType:日志类型，如 stats/monitor/access 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找 正例：mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式 说明：logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印 正例：（条件）建设采用如下方式 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);&#125; 正例：（占位符） 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml中设置 additivity=false。 正例：&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出 正例：logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e); 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从 三、安全规约 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库 【强制】用户请求传入的任何参数必须做有效性验证 说明：忽略参数校验可能导致 page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS 说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据 【强制】表单、AJAX 提交必须执行 CSRF 安全验证 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 四、MySQL数据库（一）建表规约 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否） 说明：任何字段如果是非负数，必须是unsigned 注意：POJO类中任何布尔类型的变量，都不要加is前缀，所以，需要在设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取之含义与取值范围 正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL在Windows下不区分大小写，单在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdConfig，level_3_name 【强制】表名不适用复数名词 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 【强制】禁用保留字，如desc、range、match、delayed等，请参照MySQL官方保留字 【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名为idx_字段名。 说明：pk_即primary key；uk_即unique key;idx_即index的简称。 【强制】小数类型为decimal，禁止使用float和double 说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成证书和小数部分分开存储。 【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出一张表，用主键来对应，避免影响其他字段索引效率。 【强制】表必备三个字段：id，gmt_create，gmt_modified 说明：其中id必为主键，类型为bigint unsigned、表单时自增，步长为1。gmt_create，gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新 【推荐】表的命名最好是“业务名称_表的作用” 正例：alipay_task/force_project/trade_config 【推荐】库名尽量与应用名保持一致 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 不是频繁修改的字段 不是varchar超长字段，更不能是text字段 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间，节约索引存储，更重要的是提升检索速度 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围 | 对象 | 年龄区间 | 类型 | 字节 | 表示范围 || ——– | ——— | ——————- | —- | ——————– || 人 | 150岁之内 | tinyint unsigned | 1 | 无符号：0~255 || 龟 | 数百岁 | smallint unsigned | 2 | 无符号：0~65535 || 恐龙化石 | 数千万年 | int unsigned | 4 | 无符号：0~约42.9亿 || 太阳 | 约50亿年 | bigint unsigned | 8 | 无符号：0~10的19次方 | （二）索引规约 【强制】业务上具有唯一特性的字段，及时是多个字段的组合，也必须建成唯一索引 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高了查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生 【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双标join也要注意表索引和SQL性能 【强制】在varchar字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会打到90%以上，可以使用count(distinct left(列名，索引长度))/count(*)的区分度来确定. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引：a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b;索引a_b无法排序 【推荐】利用覆盖索引来进行查询操作，避免全表。 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的中类分别为朱建索引、唯一索引、普通索引三种，而覆盖索引知识一种查询的一种效果，用explain的结果，extra列会出现using index 【推荐】利用延迟关联或者子查询优化超多分页场景 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的地下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联 1SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】防止因字段类型不同造成隐式转换，导致索引失效 【参考】创建索引避免有如下极端误解 宁滥勿缺：任务一个查询就需要建一个索引 宁缺毋滥：认为索引会小号控件、严重拖慢更新和新增速度 地址唯一索引：任务业务的唯一性一律需要在应用层通过“先查后插”方式解决 （三）SQL语句 【强制】不要使用count(列名)或者count(常量)来代替count(\*),count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL或非NULL无关。 说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 【强制】count(distinct col)计算该列除NULL之外的不重复行数，注意count(distinct col1,col2)如果其中一列全为NULL，那么及时另一列有不同的值，也返回0 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但是sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题 正例：可以使用如下方式来避免sum的NPE问题： 1SELECT IF(ISNULL(SUM(g)),0,SUM(g))FROM table; 【强制】使用ISNULL()来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL NULL&lt;&gt;NULL的返回结果是NULL，而不是false NULL=NULL的结果返回值是NULL，而不是true NULL&lt;&gt;1的返回结果是NULL，而不是true 【强制】在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句 【强制】不得使用外检或级联，一切外键概念必须在应用层解决 说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误后才能执行更新语句 【推荐】in操作能避免则避免，是在避免不了，需要仔细评估in后边集合元素数量，控制在1000个内。 【参考】注意字符串统计函数的区别说明： SELECT LENGTH(“轻松工作”);返回12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4 如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码区别 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同 （四）ORM映射 【强制】在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明说明： 增加查询分析器解析成本 增减字段容易与resultMap配置不一致 无用字段增加网络小号，尤其是text类型字段 【强制】不要用resultClass当返回参数，及时所有的类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必须有一个POJO类与之对应 说明：配置映射关系，是字段与DO类解耦，方便维护 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL 注入 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控 【强制】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等 五、Oracle数据库（一）对象命名规范 【强制】数据库名称定义为系统名+模块名说明： 全局数据库名和SID名要求一致 因SID名只能包含字符和数字，所以全局数据库和SID名中不能含有“_”等字符 【强制】表空间命名规范 面向用户的专用数据表空间以用户名+_+data命名 ，如Aud 用户专用数据表空间可命名为Aud_data 面向用户的专用索引表空间以用户名+_+idx命名 面向用户的专用临时表空间以用户名+_+tmp命名 面向用户的专用回滚段表空间以用户名+_+rbs命名 面向应用的表空间以应用名+_data/应用名+_idx/应用名+_tmp/应用名+_rbs 命名 LOB 段数据专用表空间以其数据表空间+_+lobs 命名，如上例中数据表空间为Aud_data，则LOB 段表空间可命名为Aud_data_lobs 表空间文件命名以表空间名+两位数序号(序号从01开始)组成，如Aud_data01 等 【强制】表名的命名规范- 一般表采用系统名+t_+模块名+_+表义名 格式构成- 若数据库中只含有单个模块，命名可采用系统名+t_+表义名格式构成- 模块名或表义名均以其汉语拼音的首字符命名，表义名中汉语拼音均采用小写，且字符间不加分割符- 表别名命名规则：取表义名的前3 个字符加最后一个字符。如果存在冲突，适当增加字符（如取表义名的前4 个字符加最后一个字符等）- 临时表采用系统名+t_tmp_+表义名 格式构成 正例： 123dft_gy_cbap：系统名（电费 df）+t_+模块名（高压 gy）+_+表义名（抄表安排 cbap）dft_cbbj: 系统名（电费 df）+t_+表义名（抄表标记 cbbj）dft_tmp_hj: 系统名（电费 df）+tmp+表义名（合计hj）(此处为临时表) 【强制】属性（列或字段）命名规则 采用有意义的列名，为实际含义的汉语拼音的首字符，且字符间不加任何分割符 属性名前不要加表名等作为前缀 属性后不加任何类型标识作为后缀 不要使用“ID”作为列名 关联字段命名以 cd+_+关联表的表义名（或缩写）+_+字段名进行 【强制】主键命名规则 任何表都必须定义主键 表主键命名为：pk+_+表名(或缩写)+_+主键标识如pk_YHXX_IDKH等 【强制】外键命名规则 表外键命名为： fk+_+表名(或缩写)+_主表名(或缩写)+_+主键标识如fk_YHLX_YHXX_SFZH等 【强制】CHECK约束命名规则 CHECK 约束命名为： chk+_+CHECK约束的列名（或缩写） 【强制】UNIQUE约束命名规则 UNIQUE 约束命名为： unq+_+UNIQUE约束的列名（或缩写） 【强制】索引命名规则 索引的命名为：表名（或缩写）+_+列名+_idx，其中多单词组成的属性列列名取前几个单词首字符再加末单词首字符组成如yd_kh 表khid上的index: yd_kh_khid_idx 【强制】视图命名规则 视图命名以系统名v_+模块名作为前缀，其他命名规则和表的命名类似 （二）SQL编写规范 【强制】表面使用数据库类型的自动转换功能反例： 1SELECT * FROM category WHERE id = '123'; -- id如果是数字类型的，在这就需要内置转换，所以尽量保持数据类型一致 【参考】SELECT语句编写规范 关键字大写，列表名表名小写 由SELECT 开头，后跟一个显示查询结果的列表 由FROM 开头，后跟一个或多个获取数据所涉及的表 由WHERE 开头，后跟一个或多个确定所需值的条件 由GROUP BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行汇总 由ORDER BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行排序 【参考】尽量避免在循环中使用SQL语句 【参考】避免在WHERE子句中对列施以函数；正例： 123456SELECT *FROM service_promotionWHERE gmt_modified&gt;= TO_DATE('2001-9-01','yyyy-mm-dd')AND gmt_modified&lt; TO_DATE('2001-9-02','yyyy-mm-dd'); 反例： 1234SELECT *FROM service_promotionWHERE TO_CHAR(gmt_modified,’yyyy-mm-dd’)= '20001-09-01'; （三）类型选择 【强制】不同的数据类型选择不同的数据存储类型，不要什么都用varchar2 用char(1)代表布尔值 应尽量使用varchar2代替char类型 varchar2最多4000字符 date精确到微秒，而非天 使用clob代替long,blob代替long raw oracle只有number一种数据类型，使用时请给定长度 附件：专有名词解释 POJO（Plain Ordinary Java Object）：在本手册中，POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等 OOP（Object Oriented Programming）：本手册泛指类、对象的变成处理方式 ORM（Object Relation Mapping）：对象关系映射，对象领域模型与底层数据之间的转换，本文繁殖iBATIS，mybatis等框架 NPE（java.lang.NullPointterException）：空指针异常 IDE（Integrated Development Environment）：用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本手册泛指IDEA和Eclipse OOM（Out of Memory）：源于java.lang.OutOfMemoryError，当JVM没有足够的内存来为对象分配空间并且垃圾回收无法回收空间时，系统出现的严重状况]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户登录对账号和密码加解密]]></title>
    <url>%2F2019%2F01%2F23%2F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%AF%B9%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[背景说明闲的无聊，F12看了下项目上的登录，一看账号和密码都是明文发送的，因此找了下网络上的一些文章，对项目进行了优化 背景目前的项目登录的时候都是明文的传递账号和密码，具体如下图所示 解决方案准备资源 jar包(使用Maven引入jar包，如果不是Maven项目可以去Maven仓库将jar下载下来，然后导入项目中) 12345&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt; &lt;version&gt;1.46&lt;/version&gt;&lt;/dependency&gt; 加密js文件在Github上找到这个项目https://github.com/travist/jsencrypt的bin目录下下载jsencrypt.min.js进行 具体步骤 （后台）创建一个RSA工具类(RSAUtil.java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import java.security.*;import java.security.interfaces.RSAPublicKey;/** * @ClassName RASUtil * @Description TODO * @Date 2018/12/109:52 * @Version 1.0 **/public class RSAUtil&#123; //KeyPair is a simple holder for a key pair. private static final KeyPair keyPair = initKey(); /** * 初始化方法，产生key pair，提供provider和random * @return KeyPair instance */ private static KeyPair initKey() &#123; try &#123; //添加provider Provider provider = new org.bouncycastle.jce.provider.BouncyCastleProvider(); Security.addProvider(provider); //产生用于安全加密的随机数 SecureRandom random = new SecureRandom(); KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA", provider); generator.initialize(1024, random); return generator.generateKeyPair(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 产生public key * @return public key字符串 */ public static String generateBase64PublicKey() &#123; PublicKey publicKey = (RSAPublicKey)keyPair.getPublic(); //encodeBase64(): Encodes binary data using the base64 //algorithm but does not chunk the output. //getEncoded():返回key的原始编码形式 return new String(Base64.encodeBase64(publicKey.getEncoded())); &#125; /** * 解密数据 * @param string 需要解密的字符串 * @return 破解之后的字符串 */ public static String decryptBase64(String string) &#123; //decodeBase64():将Base64数据解码为"八位字节”数据 return new String(decrypt(Base64.decodeBase64(string.getBytes()))); &#125; private static byte[] decrypt(byte[] byteArray) &#123; try &#123; Provider provider = new org.bouncycastle.jce.provider.BouncyCastleProvider(); Security.addProvider(provider); //Cipher: 提供加密和解密功能的实例 //transformation: "algorithm/mode/padding" Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", provider); PrivateKey privateKey = keyPair.getPrivate(); //初始化 cipher.init(Cipher.DECRYPT_MODE, privateKey); //doFinal(): 加密或者解密数据 byte[] plainText = cipher.doFinal(byteArray); return plainText; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; （后台）编写一个生成公钥的接口 12345678910111213141516171819202122/** *@Description 生成公钥 *@param *@return java.lang.String *@date 2018/12/10 9:48 **/@RequestMapping("/genPubKey")@ResponseBodypublic String genPubKey()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("code",-1); String publicKey = ""; try &#123; publicKey = RSAUtil.generateBase64PublicKey(); map.put("pubkey",publicKey); map.put("code",1); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put("msg",e.getMessage()); &#125; return publicKey;&#125; （前台）登录界面引入jsencrypt.min.js，初始化登录页的同时初始化公钥 123456789101112131415161718192021//页面初始化，调取公钥var publicKey = &apos;&apos;;$(function()&#123; getPublicKey();&#125;)//调取后台生成公钥接口function getPublicKey()&#123; $.ajax(&#123; url: &quot;user/genPubKey&quot;, type: &quot;post&quot;, dataType: &quot;text&quot;, data:&#123;&#125;, success: function(data) &#123; if(data) publicKey = data; if(publicKey==null)&#123; alert(获取publicKey失败，请联系管理员！); &#125; &#125; &#125;);&#125; （前台）点击登录时，使用公钥生成私钥，加密账号和密码 1234567891011var uname = $.trim($(&quot;#userName&quot;).val());var upwd = $.trim($(&quot;#passWord&quot;).val());var encrypt = new JSEncrypt();if(publicKey)&#123;encrypt.setPublicKey(publicKey);//设置公钥到前端生成私钥uname = encrypt.encrypt(uname);//加密用户名upwd = encrypt.encrypt(upwd);//加密密码//通过ajax发送加密的账号和密码到后台.....&#125; （后台）后台账号和密码解密 12String loginID = RSAUtil.decryptBase64(username);String pwd = RSAUtil.decryptBase64(passwd); 总结前台页面加载时调用生成公钥方法生成公钥，然后用户点击登录时，获取用户名和密码，根据之前生成的公钥，进行私钥加密，传入后台的数据就是已经加密过的数据，然后我们在后台进行解密，得到用户输入的原始密码和账户]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>功能相关</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>登录</tag>
        <tag>加解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 操作页面打印操作（不使用插件）]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[页面打印​ 打印之前没怎么接触过，最近项目有需求在系统中实现打印合同的功能，系统中的合同是用Bootstrap实现的html页面，因此就查阅资料，发现window.print方法可以在不使用外部打印插件的前提下，可以进行页面的打印操作，这种既简单又好操作，但是存在一个缺点是：页面内容的替换 实现原理实现原理很简单：是通过页面替换到window.document.body中的内容，然后就可以用window.print就可以打印window.document.body中的内容 实现代码123456789101112131415&lt;body&gt;...&lt;div id="print-content" class="container" style="clear: both;width: 210mm;height: 297mm"&gt; ....&lt;/div&gt;....&lt;script&gt; var bdhtml = window.document.body.innerHTML;//获取当前页的html代码 //获取需要打印的html代码 window.document.body.innerHTML = $("#print-content")[0].innerHTML; window.print(); window.document.body.innerHTML = bdhtml;//还原页面内容&lt;/script&gt;&lt;/body&gt; 效果Chrome Firfox和IE这两个浏览器是没有打印预览的，是直接弹出打印页面的 扩展打印的时候出现页眉页脚问题处理Chrome打印的时候会出现页眉和页脚中有地址的问题，可以直接点击上图中左侧的页眉页脚中取消勾选 打印时出现Bootstrap布局失效的问题col-xs-4为Bootstrap中的自适应样式，如果不修改的时候，会出现本来在一行中的内容会出现都成一列的问题123col-lg-4修改为col-xs-4 效果如下：]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 遍历JSON]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E9%81%8D%E5%8E%86JSON%2F</url>
    <content type="text"><![CDATA[背景说明：常规下一般是用不到Json对象的遍历的，但是如果要做一些公共方法的时候，有可能会用到，比如说后端扔给你一个json串，需要你把数据反显到页面上，这种就需要进行处理了，遍历扔给你json串，然后获取和页面上匹配的内容，进行赋值操作，当然这个过程中还得需要判断控件的类型，毕竟存在一些特殊类型的控件，比如说文件上传和回显、复选框、单选框等等特殊控件 遍历有规律的JSON对象12345678910111213packJson = [&#123;"name":"nikita", "password":"1111"&#125;,&#123;"name":"tony", "password":"2222"&#125;];for(var p in packJson)&#123;//遍历json数组时，这么写p为索引，0,1 alert(packJson[p].name + " " + packJson[p].password);&#125; 遍历无规律的JSON对象123456789101112&lt;script&gt;var json = [ &#123;dd:'SB',AA:'东东',re1:123&#125;, &#123;cccc:'dd',lk:'1qw'&#125;];for(var i=0,l=json.length;i&lt;l;i++)&#123; for(var key in json[i])&#123; alert(key+':'+json[i][key]); &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 基础知识]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[js字符串转int(parseInt)1alert(parseInt(childNode)+1); js删除Object对象中的属性1delete obj.attr js获取时间的用法 获取时间 1var myDate = new Date();//获取系统的时间 获取特定格式的日期 12345678910111213myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
