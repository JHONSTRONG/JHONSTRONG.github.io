<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[windows curl安装及常规命令使用]]></title>
    <url>%2F2019%2F02%2F16%2Fwindows-curl%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[curl是什么curl是一个利用URL语法在命令行下工作的文件传输工具，它支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。curl还支持SSL认证、HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling 安装步骤下载Windows版本的curl 下载Win版curl的地址如下https://curl.haxx.se/windows/ 根据你自己的个人系统位数，下载对应的版本，我是X64的因此下载了下图中的红圈标注出来的版本 下载完成后解压，放到你想放置的位置，本次安装放在了D:\Program Files\curl（这里进行了解压文件的重命名，也可以不用重命名） 添加环境变量 我的电脑-&gt;右键“属性”-&gt;高级系统设置-&gt;环境变量在系统变量中点击新建按钮，如下图所示 弹出新建系统变量界面，在变量名中输入CURL_HOME，在变量值中输入D:\Program Files\curl\bin这个地方需要注意，替换成你自己的curl安装目录，并在最后添加\bin，具体如下图所示 修改系统变量中的Path，添加%CURL_HOME%，具体操作见下图 添加完成后，点击确定测试是否安装成功 打开CMD窗口，然后输入curl --help，看是否有反应，如果有如下输出，说明正常，如果没有，说明安装失败，根据具体的提示百度确认问题出在哪里123456789101112131415161718192021222324C:\Users\zp&gt;curl --helpUsage: curl [options...] &lt;url&gt; --abstract-unix-socket &lt;path&gt; Connect via abstract Unix domain socket --anyauth Pick any authentication method -a, --append Append to target file when uploading --basic Use HTTP Basic Authentication --cacert &lt;file&gt; CA certificate to verify peer against --capath &lt;dir&gt; CA directory to verify peer against -E, --cert &lt;certificate[:password]&gt; Client certificate file and password --cert-status Verify the status of the server certificate --cert-type &lt;type&gt; Certificate file type (DER/PEM/ENG) --ciphers &lt;list of ciphers&gt; SSL ciphers to use --compressed Request compressed response --compressed-ssh Enable SSH compression -K, --config &lt;file&gt; Read config from a file --connect-timeout &lt;seconds&gt; Maximum time allowed for connection --connect-to &lt;HOST1:PORT1:HOST2:PORT2&gt; Connect to host -C, --continue-at &lt;offset&gt; Resumed transfer offset -b, --cookie &lt;data&gt; Send cookies from string/file -c, --cookie-jar &lt;filename&gt; Write cookies to &lt;filename&gt; after operation --create-dirs Create necessary local directory hierarchy --crlf Convert LF to CRLF in upload --crlfile &lt;file&gt; Get a CRL list in PEM format from the given file...... 常用命令详细的使用方法见地址https://curl.haxx.se/docs/manpage.html语法：#curl [option] [url]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114-a/--append 上传文件时，附加到目标文件 -A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 - anyauth 可以使用“任何”身份验证方法 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 - basic 使用HTTP基本验证 -B/--use-ascii 使用ASCII /文本传输 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -d/--data &lt;data&gt; HTTP POST方式传送数据 --data-ascii &lt;data&gt; 以ascii的方式post数据 --data-binary &lt;data&gt; 以二进制的方式post数据 --negotiate 使用HTTP身份验证 --digest 使用数字身份验证 --disable-eprt 禁止使用EPRT或LPRT --disable-epsv 禁止使用EPSV -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 --egd-file &lt;file&gt; 为随机数据(SSL)设置EGD socket路径 --tcp-nodelay 使用TCP_NODELAY选项 -e/--referer 来源网址 -E/--cert &lt;cert[:passwd]&gt; 客户端证书文件和密码 (SSL) --cert-type &lt;type&gt; 证书文件类型 (DER/PEM/ENG) (SSL) --key &lt;key&gt; 私钥文件名 (SSL) --key-type &lt;type&gt; 私钥文件类型 (DER/PEM/ENG) (SSL) --pass &lt;pass&gt; 私钥密码 (SSL) --engine &lt;eng&gt; 加密引擎使用 (SSL). "--engine list" for list --cacert &lt;file&gt; CA证书 (SSL) --capath &lt;directory&gt; CA目录 (made using c_rehash) to verify peer against (SSL) --ciphers &lt;list&gt; SSL密码 --compressed 要求返回是压缩的形势 (using deflate or gzip) --connect-timeout &lt;seconds&gt; 设置最大请求时间 --create-dirs 建立本地目录的目录层次结构 --crlf 上传是把LF转变成CRLF -f/--fail 连接失败时不显示http错误 --ftp-create-dirs 如果远程目录不存在，创建远程目录 --ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 --ftp-pasv 使用 PASV/EPSV 代替端口 --ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 --ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输 --ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输 -F/--form &lt;name=content&gt; 模拟http表单提交数据 -form-string &lt;name=string&gt; 模拟http表单提交数据 -g/--globoff 禁用网址序列和范围使用&#123;&#125;和[] -G/--get 以get的方式来发送数据 -h/--help 帮助 -H/--header &lt;line&gt;自定义头信息传递给服务器 --ignore-content-length 忽略的HTTP头信息的长度 -i/--include 输出时包括protocol头信息 -I/--head 只显示文档信息 从文件中读取-j/--junk-session-cookies忽略会话Cookie - 界面&lt;interface&gt;指定网络接口/地址使用 - krb4 &lt;级别&gt;启用与指定的安全级别krb4 -j/--junk-session-cookies 读取文件进忽略session cookie --interface &lt;interface&gt; 使用指定网络接口/地址 --krb4 &lt;level&gt; 使用指定安全级别的krb4 -k/--insecure 允许不使用证书到SSL站点 -K/--config 指定的配置文件读取 -l/--list-only 列出ftp目录下的文件名称 --limit-rate &lt;rate&gt; 设置传输速度 --local-port&lt;NUM&gt; 强制使用本地端口号 -m/--max-time &lt;seconds&gt; 设置最大传输时间 --max-redirs &lt;num&gt; 设置最大读取的目录数 --max-filesize &lt;bytes&gt; 设置最大下载的文件总量 -M/--manual 显示全手动 -n/--netrc 从netrc文件中读取用户名和密码 --netrc-optional 使用 .netrc 或者 URL来覆盖-n --ntlm 使用 HTTP NTLM 身份验证 -N/--no-buffer 禁用缓冲输出 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -p/--proxytunnel 使用HTTP代理 --proxy-anyauth 选择任一代理身份验证方法 --proxy-basic 在代理上使用基本身份验证 --proxy-digest 在代理上使用数字身份验证 --proxy-ntlm 在代理上使用ntlm身份验证 -P/--ftp-port &lt;address&gt; 使用端口地址，而不是使用PASV -Q/--quote &lt;cmd&gt;文件传输前，发送命令到服务器 -r/--range &lt;range&gt;检索来自HTTP/1.1或FTP服务器字节范围 --range-file 读取（SSL）的随机文件 -R/--remote-time 在本地生成文件时，保留远程文件时间 --retry &lt;num&gt; 传输出现问题时，重试的次数 --retry-delay &lt;seconds&gt; 传输出现问题时，设置重试间隔时间 --retry-max-time &lt;seconds&gt; 传输出现问题时，设置最大重试时间 -s/--silent静音模式。不输出任何东西 -S/--show-error 显示错误 --socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口 --socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口 --stderr &lt;file&gt; -t/--telnet-option &lt;OPT=val&gt; Telnet选项设置 --trace &lt;file&gt; 对指定文件进行debug --trace-ascii &lt;file&gt; Like --跟踪但没有hex输出 --trace-time 跟踪/详细输出时，添加时间戳 -T/--upload-file &lt;file&gt; 上传文件 --url &lt;URL&gt; Spet URL to work with -u/--user &lt;user[:password]&gt;设置服务器的用户和密码 -U/--proxy-user &lt;user[:password]&gt;设置代理用户名和密码 -v/--verbose -V/--version 显示版本信息 -w/--write-out [format]什么输出完成后 -x/--proxy &lt;host[:port]&gt;在给定的端口上使用HTTP代理 -X/--request &lt;command&gt;指定什么命令 -y/--speed-time 放弃限速所要的时间。默认为30 -Y/--speed-limit 停止传输速度的限制，速度时间'秒 -z/--time-cond 传送时间设置 -0/--http1.0 使用HTTP 1.0 -1/--tlsv1 使用TLSv1（SSL） -2/--sslv2 使用SSLv2的（SSL） -3/--sslv3 使用的SSLv3（SSL） --3p-quote like -Q for the source URL for 3rd party transfer --3p-url 使用url，进行第三方传送 --3p-user 使用用户名和密码，进行第三方传送 -4/--ipv4 使用IP4 -6/--ipv6 使用IP6 -#/--progress-bar 用进度条显示当前的传送状态 使用案例 获取页面的数据curl www.baidu.com 1234C:\Users\zp&gt;curl www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270...... 获取页面数据的同时，查看HTTP头信息curl -i www.baidu.com 1234567891011121314151617C:\Users\zp&gt;curl -i www.baidu.comHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2381Content-Type: text/htmlDate: Sat, 16 Feb 2019 02:10:54 GMTEtag: "588604c8-94d"Last-Modified: Mon, 23 Jan 2017 13:27:36 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action...... 仅获取HTTP头信息curl -I www.baidu.com 123456789101112C:\Users\zp&gt;curl -I www.baidu.comHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 277Content-Type: text/htmlDate: Sat, 16 Feb 2019 02:12:46 GMTEtag: "575e1f60-115"Last-Modified: Mon, 13 Jun 2016 02:50:08 GMTPragma: no-cacheServer: bfe/1.0.8.18 获取更详细的信息，包解析ip的过程等等curl -v www.baidu.com 12345678910111213141516171819202122232425262728293031323334C:\Users\zp&gt;curl -v www.baidu.com* Expire in 0 ms for 6 (transfer 0x23fb58a20a0)* Expire in 1 ms for 1 (transfer 0x23fb58a20a0)* Expire in 1 ms for 1 (transfer 0x23fb58a20a0)* Expire in 2 ms for 1 (transfer 0x23fb58a20a0)* Expire in 6 ms for 1 (transfer 0x23fb58a20a0)* Expire in 7 ms for 1 (transfer 0x23fb58a20a0)* Expire in 10 ms for 1 (transfer 0x23fb58a20a0)* Trying 111.13.100.91...* TCP_NODELAY set* Expire in 149983 ms for 3 (transfer 0x23fb58a20a0)* Expire in 200 ms for 4 (transfer 0x23fb58a20a0)* Connected to www.baidu.com (111.13.100.91) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.64.0&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Accept-Ranges: bytes&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform&lt; Connection: Keep-Alive&lt; Content-Length: 2381&lt; Content-Type: text/html&lt; Date: Sat, 16 Feb 2019 02:14:02 GMT&lt; Etag: "588604c8-94d"&lt; Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT&lt; Pragma: no-cache&lt; Server: bfe/1.0.8.18&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.co...... 保存访问的网页(文件会下载到你当前命令执行的所在目录) 使用重定向功能保存curl www.baidu.com &gt;&gt; index.html 1234C:\Users\zp&gt;curl http://www.baidu.com &gt;&gt;index.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2381 100 2381 0 0 27367 0 --:--:-- --:--:-- --:--:-- 27367 使用curl内置option:-o(小写) 保存网页curl -o temp.html www.baidu.com 1234C:\Users\zp&gt;curl -o temp.html www.baidu.com % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2381 100 2381 0 0 27686 0 --:--:-- --:--:-- --:--:-- 27686 使用curl内置option:-O(大写) 保存网页上的文件curl -O http://www.linux.com/hello.sh 1234C:\Users\zp&gt;curl -O http://www.linux.com/hello.sh % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:01 --:--:-- 0 测试网页返回值测试网站是否正常的常用方法curl -o /dev/null -s -w %{http_code} www.linux.com 12C:\Users\zp&gt; curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com301 通过执行代理服务器及端口访问curl -x 192.168.100.100:1080 http://www.linux.com 1# curl -x 192.168.100.100:1080 http://www.linux.com Cookie很多网站上使用cookie记录session信息，curl可以增加相关参数处理cookie信息 保存网站上的cookie，内置option: -c(小写)]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Windows</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F02%2F11%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253系统版本：登陆root帐户，输入 cat /etc/redhat-release，。查看CPU信息：grep "model name" /proc/cpuinfo系统位数：uname -a查看已经安装的程序：rpm -qa查看主机名：hostname 解压：tar -zxvf web.tar.gz查看端口号占用情况：netstat -ntlp[root@yan-001 ~] # uname -a # 查看内核/操作系统/CPU信息的linux系统信息命令[root@yan-001 ~] # head -n 1 /etc/issue # 查看操作系统版本，是数字1不是字母L[root@yan-001 ~] # cat /proc/cpuinfo # 查看CPU信息的linux系统信息命令[root@yan-001 ~] # hostname # 查看计算机名的linux系统信息命令[root@yan-001 ~] # lspci -tv # 列出所有PCI设备[root@yan-001 ~] # lsusb -tv # 列出所有USB设备的linux系统信息命令[root@yan-001 ~] # lsmod # 列出加载的内核模块[root@yan-001 ~] # env # 查看环境变量资源[root@yan-001 ~] # free -m # 查看内存使用量和交换区使用量[root@yan-001 ~] # df -h # 查看各分区使用情况[root@yan-001 ~] # du -sh # 查看指定目录的大小[root@yan-001 ~] # grep MemTotal /proc/meminfo # 查看内存总量[root@yan-001 ~] # grep MemFree /proc/meminfo # 查看空闲内存量[root@yan-001 ~] # uptime # 查看系统运行时间、用户数、负载[root@yan-001 ~] # cat /proc/loadavg # 查看系统负载磁盘和分区[root@yan-001 ~] # mount | column -t # 查看挂接的分区状态[root@yan-001 ~] # fdisk -l # 查看所有分区[root@yan-001 ~] # swapon -s # 查看所有交换分区[root@yan-001 ~] # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)[root@yan-001 ~] # dmesg | grep IDE # 查看启动时IDE设备检测状况网络[root@yan-001 ~] # ifconfig # 查看所有网络接口的属性[root@yan-001 ~] # iptables -L # 查看防火墙设置[root@yan-001 ~] # route -n # 查看路由表[root@yan-001 ~] # netstat -lntp # 查看所有监听端口[root@yan-001 ~] # netstat -antp # 查看所有已经建立的连接[root@yan-001 ~] # netstat -s # 查看网络统计信息进程[root@yan-001 ~] # ps -ef # 查看所有进程[root@yan-001 ~] # top # 实时显示进程状态用户[root@yan-001 ~] # w # 查看活动用户[root@yan-001 ~] # id # 查看指定用户信息[root@yan-001 ~] # last # 查看用户登录日志[root@yan-001 ~] # cut -d: -f1 /etc/passwd # 查看系统所有用户[root@yan-001 ~] # cut -d: -f1 /etc/group # 查看系统所有组[root@yan-001 ~] # crontab -l # 查看当前用户的计划任务服务[root@yan-001 ~] # chkconfig –list # 列出所有系统服务[root@yan-001 ~] # chkconfig –list | grep on # 列出所有启动的系统服务程序[root@yan-001 ~] # rpm -qa # 查看所有安装的软件包[root@yan-001 ~] # cat /proc/cpuinfo # 查看CPU相关参数的linux系统命令[root@yan-001 ~] # cat /proc/partitions # 查看linux硬盘和分区信息的系统信息命令[root@yan-001 ~] # cat /proc/meminfo # 查看linux系统内存信息的linux系统命令[root@yan-001 ~] # cat /proc/version # 查看版本，类似uname -r[root@yan-001 ~] # cat /proc/ioports # 查看设备io端口[root@yan-001 ~] # cat /proc/interrupts # 查看中断[root@yan-001 ~] # cat /proc/pci # 查看pci设备的信息[root@yan-001 ~] # cat /proc/swaps # 查看所有swap分区的信息 注释掉系统不需要的用户和用户组注意：不建议直接删除，当你需要某个用户时，自己重新添加会很麻烦。 注释掉不用的用户 1234567891011cp /etc/passwd /etc/passwdbak #修改之前先备份 vi /etc/passwd #编辑用户，在前面加上#注释掉 此行#adm:x:3:4:adm:/var/adm:/sbin/nologin#lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin#sync:x:5:0:sync:/sbin:/bin/sync#shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown#halt:x:7:0:halt:/sbin:/sbin/halt#uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin#operator:x:11:0:operator:/root:/sbin/nologin#games:x:12:100:games:/usr/games:/sbin/nologin#gopher:x:13:30:gopher:/var/gopher:/sbin/nologin#ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin #注释掉ftp匿名账号 注释掉不用的用户用户组 12345678cp /etc/group /etc/groupbak #修改之前先备份 vi /etc/group #编辑用户组，在前面加上#注释掉此行#adm:x:4:root,adm,daemon#lp:x:7:daemon,lp#uucp:x:14:uucp#games:x:20:#dip:x:40: 关闭系统不需要的服务12345678service acpid stop chkconfig acpid off #停止服务，取消开机启动 #电源进阶设定，常用在 Laptop 上service autofs stop chkconfig autofs off #停用自动挂载档桉系统与周边装置service bluetooth stop chkconfig bluetooth off #停用Bluetooth蓝芽service cpuspeed stop chkconfig cpuspeed off #停用控制CPU速度主要用来省电service cups stop chkconfig cups off #停用 Common UNIX Printing System 使系统支援印表机service ip6tables stop chkconfig ip6tables off #禁止IPv6#如果要恢复某一个服务，可以执行下面操作#service acpid start chkconfig acpid on 禁止非root用户执行/etc/rc.d/init.d/下的系统命令12chmod -R 700 /etc/rc.d/init.d/*chmod -R 777 /etc/rc.d/init.d/* #恢复默认设置 给下面的文件加上不可更改属性，从而防止非授权用户获得权限12345678910111213chattr +i /etc/passwdchattr +i /etc/shadowchattr +i /etc/groupchattr +i /etc/gshadowchattr +i /etc/services #给系统服务端口列表文件加锁,防止未经许可的删除或添加服务lsattr /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/services #显示文件的属性 注意：执行以上权限修改之后，就无法添加删除用户了。如果再要添加删除用户，需要先取消上面的设置，等用户添加删除完成之后，再执行上面的操作chattr -i /etc/passwd #取消权限锁定设置 chattr -i /etc/shadow chattr -i /etc/group chattr -i /etc/gshadow chattr -i /etc/services #取消系统服务端口列表文件加锁现在可以进行添加删除用户了，操作完之后再锁定目录文件 限制不同文件的权限12345678910111213chattr +a .bash_history #避免删除.bash_history或者重定向到/dev/nullchattr +i .bash_historychmod 700 /usr/bin 恢复 chmod 555 /usr/binchmod 700 /bin/ping 恢复 chmod 4755 /bin/pingchmod 700 /usr/bin/vim 恢复 chmod 755 /usr/bin/vimchmod 700 /bin/netstat 恢复 chmod 755 /bin/netstatchmod 700 /usr/bin/tail 恢复 chmod 755 /usr/bin/tailchmod 700 /usr/bin/less 恢复 chmod 755 /usr/bin/lesschmod 700 /usr/bin/head 恢复 chmod 755 /usr/bin/headchmod 700 /bin/cat 恢复 chmod 755 /bin/catchmod 700 /bin/uname 恢复 chmod 755 /bin/unamechmod 500 /bin/ps 恢复 chmod 755 /bin/ps 禁止使用Ctrl+Alt+Del快捷键重启服务器123cp /etc/inittab /etc/inittabbakvi /etc/inittab #注释掉下面这一行#ca::ctrlaltdel:/sbin/shutdown -t3 -r now 不随意升级内核使用yum update更新系统时不升级内核，只更新软件包由于系统与硬件的兼容性问题，有可能升级内核后导致服务器不能正常启动，这是非常可怕的，没有特别的需要，建议不要随意升级内核。12345cp /etc/yum.conf /etc/yum.confbak1、修改yum的配置文件 vi /etc/yum.conf 在[main]的最后添加 exclude=kernel*2、直接在yum的命令后面加上如下的参数：yum --exclude=kernel* update查看系统版本 cat /etc/issue查看内核版本 uname -a 关闭Centos自动更新1234567chkconfig --list yum-updatesd #显示当前系统状态yum-updatesd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭service yum-updatesd stop #关闭 开启参数为start停止 yum-updatesd： [确定]service yum-updatesd status #查看是否关闭yum-updatesd 已停chkconfig --level 35 yum-updatesd off #禁止开启启动（系统模式为3、5）chkconfig yum-updatesd off #禁止开启启动（所有启动模式全部禁止）chkconfig --list yum-updatesd #显示当前系统状态yum-updatesd 0:关闭 1:关闭 2:启用 3:关闭 4:启用 5:关闭 6:关闭 关闭多余的虚拟控制台我们知道从控制台切换到 X 窗口，一般采用 Alt-F7 ，为什么呢？因为系统默认定义了 6 个虚拟控制台，所以 X 就成了第7个。实际上，很多人一般不会需要这么多虚拟控制台的，修改/etc/inittab ，注释掉那些你不需要的。123456789cp /etc/inittab /etc/inittabbakvi /etc/inittab# Run gettys in standard runlevels1:2345:respawn:/sbin/mingetty tty1#2:2345:respawn:/sbin/mingetty tty2#3:2345:respawn:/sbin/mingetty tty3#4:2345:respawn:/sbin/mingetty tty4#5:2345:respawn:/sbin/mingetty tty5#6:2345:respawn:/sbin/mingetty tty6 修改history命令记录123cp /etc/profile /etc/profilebakvi /etc/profile找到 HISTSIZE=1000 改为 HISTSIZE=50 隐藏服务器系统信息在缺省情况下，当你登陆到linux系统，它会告诉你该linux发行版的名称、版本、内核版本、服务器的名称。为了不让这些默认的信息泄露出来，我们要进行下面的操作，让它只显示一个”login:”提示符。删除/etc/issue和/etc/issue.net这两个文件，或者把这2个文件改名，效果是一样的。12mv /etc/issue /etc/issuebakmv /etc/issue.net /etc/issue.netbak 优化Linux内核参数1234567cp /etc/sysctl.conf /etc/sysctl.confbakvi /etc/sysctl.conf#在文件末尾添加以下内容net.ipv4.ip_forward = 1#修改为1net.core.somaxconn = 262144net.core.netdev_max_backlog = 262144net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.netfilter.ip_conntrack_max = 131072net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 180net.ipv4.route.gc_timeout = 20net.ipv4.ip_conntrack_max = 819200net.ipv4.ip_local_port_range = 10024 65535net.ipv4.tcp_retries2 = 5net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_len = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_keepalive_time = 120net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000/sbin/sysctl -p #使配置立即生效 十四、CentOS 系统优化1234cp /etc/profile /etc/profilebak2vi /etc/profile #在文件末尾添加以下内容ulimit -c unlimitedulimit -s unlimitedulimit -SHn 65535ulimit -S -c 0export LC_ALL=Csource /etc/profile #使配置立即生效ulimit -a #显示当前的各种用户进程限制 服务器禁止ping12cp /etc/rc.d/rc.local /etc/rc.d/rc.localbakvi /etc/rc.d/rc.local#在文件末尾增加下面这一行echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all参数0表示允许 1表示禁止]]></content>
      <categories>
        <category>服务器</category>
        <category>Linux常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux后台执行命令 &和nohup]]></title>
    <url>%2F2019%2F02%2F11%2FLinux%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-%E5%92%8Cnohup%2F</url>
    <content type="text"><![CDATA[当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。 使用&amp;当在前台运行某个作业时，终端被该作业占用；可以在命令后面加上&amp;实现后台运行，例如：1sh test.sh &amp; 适合在后台运行find、费时的排序及一些shell脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行（例如需要你去确认是否安装，是否overwrite之类的），否则机器会在哪里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业产生大量的输出，最好使用下面的方法把他重定向输出到某个文件中,具体的实例见下图，当成功提交进程后，会显示一个进程号，可以使用它来监控进程或者杀死进程（ps -ef|grep 查看进程；kill -9 杀死进程）：1command &gt; out.file 2&gt;&amp;1 &amp; 使用nohup使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一旦把当前控制台关掉（退出账户时），作业就会停止运行。nohup命令可以在你退出账号之后继续运行相应的进程。nohup就是不挂起的意思（no hang up），该命令的一般形式如下：1nohup command &amp; 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外制定了输出文件1nohup command &gt; myout.file 2&gt;&amp;1 &amp; 使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台执行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行 相关指令 Ctrl+z可以将一个正在执行的命令放到后台，并且处于暂停状态 jobs查看当前有多少在后台运行的命令，查看的结果是没有进程ID的，所以上面nohup打印进程ID的时候，一定要记下来，好用来结束 2&gt;&amp;12&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行 试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出]]></content>
      <categories>
        <category>服务器</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>后台执行</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10激活方法]]></title>
    <url>%2F2019%2F02%2F11%2FWin10%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法1：创建一个bat文件，里面输入以下命令，然后管理员权限执行以下 123slmgr /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJslmgr /skms kms.firadio.netslmgr /ato 方法二：管理员方式运行下面的bat 下载Win10_KMS_Activation.bat 方法三123456789101.打开“注册表编辑器”；（Windows + R然后输入 Regedit）修改SkipRearm 的值为1：（在HKEY_LOCAL_MACHINE–》SOFTWARE–》Microsoft–》Windows NT–》CurrentVersion–》SoftwareProtectionPlatform里面，将SkipRearm的值修改为1）重启电脑2.以管理员身份启动cmd，输入SLMGR -REARM，根据提示，再次重启电脑！3.slmgr /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ弹出窗口提示：“成功的安装了产品密钥”。4.slmgr /skms xykz.f3322.org密钥管理服务计算机名称成功设置为xykz.f3322.org5.slmgr /ato按回车键后将弹出窗口提示：“成功的激活了产品”。至此，Win10正式企业版系统激活成功。]]></content>
      <categories>
        <category>办公知识</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap-Treeview实现级联勾选]]></title>
    <url>%2F2019%2F02%2F11%2Fbootstrap-Treeview%E5%AE%9E%E7%8E%B0%E7%BA%A7%E8%81%94%E5%8B%BE%E9%80%89%2F</url>
    <content type="text"><![CDATA[实例化Tree123456$('#searchTree').treeview(&#123; showCheckbox:true, data:treeData, onNodeChecked:nodeChecked , onNodeUnchecked:nodeUnchecked &#125;); 核心方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var nodeCheckedSilent = false; function nodeChecked (event, node)&#123; if(nodeCheckedSilent)&#123; return; &#125; nodeCheckedSilent = true; checkAllParent(node); checkAllSon(node); nodeCheckedSilent = false; &#125; var nodeUncheckedSilent = false; function nodeUnchecked (event, node)&#123; if(nodeUncheckedSilent) return; nodeUncheckedSilent = true; uncheckAllParent(node); uncheckAllSon(node); nodeUncheckedSilent = false; &#125; //选中全部父节点 function checkAllParent(node)&#123; $('#searchTree').treeview('checkNode',node.nodeId,&#123;silent:true&#125;); var parentNode = $('#searchTree').treeview('getParent',node.nodeId); if(!("nodeId" in parentNode))&#123; return; &#125;else&#123; checkAllParent(parentNode); &#125; &#125; //取消全部父节点 function uncheckAllParent(node)&#123; $('#searchTree').treeview('uncheckNode',node.nodeId,&#123;silent:true&#125;); var siblings = $('#searchTree').treeview('getSiblings', node.nodeId); var parentNode = $('#searchTree').treeview('getParent',node.nodeId); if(!("nodeId" in parentNode)) &#123; return; &#125; var isAllUnchecked = true; //是否全部没选中 for(var i in siblings)&#123; if(siblings[i].state.checked)&#123; isAllUnchecked=false; break; &#125; &#125; if(isAllUnchecked)&#123; uncheckAllParent(parentNode); &#125; &#125; //级联选中所有子节点 function checkAllSon(node)&#123; $('#searchTree').treeview('checkNode',node.nodeId,&#123;silent:true&#125;); if(node.nodes!=null&amp;&amp;node.nodes.length&gt;0)&#123; for(var i in node.nodes)&#123; checkAllSon(node.nodes[i]); &#125; &#125; &#125; //级联取消所有子节点 function uncheckAllSon(node)&#123; $('#searchTree').treeview('uncheckNode',node.nodeId,&#123;silent:true&#125;); if(node.nodes!=null&amp;&amp;node.nodes.length&gt;0)&#123; for(var i in node.nodes)&#123; uncheckAllSon(node.nodes[i]); &#125; &#125; &#125;]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>treeview</tag>
        <tag>bootstrap</tag>
        <tag>前端开发框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui下拉及复选动态设置disabled、checked及onchange监听]]></title>
    <url>%2F2019%2F02%2F11%2Flayui%E4%B8%8B%E6%8B%89%E5%8F%8A%E5%A4%8D%E9%80%89%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEdisabled%E3%80%81checked%E5%8F%8Aonchange%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[layui是非模块化引入的12345&lt;link rel="stylesheet" href="plugins/layuiv-2.3.0/css/layui.css"&gt;**********************页面代码*********************&lt;script type="text/javascript" src="plugins/layuiv-2.3.0/layui.all.js"&gt;&lt;/script&gt; html代码1234567891011121314151617181920212223242526272829303132333435&lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;审批意见&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select name="APPVTYPE" lay-filter="appvtype" lay-verify="required" lay-search=""&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty appvTypeList&#125;"&gt; &lt;c:forEach items="$&#123;appvTypeList&#125;" var="appvType" varStatus="vs"&gt; &lt;option value="$&#123;appvType.APPR_CODE&#125;"&gt;$&#123;appvType.APPR_NAME&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;拒件理由&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select name="REFUSALREG" lay-verify="required" lay-search="" disabled=""&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty refusalRegList&#125;"&gt; &lt;c:forEach items="$&#123;refusalRegList&#125;" var="refusalReg" varStatus="vs"&gt; &lt;option value="$&#123;refusalReg.CODE_VALUE&#125;"&gt;$&#123;refusalReg.CODE_NAME&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="layui-inline"&gt; &lt;div class="layui-input-block"&gt; &lt;input type="checkbox" name="like1[write]" lay-skin="primary" title="加入黑名单" disabled="" id="BLACKLIST"&gt; &lt;/div&gt;&lt;/div&gt; js代码（一定要注意下面的重新渲染）1234567891011121314var form = layui.form;//初始化formform.on('select(appvtype)', function(data)&#123;//监听下拉框onchange if(data.value=="02")&#123; $("select[name^='REFUSALREG']").removeAttr("disabled");//设置下拉框为非只读 $("#BLACKLIST").removeAttr("disabled");//设置复选框为非只读 form.render();//重新渲染所有元素（必须得进行重新渲染，要不没法正常显示） &#125;else&#123; $("select[name^='REFUSALREG']").attr("disabled","disabled");//设置下拉框为只读 $("#BLACKLIST").attr("disabled","disabled");//设置复选框为只读 $("select[name^='REFUSALREG']").val("");//清空下拉框选中的值 $("#BLACKLIST").prop("checked",false);//清空复选框选中的值 form.render();//重新渲染所有元素（必须得重新渲染，要不没法正常显示） &#125;&#125;);]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>layui</category>
      </categories>
      <tags>
        <tag>前端开发框架</tag>
        <tag>layui</tag>
        <tag>下拉框、复选框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery模糊选择器及遍历]]></title>
    <url>%2F2019%2F02%2F01%2FJquery%E6%A8%A1%E7%B3%8A%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[JQuery常规选择器1. 首先是常规使用选择所有元素12345678910$("*")$("body *")$(document).ready(function()&#123; $("body *").css("background-color","#B2E0FF");&#125;);$(function()&#123; $("body *").css("background-color","red");&#125;) 根据id选择元素12345$("#id")$(document).ready(function()&#123; $("#choose").css("background-color","#B2E0FF");&#125;) 根据样式class选择元素该方法常用作选择多个元素123456789$(".class")$(document).ready(function()&#123; $(".className").css("background-color","red");&#125;)$(function()&#123; $(".className").css("background-color","red");&#125;) 获取第一个、最后一个元素12$("p:first")$("p:last") 所有偶数或者所有奇数标签这里的偶数和奇数是索引，索引是从0开始的，因此第一个偶数就是0123$("tr:even") //偶数$("tr:odd") //奇数$("tr:even").css("background-color","#B2E0FF"); 选择index&gt;n 或者小于n的所有对象123$("ul li:gt(3)")$("ul li:lt(3)")$("tr:lt(2)") 选择所有不为空的input123$("selector:not(selector)")$("input:not(:empty)")$("input:not(:empty)") 所有标题元素1$(":header") //所有标题元素 &lt;h1&gt; - &lt;h6&gt; 所有动画元素1$(":animated") 包含指定字符串的所有元素1234$(":contains('W3School')")$("p:contains(is)")$("p:contains(is)").css("background-color","#B2E0FF");$("div:contains(is)").css("background-color","red") 所有无子节点的所有元素1$(":empty") 所有隐藏的标签12$(":hidden")$("p:hidden") 所有可见表格1$("table:visible") 所有带匹配选择的元素1$("th,td,.intro") 所有带某个属性的元素123//公式$("[attribute]")$("[href]")$("li[name]").css("background-color","#B2E0FF");//li标签中带name属性的 所有带某个属性值等于或者不等于XXX的元素123456$("[href='#']")$("input[name='123123']")$("input[name^='123123']")$("[name!='123123']")$("[href!='#']") 包含以XXX开头 XXX结尾的元素12$("input[name^='aaa']")//以aaa开头的所有input元素$("input[name$='bbb']")//所有以bbb结尾的input元素 input的各种类型元素筛选器12345678910$(":input") // 所有 &lt;input&gt; 元素$(":text") //$(":password")//$(":radio")//$(":checkbox")//$(":submit")//$(":reset")//$(":button")//$(":image")//$(":file")// 所有激活或者禁用的元素12$(":enabled")$(":disabled") 下拉框选择中被选中的1$(":selected") 123456789 $(".btn1").click(function()&#123; $(":selected").hide(); &#125;);&lt;select multiple="multiple"&gt; &lt;option&gt;Volvo&lt;/option&gt; &lt;option selected="selected"&gt;Saab&lt;/option&gt; &lt;option&gt;Mercedes&lt;/option&gt; &lt;option&gt;Audi&lt;/option&gt; 单选框、复选框中被选中的1$(":checked").hide(); 2. 模糊选择器前后缀为XXX的选择器1234$("[name^='aaa']")//前缀$("input[name^='aaa']")//前缀$("[name$='aaa']")//后缀$("input[name$='aaa']")//后缀 name中包含XXX的选择器1$("input[name*='aaaa']") 1$("input:text[name='xx']") 3. 遍历12$("input[name^='aaa']").each(function(i)&#123;&#125;)]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>选择器</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery控制组合按钮及div下拉效果及鼠标悬浮显示div效果]]></title>
    <url>%2F2019%2F02%2F01%2FjQuery%E6%8E%A7%E5%88%B6%E7%BB%84%E5%90%88%E6%8C%89%E9%92%AE%E5%8F%8Adiv%E4%B8%8B%E6%8B%89%E6%95%88%E6%9E%9C%E5%8F%8A%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%98%BE%E7%A4%BAdiv%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[效果图 HTML代码1234567891011121314&lt;button id="searchTypeBtn" class="btn btn-default" type="button" style="padding: 2px;margin-left:2px;background-color: #000 !important"&gt; &lt;i class="glyphicon glyphicon-sort" style="margin-left:3px"&gt;&lt;/i&gt; &lt;div class="searchType" style="z-index:99;position: absolute;width: 97px;left: -70px;top: 25px;display: none;color:#000;background-color: #fff;border: 1px solid #eee"&gt; &lt;table class="layui-table" style="margin:0px"&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty moduleTypeList&#125;"&gt; &lt;c:forEach items="$&#123;moduleTypeList&#125;" var="moduleType" varStatus="vs"&gt; &lt;tr onclick="updateModuleList('$&#123;moduleType.CODE_VALUE&#125;')"&gt;&lt;td style="text-align: center;"&gt;$&#123;moduleType.CODE_NAME&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/table&gt; &lt;/div&gt;&lt;/button&gt; JS代码12345678910$(function()&#123; $("#searchTypeBtn").hover( function()&#123; $(".searchType").slideDown(400); &#125;, function()&#123; $(".searchType").slideUp(400); &#125; );&#125;);]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery获取input标签的值(text,radio,checkbox)]]></title>
    <url>%2F2019%2F02%2F01%2FjQuery%E8%8E%B7%E5%8F%96input%E6%A0%87%E7%AD%BE%E7%9A%84%E5%80%BC-text-radio-checkbox%2F</url>
    <content type="text"><![CDATA[本文章转自《jQuery获取input标签的值(text,radio,checkbox)》 这篇文章有个比较好的地方，就是遍历设置复选框的选中状态和获取复选框选中的值并拼装成对应的数据 获取页面上的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;/head&gt; &lt;script src="jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div&gt; &lt;input type="text" placeholder="账号" id="zh"/&gt; &lt;p/&gt; &lt;input type="radio" name="sex" value="0" /&gt;男 &lt;input type="radio" name="sex" value="1" checked="checked"/&gt;女 &lt;p/&gt; &lt;input type="checkbox" name="hobby" value="swim" /&gt;swim &lt;input type="checkbox" name="hobby" value="game" /&gt;game &lt;input type="checkbox" name="hobby" value="video" /&gt;video &lt;p/&gt; &lt;input type="button" id="submit" value="提交" /&gt; &amp;nbsp;&amp;nbsp; &lt;input type="button" id="look" value="查看注册用户信息" /&gt; &lt;div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;$("#submit").click(function()&#123; var zh = $("#zh").val(); var sex = $("[name='sex']:checked").val(); var hobbies = ""; //将hobby复选框的值 总和成 ,, 的形式 $("[name='hobby']:checked").each(function(index, element) &#123; hobbies += $(this).val()+","; &#125;); hobbies = hobbies.slice(0,-1); //用json传值 var user = new User(zh,sex,hobbies); var jsonUser = JSON.stringify(user); console.log(jsonUser); localStorage.setItem("user",jsonUser);&#125;);$("#look").click(function()&#123; window.location="用户信息.html";&#125;);&lt;/script&gt; 设置值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户信息&lt;/title&gt; &lt;style&gt; div&#123; margin:100px; font-size:24px; &#125; div input&#123; font-size:24px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;script src="jquery-2.1.1.min.js"&gt;&lt;/script&gt;&lt;script src="user.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div&gt; &lt;input type="text" placeholder="账号" id="zh"/&gt; &lt;p/&gt; &lt;input type="radio" name="sex" value="0" checked="checked"/&gt;男 &lt;input type="radio" name="sex" value="1" /&gt;女 &lt;p/&gt; &lt;input type="checkbox" name="hobby" value="swim" /&gt;swim &lt;input type="checkbox" name="hobby" value="game" /&gt;game &lt;input type="checkbox" name="hobby" value="video" /&gt;video &lt;p/&gt; &lt;input type="button" id="submit" value="修改" /&gt; &lt;div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;$(function()&#123; var jsonUser = localStorage.getItem("user"); var user = JSON.parse(jsonUser); var userClass = new User(); //当json中的key 与 定义类 User中的key (属性名)相同时 赋值 for(var userKey in user)&#123; for(var userClasskey in userClass)&#123; if(userKey == userClasskey)&#123; userClass[userClasskey]=user[userKey]; &#125; &#125; &#125; $("#zh").val(userClass.getName()); $("[name='sex'][value="+userClass.getSex()+"]").attr("checked","checked"); var hobbies = userClass.getHobby().split(","); for(var i=0;i&lt;hobbies.length;i++)&#123; $("[name='hobby'][value="+hobbies[i]+"]").attr("checked","checked"); &#125;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery获取标签的类型及input标签的类型]]></title>
    <url>%2F2019%2F02%2F01%2FJquery%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8Ainput%E6%A0%87%E7%AD%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[常规情况下一班是没有这种需求的，但最近在做页面数据反显，而且数据是反显在p标签里面和span标签里面，因此有了这方面的需求 首先列举一下标签的种类 标签 描述 &lt;a&gt; 定义锚 &lt;article&gt; 定义文章 &lt;b&gt; 定义粗字体 &lt;body&gt; 定义文档的主体 &lt;br&gt; 定义简单的折行 &lt;button&gt; 定义按钮 (push button) &lt;canvas&gt; 定义图形 &lt;code&gt; 定义计算机代码文本 &lt;del&gt; 定义被删除文本 &lt;em&gt; 定义强调文本 &lt;fotter&gt; 定义 section 或 page 的页脚 &lt;form&gt; 定义供用户输入的 HTML 表单 &lt;frame&gt; 定义框架集的窗口或框架 &lt;h1&gt;to&lt;h6&gt; 定义 HTML 标题 &lt;hr&gt; 定义水平线 &lt;i&gt; 定义斜体字 &lt;img&gt; 定义图像 &lt;input&gt; 定义输入控件 &lt;label&gt; 定义 input 元素的标注 &lt;p&gt; 定义段落 &lt;span&gt; 定义文档中的节 &lt;table&gt; 定义表格 &lt;tbody&gt; 定义表格中的主体内容 &lt;td&gt; 定义表格中的单元 &lt;textarea&gt; 定义多行的文本输入控件 &lt;thead&gt; 定义表格中的表头内容 &lt;tr&gt; 定义表格中的行 &lt;ul&gt; 定义无序列表 获取方法12//目前测试了几个p标签是p，span打印span$("#id")[0].tagName.toLowerCase() 问题那么问题来了，就是关于input中包含很多类型，比如说text、button、radio、checkbox等等，怎么获取这些类型进行区分呢？ 12//目前测试能够返回checkbox、radio等等$("#id")[0].type]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP知识点]]></title>
    <url>%2F2019%2F02%2F01%2FJSP%E4%B8%AD%E9%9A%90%E8%97%8FIFrame%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[隐藏iframe提交功能1234//隐藏Iframe提交功能document.forms[0].target = "hiddenFrame";document.forms[0].action = url;document.forms[0].submit(); jsp调用servlet进行页面跳转12request.getRequestDispatcher("/Newpage.jsp").forward(request,response);主要的部分就是红字部分，由于跳转到的页面就在根目录下面，因此只需要跟到（“/Newpage.jsp”）就可以了！]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JSP</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识点]]></title>
    <url>%2F2019%2F02%2F01%2FCSS%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[CSS模糊筛选器12&lt;!--p是标签的类型，class是标签的属性，important是需要模糊查询的内容--&gt;p[class~="important"] &#123;color: red;&#125; 123div[id^="filePicker"]&#123; width: 200px;&#125; 123456img[title~="Figure"] &#123;border: 1px solid gray;&#125;``` ## JQuery 给样式添加important的样式```css$(".tab_close").css("cssText","display:none !important"); 类型 描述 [abc^=”def”] 选择 abc 属性值以 “def” 开头的所有元素 [abc$=”def”] 选择 abc 属性值以 “def” 结尾的所有元素 [abc*=”def”] 选择 abc 属性值中包含子串 “def” 的所有元素 CSS3实现一直旋转的图片使用方法：①新建一个DIV，class=”demo_div”,div里面放一个图片，就能让图片一直进行旋转了，很好玩123456789101112@-webkit-keyframes rotation&#123; from &#123;-webkit-transform: rotate(0deg);&#125; to &#123;-webkit-transform: rotate(360deg);&#125;&#125;.demo_div&#123; -webkit-transform: rotate(360deg); animation: rotation 3s linear infinite; -moz-animation: rotation 3s linear infinite; -webkit-animation: rotation 3s linear infinite; -o-animation: rotation 3s linear infinite;&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号 模板消息发送]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[前言微信公众号开发，其实很简单，这里是在微信公众号测试账号（公众号沙箱）上的开发流程，具体到生产环境的公众号开发，另行配置，比如说公众号主体信息认证、消息模板配置（审核很严，需要提前进行申请，防止影响业务） 名词介绍 appID：第三方用户唯一凭证 appsecret：第三方用户唯一凭证密钥，即appsecret access_token：公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token，通过接口传递appId和appsecret，而且目前的有效时间是7200s，所以需要定期进行数据再求，更改access_token opendId：用户与公众号对应关系的唯一ID，一个用户对多个公众号有多个不同的openId，一个公众号对不同的用户有不同的openId templete_id：模板ID，发送消息的时候是通过调用接口，传递模板ID和对应模板中的参数进行数据发送的 准备材料 打开微信公众号测试账号地址，登录之后，会显示对应的appID和appsecret，这个获取access_token的时候会用到，需要记录下来 扫描测试账号界面的二维码，关注自己的测试公众号，然后能获取一个opendId，具体界面如下 创建发送消息的模板，获取到一个templete_id（测试公众号的模板是可以随便创建，不需要申请流程，但是每个测试账号下面只能有最多10个测试模板），创建模板的时候，一定要注意规则要传递的变量是以，其中param是你的要传递的参数个人创建的模板为：1&#123;&#123;first.DATA&#125;&#125; 采购单编号：&#123;&#123;keyword1.DATA&#125;&#125; 采购类型：&#123;&#123;keyword2.DATA&#125;&#125; 订货日期：&#123;&#123;keyword3.DATA&#125;&#125; 要求送货日期：&#123;&#123;keyword4.DATA&#125;&#125; &#123;&#123;remark.DATA&#125;&#125; 代码工具类HttpUtils.java和ReadProperties.java HttpUtils类是用作发送网络请求 ReadProperties类是用作读取Properties中的appid和appsecret（因为这两个值一般不会发生变化，所以存在properties文件中） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ConnectException;import java.net.CookieHandler;import java.net.CookieManager;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.ProtocolException;import java.net.URL;import java.net.URLConnection;import java.util.Iterator;import java.util.Map;import com.alibaba.fastjson.JSONObject;public class HttpUtils &#123; /** * Do POST request * @param url * @param JsonObject * @return * @throws Exception */ public String doPostForJson(String url, JSONObject jsonObj) throws Exception &#123; System.out.println("POST parameter : " + jsonObj.toString()); URL localURL = new URL(url); URLConnection connection = localURL.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setDoOutput(true); httpURLConnection.setRequestMethod("POST"); httpURLConnection.setRequestProperty("Accept-Charset", "UTF-8"); httpURLConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); httpURLConnection.setRequestProperty("Content-Length", String.valueOf(jsonObj.toString().length())); OutputStream outputStream = null; OutputStreamWriter outputStreamWriter = null; InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; try &#123; outputStream = httpURLConnection.getOutputStream(); outputStreamWriter = new OutputStreamWriter(outputStream,"UTF-8"); outputStreamWriter.write(jsonObj.toString()); outputStreamWriter.flush(); if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception("HTTP Request is not success, Response code is " + httpURLConnection.getResponseCode()); &#125; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (outputStreamWriter != null) &#123; outputStreamWriter.close(); &#125; if (outputStream != null) &#123; outputStream.close(); &#125; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125; /** * 发送GET请求 * @param url * @return * @throws Exception */ public String doGet(String url) throws Exception &#123; URL localURL = new URL(url); URLConnection connection = localURL.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setRequestProperty("Accept-Charset", "utf-8"); httpURLConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception("HTTP Request is not success, Response code is " + httpURLConnection.getResponseCode()); &#125; try &#123; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream,"UTF-8"); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233import java.util.MissingResourceException;import java.util.ResourceBundle;public class ReadProperties &#123; private static final ResourceBundle bundle; static &#123; // 读取propertiest资源文件 bundle = ResourceBundle.getBundle("systemconfig"); &#125; /** * 根据name获得propertiest资源文件里字符串的名 * @param name * @return */ public static String getString(String name) &#123; String value = null; try &#123; value = bundle.getString(name); value = new String(value.getBytes("ISO8859-1"), "UTF-8"); &#125; catch (MissingResourceException e) &#123; System.err.println(e); &#125; catch (Exception ee) &#123; System.err.println(ee); &#125; if ("".equals(value)) &#123; return null; &#125; else &#123; return value; &#125; &#125;&#125; 微信返回消息实体类WeixinAccessTokenEntity.java1234567891011121314151617181920212223/** * 请求微信Token返回的实体类 */public class WeixinAccessTokenEntity &#123; private String accessToken; private long expirationTime; public WeixinAccessTokenEntity(String accessToken, long expirationTime) &#123; this.accessToken = accessToken; this.expirationTime = expirationTime; &#125; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpirationTime() &#123; return expirationTime; &#125; public void setExpirationTime(long expirationTime) &#123; this.expirationTime = expirationTime; &#125;&#125; 发送消息的公共方法类WeChatCommon.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.third.util;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletContext;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.WebApplicationContext;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.third.bean.common.WeixinAccessTokenEntity;/** * 微信公众号相关公共类 * @author zp */public class WeChatCommon &#123; public static JSONObject sendTempleteMsg(String openId,String templateId,Map&lt;String,Object&gt; msgContentMap) &#123; //返回的JSONObject JSONObject jsonObject = new JSONObject(); jsonObject.put("code",-1); //获取access_token String accessToken = ""; try &#123; //首先通过项目全局上下文判断access_token是否失效 WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext application = webApplicationContext.getServletContext(); Object wechatAccessTokenObj = application.getAttribute("tokenMap"); WeixinAccessTokenEntity wechatAccessTokenEntity = wechatAccessTokenObj == null ? null: (WeixinAccessTokenEntity)wechatAccessTokenObj; //如果超期，或者access_token没有的时候，重新生成，并设置到全局上下文中 if(wechatAccessTokenEntity == null || wechatAccessTokenEntity.getExpirationTime()&lt;System.currentTimeMillis()) &#123; accessToken = getAccseeToken(); &#125;else &#123; accessToken = wechatAccessTokenEntity.getAccessToken(); &#125; //如果还是获取失败，则走Exception if(accessToken == null || "".equals(accessToken)) &#123; throw new Exception("获取accessToken失败!"); &#125; //组装发送的JSON串信息 JSONObject sendInfoJsonObject = packSendTemplate(openId,templateId,msgContentMap); //发送网络请求 String urlStr = "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="+accessToken;//发送消息Url HttpUtils httpUtils = new HttpUtils(); String returnMsgInfoStr = httpUtils.doPostForJson(urlStr, sendInfoJsonObject); System.out.println(returnMsgInfoStr); JSONObject returnMsgInfoJSONObject = JSON.parseObject(returnMsgInfoStr); if(returnMsgInfoJSONObject!=null &amp;&amp; returnMsgInfoJSONObject.getInteger("errcode") == 0) &#123; jsonObject.put("code",0); &#125;else &#123; jsonObject.put("msg",returnMsgInfoJSONObject.get("errmsg")); &#125; &#125; catch (Exception e) &#123; jsonObject.put("msg",e.getMessage()); e.printStackTrace(); &#125; return jsonObject; &#125; /** * 获取access_token * @return */ public static String getAccseeToken() &#123; //首先获取appId和appSecret（这个是读取配置文件*.properties文件），当然你也可以写死成上面获取到的appId和appsecret String appId=ReadProperties.getString("appId"); String appSecret=ReadProperties.getString("appsecret"); WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext application = webApplicationContext.getServletContext(); String url="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="+appId+"&amp;secret="+appSecret; HttpUtils httpRequestor = new HttpUtils(); String returnData=""; try &#123; returnData = httpRequestor.doGet(url); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; JSONObject json=JSON.parseObject(returnData); if(json.containsKey("access_token"))&#123; if(json.get("access_token")!=null&amp;&amp;!json.get("access_token").equals(""))&#123; //如果获取成功了，设置到程序的全局变量中，当然如果是集群或者其他的话，可以直接放入Redis，并设置失效时间 application.setAttribute("tokenMap", new WeixinAccessTokenEntity(json.get("access_token").toString(), System.currentTimeMillis()+Long.parseLong(json.get("expires_in").toString())*1000)); return json.get("access_token").toString(); &#125; &#125; return null; &#125; /** * 组装微信消息模板JsonObject * @return */ private static JSONObject packSendTemplate(String openId,String templateId,Map&lt;String,Object&gt; msgContentMap) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("touser",openId); jsonObject.put("template_id",templateId); JSONObject dataJSONObject = new JSONObject(); for (Map.Entry&lt;String,Object&gt; entry : msgContentMap.entrySet()) &#123; JSONObject tempContentJSONObject = new JSONObject(); tempContentJSONObject.put("value", entry.getValue()); tempContentJSONObject.put("color", "#173177"); dataJSONObject.put(entry.getKey(),tempContentJSONObject); &#125; jsonObject.put("data",dataJSONObject); return jsonObject; &#125;//没写测试代码，直接写了个main方法进行的测试 public static void main(String args[]) &#123; Map&lt;String,Object&gt; msgContentMap = new HashMap&lt;String,Object&gt;(); msgContentMap.put("first", "欢迎欢迎!"); msgContentMap.put("keyword1", "你好啊123123123"); msgContentMap.put("keyword2", "欢迎欢迎!"); msgContentMap.put("keyword3", "欢迎欢迎!"); msgContentMap.put("keyword4", "欢迎欢迎!"); msgContentMap.put("remark", "欢迎欢迎!"); sendTempleteMsg("openId","templateId",msgContentMap);//这个地方需要修改成用户对应的openId和你自己创建的模板ID &#125;&#125; 总结 WeChatCommon 一定要记住修改openId和templateId为自己的 accsee_token的有效时间目前为两小时 模板中的参数一定要和模板中的参数名字保持一致 生产环境模板一定要尽快申请，防止到时申请（审核时间比较长）不下来影响业务 目前是用项目全局上下文存储的access_token，如果有redis，可以存储在redis中，并设置时间有效]]></content>
      <categories>
        <category>后端插件</category>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信公众号</tag>
        <tag>模板消息发送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ExecutorService限制线程数量]]></title>
    <url>%2F2019%2F01%2F30%2FJava-ExecutorService%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[本文引自使用JAVA的ExecutorService来限制线程数量 前言目前对于线程的了解还是比较少，今天碰到一个使用微信公众号发送微信消息的功能，会出现批量发送的问题，如果排队执行，肯定会需要很长的时间，因此需要起线程执行，但是线程又不可能无限制的一直起，肯定会造成内存溢出类似的问题，因此想到了限制线程数量的方法。查阅了一些文章，提到了ExecutorService能够实现，因此进行了如下记录 概念ExecutorService是什么ExecutorService是Java并行运行的计算库java.util.concurrent包里面的接口，封装原来的难以使用的Java线程，使其简单优化 测试代码线程代码根据给定的生命周期，记录生命周期前后的时间点并输出信息123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.Calendar;public class SampleThread implements Runnable &#123; private int no; private int time; SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss"); SampleThread(int no, int time) &#123; this.no = no; this.time = time; &#125; @Override public void run() &#123; //开始执行，显示当前的时间，用于计算进程执行的生命周期 System.out.println("No." + no + " start ID:" + Thread.currentThread().getId() + " 生命周期:" + time + " 现在时间:" + sdf.format(Calendar.getInstance().getTime())); try &#123; Thread.sleep(time * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //执行完毕之后，打印执行结束时的时间 System.out.println("No." + no + " end ID:" + Thread.currentThread().getId() + " 生命周期:" + time + " 现在时间:" + sdf.format(Calendar.getInstance().getTime())); &#125;&#125; 使用ExecutorService调用线程的代码12345678910111213141516171819202122import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123; public static void main(String[] args) &#123; final int MAX_THREADS = 3; //定义线程数最大值 ExecutorService executorService = Executors.newFixedThreadPool(MAX_THREADS); for (int i = 0; i &lt; 10; i++) &#123; int no = i; //随机一个线程能活多少秒 int lifeTime = (int)(Math.random() * 9 + 1); //将线程提交到executorService中，等待执行 executorService.submit(new SampleThread(no, lifeTime)); &#125; System.out.println("executor.shutdown();"); executorService.shutdown(); &#125;&#125; 执行的结果12345678910111213141516171819202122executor.shutdown();No.0 start ID:13 生命周期:4 现在时间:21:52:46No.2 start ID:15 生命周期:4 现在时间:21:52:46No.1 start ID:14 生命周期:1 现在时间:21:52:46No.1 end ID:14 生命周期:1 现在时间:21:52:47No.3 start ID:14 生命周期:2 现在时间:21:52:47No.3 end ID:14 生命周期:2 现在时间:21:52:49No.4 start ID:14 生命周期:6 现在时间:21:52:49No.0 end ID:13 生命周期:4 现在时间:21:52:50No.5 start ID:13 生命周期:2 现在时间:21:52:50No.2 end ID:15 生命周期:4 现在时间:21:52:50No.6 start ID:15 生命周期:6 现在时间:21:52:50No.5 end ID:13 生命周期:2 现在时间:21:52:52No.7 start ID:13 生命周期:2 现在时间:21:52:52No.7 end ID:13 生命周期:2 现在时间:21:52:54No.8 start ID:13 生命周期:7 现在时间:21:52:54No.4 end ID:14 生命周期:6 现在时间:21:52:55No.9 start ID:14 生命周期:5 现在时间:21:52:55No.6 end ID:15 生命周期:6 现在时间:21:52:56No.9 end ID:14 生命周期:5 现在时间:21:53:00No.8 end ID:13 生命周期:7 现在时间:21:53:01Disconnected from the target VM, address: '127.0.0.1:14207', transport: 'socket' 总结 同一个时间点执行的线程数量不会超过MAX_THREAD所定义的数量 从线程的ID可以看出，只有三个线程在跑 有点没搞明白的是：ExecutorService已经在主线程里面调用了shutdown了，但是在子线程还能在正常调度的问题？？？]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程数量控制</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 创建多模块Maven项目]]></title>
    <url>%2F2019%2F01%2F30%2FIDEA-%E5%88%9B%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97Maven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建父模块 依次点击打开File-&gt;New-&gt;Project，具体操作见下图 打开创建项目对话框后，左侧选择Maven，右侧不勾选Create from archetype，然后点击Next，具体操作见下图 输入项目的信息，GroupId和ArtifactId，然后点击Next，具体操作见下图 直接点Next，直接到Finish，最后生成完成之后，删除src文件夹（因为这个是父级模块，因此不需要src文件夹），如下图所示： 创建核心子模块 右键父级模块，点击New-&gt;Module，打开新增Module界面，具体操作见下图： 左侧选择Maven，因为要创建一个普通项目，右侧同样不选择Create from archetype，然后点击Next，如下图所示： GroupId和version继承自父模块，不需要修改，只需要修改ArtifactId，点击Next 输入Module name，模块的名称可以和ArtifactId保持一致即可，具体操作见下图 创建完成后的结构图如下： 创建子模块 第一步和创建核心子模块一样，只是在打开New Module的时候，选上Create from archetype，并选中maven-archetype-webapp 一路点击下去，中间会有一个选择Maven的地方，选择你自己的Maven以及配置文件，然后点到最后，创建的项目路径如下图所示：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>SSM框架搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>搭建</tag>
        <tag>多模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遍历Map的方法]]></title>
    <url>%2F2019%2F01%2F30%2Fjava%E9%81%8D%E5%8E%86Map%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言遍历Map在Java中有好几种方式，但各自方式都有优缺点，不同的方式应用在不同的应用场景中 遍历方法keySet values在使用的过程中只是用到了Map的key或者value，这种是最简单的方式123456789101112// KeySet 获取keypublic void testKeySet() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key); &#125;&#125;// values 获取valuepublic void testValues() &#123; for (Integer value : map.values()) &#123; System.out.println(value); &#125;&#125; keySet get(key)(不推荐使用)如果同时需要key和value，可以先获取key，然后通过key获取到value，但这种方法不推荐使用12345public void testKeySetAndGetKey() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key + ":" + map.get(key)); &#125;&#125; entrySet通过map的entrySet进行遍历，是可以同时拿到key和value的，性能上更好一点，一般是用这种方式获取12345public void testEntry() &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ":" + entry.getValue()); &#125;&#125; IteratorIterator的优势是可以在遍历过程中删除元素123456789// Iterator entrySet 获取key and value public void testIterator() &#123; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + ":" + entry.getValue()); // it.remove(); 删除元素 &#125; &#125; Lambda Lambda是从java1.8开始支持的，语法更简洁，可以拿到key和value，但性能稍微低点 12345public void testLambda() &#123; map.forEach((key, value) -&gt; &#123; System.out.println(key + ":" + value); &#125;);&#125; 总结 单纯获取key或者value，使用keySet 需要同时获取key和value，使用entrySet 遍历过程中如果需要删除操作，使用Iterator 遍历过程中需要添加元素，可以新建一个临时map，遍历完成后，把临时map塞到最终map当中]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>遍历</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 读取和保存properties文件内容]]></title>
    <url>%2F2019%2F01%2F29%2FJava-%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98properties%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[前言最近做微信公众号，需要读取配置文件中的appId等信息，鄙人将这些固定的信息放进了properties文件里面，因此才用到了这块读操作，顺道也把写操作在网上查了下 Properties类Properties类和properties配置文件Properties类继承自Hashtable，并实现了Map的接口，也就是properties文件在Properties类中是以键值对存在的，而且值都是字符串 Properties类的主要的方法 load(InputStream inStream)以文件流的形式加载文件中的信息到Properties类中，具体的代码如下： 1234567Properties pro = new Properties();//文件流读取文件信息FileInputStream inStrem = new FileInputStream("a.properties");//加载数据到Properties类中pro.load(in);//关闭文件流in.close(); store(OutputStream out, String comments)将Properties类中的内容输出保存到properties文件当中，具体的代码如下： 123FileOutputStream outFile = new FileOutputStream("a.properties",true);pro.store(outFile,"Comments");outFile.close(); 如果comments不为空，保存后文件的第一行回事#comments，表示注释信息；如果为空则没有注释信息 getProperty/setProperty这两个方法分别是用来获取和设置properties文件的属性的 代码实例 a.properties文件的内容如下123name=rootpass=liukey=value 读取a.properties文件和生成b.properties文件1234567891011121314151617181920212223242526272829303132import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.util.Iterator;import java.util.Properties;public class PropertyTest &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); try&#123; //读取属性文件a.properties InputStream in = new BufferedInputStream (new FileInputStream("a.properties")); prop.load(in); ///加载属性列表 Iterator&lt;String&gt; it=prop.stringPropertyNames().iterator(); while(it.hasNext())&#123; String key=it.next(); System.out.println(key+":"+prop.getProperty(key)); &#125; in.close(); ///保存属性到b.properties文件 FileOutputStream oFile = new FileOutputStream("b.properties", true);//true表示追加打开 prop.setProperty("phone", "10086"); prop.store(oFile, "The New properties file"); oFile.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; ResourceBundle该类是基于类读取属性：将属性文件当做类，意味着属性文件必须放在包中，使用属性文件的权限定性类名而非路径1234567891011121314151617181920/** * 基于类读取属性文件：该方法将属性文件当作类来处理，属性文件放在包中，使用属性文件的全限定性而非路径来指代文件 */ @Test public void test02() &#123; ResourceBundle bundle = ResourceBundle.getBundle("com.javase.properties.test01"); System.out.println("获取指定key的值"); System.out.println("driver=" + bundle.getString("jdbc.driver")); System.out.println("url=" + bundle.getString("jdbc.url")); System.out.println("username=" + bundle.getString("jdbc.username")); System.out.println("password=" + bundle.getString("jdbc.password")); System.out.println("-----------------------------"); System.out.println("遍历属性文件"); Enumeration&lt;String&gt; keys = bundle.getKeys(); while (keys.hasMoreElements()) &#123; String key = keys.nextElement(); System.out.println(key + "=" + bundle.getString(key)); &#125; &#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>properties文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA2018搭建SSM框架（一）前期搭建]]></title>
    <url>%2F2019%2F01%2F28%2FIDEA2018%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E6%9C%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建环境说明 JDK1.8 IDEA 2018 Maven 3.5.3 搭建步骤1. 首先创建Maven webapp项目 2. 搭建项目结构 搭建完成的文件目录如下 建设完目录的过程中需要设置文件的类型为Source,Test,Resources,设置完成后的效果图如下： 3. 配置文件内容 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.chatRobot&lt;/groupId&gt; &lt;artifactId&gt;ChatRobot&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;ChatRobot Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ChatRobot&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 设置JDK版本 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 记得设置左下角的自动引入 logback.xml选择logback比log4j好，具体原因自己百度 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="true"&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;/root&gt;&lt;/configuration&gt; jdbc.properties 1234567891011121314151617jdbc.driver=com.mysql.jdbc.Driver#数据库地址jdbc.url=jdbc:mysql://xxxxxxxxx:3306/ChatRobot?useUnicode=true&amp;characterEncoding=utf8#用户名jdbc.username=xxxx#密码jdbc.password=xxxxx#最大连接数c3p0.maxPoolSize=30#最小连接数c3p0.minPoolSize=10#关闭连接后不自动commitc3p0.autoCommitOnClose=false#获取连接超时时间c3p0.checkoutTimeout=10000#当获取连接失败重试次数c3p0.acquireRetryAttempts=2 spring-mybatis.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=&quot;com.chatRobot.service&quot;/&gt; &lt;!-- 配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;c3p0.maxPoolSize&#125;&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;$&#123;c3p0.minPoolSize&#125;&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;$&#123;c3p0.autoCommitOnClose&#125;&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;$&#123;c3p0.checkoutTimeout&#125;&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;$&#123;c3p0.acquireRetryAttempts&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.chatRobot.model&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.chatRobot.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.chatRobot.controller&quot;/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;ChatRobot&lt;/display-name&gt; &lt;description&gt;ChatRobot_Alpha_0.0.1&lt;/description&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求，此处也可以配置成 *.do 形式 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 4. 测试 首先导入一份数据库测试文件 1234567891011121314CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;, `email` varchar(255) NOT NULL COMMENT &apos;用户邮箱&apos;, `password` varchar(255) NOT NULL COMMENT &apos;用户密码&apos;, `username` varchar(255) NOT NULL COMMENT &apos;用户昵称&apos;, `role` varchar(255) NOT NULL COMMENT &apos;用户身份&apos;, `status` int(1) NOT NULL COMMENT &apos;用户状态&apos;, `regTime` datetime NOT NULL COMMENT &apos;注册时间&apos;, `regIp` varchar(255) NOT NULL COMMENT &apos;注册IP&apos;, PRIMARY KEY (`id`), UNIQUE KEY `email` (`email`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO `user` VALUES (&apos;1&apos;, &apos;xxx&apos;, &apos;xxxxx&apos;, &apos;xxxxx&apos;, &apos;root&apos;, &apos;0&apos;, &apos;2017-03-28 09:40:31&apos;, &apos;127.0.0.1&apos;);SET FOREIGN_KEY_CHECKS=1; 创建类 UserController.java 123456789101112131415161718192021222324252627282930313233package com.chatRobot.controller;import javax.servlet.http.HttpServletRequest;import com.chatRobot.model.User;import com.chatRobot.service.IUserService;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controller@RequestMapping("/user")public class UserController &#123; @Resource private IUserService userService; @RequestMapping("/showUser.do") public void selectUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); long userId = Long.parseLong(request.getParameter("id")); User user = this.userService.selectUser(userId); ObjectMapper mapper = new ObjectMapper(); response.getWriter().write(mapper.writeValueAsString(user)); response.getWriter().close(); &#125;&#125; IUserDao.java 123456789package com.chatRobot.dao;import com.chatRobot.model.User;public interface IUserDao &#123; User selectUser(long id);&#125; User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.chatRobot.model;import java.util.Date;public class User &#123; private long id; private String email; private String password; private String username; private String role; private int status; private Date regTime; private String regIp; public long getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getRole() &#123; return role; &#125; public void setRole(String role) &#123; this.role = role; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public Date getRegTime() &#123; return regTime; &#125; public void setRegTime(Date regTime) &#123; this.regTime = regTime; &#125; public String getRegIp() &#123; return regIp; &#125; public void setRegIp(String regIp) &#123; this.regIp = regIp; &#125;&#125; IUserService.java 123456789package com.chatRobot.service;import com.chatRobot.model.User;public interface IUserService &#123; public User selectUser(long userId);&#125; UserServiceImpl.java 1234567891011121314151617181920package com.chatRobot.service.impl;import com.chatRobot.dao.IUserDao;import com.chatRobot.model.User;import com.chatRobot.service.IUserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service("userService")public class UserServiceImpl implements IUserService &#123; @Resource private IUserDao userDao; public User selectUser(long userId) &#123; return this.userDao.selectUser(userId); &#125;&#125; UserDao.xml 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置为IUserDao接口方法提供sql语句配置 --&gt;&lt;mapper namespace="com.chatRobot.dao.IUserDao"&gt; &lt;select id="selectUser" resultType="User" parameterType="long"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建测试类IUserDaoTest.java 12345678910111213141516171819202122232425package com.chatRobot.dao;import com.chatRobot.model.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;// 加载spring配置文件@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-mybatis.xml"&#125;)public class IUserDaoTest &#123; @Autowired private IUserDao dao; @Test public void testSelectUser() throws Exception &#123; long id = 1; User user = dao.selectUser(id); System.out.println(user.getUsername()); &#125;&#125; 运行测试类，会在控制台输出上面sql文件中用户的名字 继续新建个页面来测试springmvc和mybatis 创建测试类index.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;script&gt; function selectUser() &#123; var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; document.getElementById(&quot;test&quot;).innerHTML = xmlhttp.responseText; &#125; &#125; xmlhttp.open(&quot;POST&quot;, &quot;user/showUser.do&quot;, true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;id=1&quot;); &#125;&lt;/script&gt;&lt;body&gt;&lt;p id=&quot;test&quot;&gt;Hello World!&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;selectUser()&quot;&gt;onclick test&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 新建完成后配置项目运行环境，点击Run-Edit Configurations…点击加号新建运行环境，选择Tomcat Server-Local 选中新建好的服务器，右边选择Deployment,点击加号-Atifact… 选择第二项 然后在右边Application context配置你的项目名 最后运行项目，在打开的页面中点击按钮测试，成功的话会在页面上显示id为1的用户信息]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>SSM框架搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 返回Map类型key改为小写]]></title>
    <url>%2F2019%2F01%2F28%2Fmybatis-%E8%BF%94%E5%9B%9EMap%E7%B1%BB%E5%9E%8Bkey%E6%94%B9%E4%B8%BA%E5%B0%8F%E5%86%99%2F</url>
    <content type="text"><![CDATA[当使用mybatis查询数据库的时候，会出现查询出来的Map中字段都是大写的，需要进行处理，处理的方法如下 添加别名 别名上添加双引号，查询出来的就是小写了 demo 1234&lt;select id="getStudentList" resultType="java.util.Map"&gt;select t.name as "sName",t.sex as "sSex" from student&lt;/select&gt;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>MyBatis</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>大小写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架DDL操作数据库表]]></title>
    <url>%2F2019%2F01%2F28%2FSSM%E6%A1%86%E6%9E%B6DDL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[创建表123&lt;update id="createTableWithColumn" parameterType="pd"&gt; CREATE TABLE $&#123;MODULE_CODE&#125; ( $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125; ) TABLESPACE USR_XYD_TBS STORAGE ( INITIAL 64K MINEXTENTS 1 MAXEXTENTS UNLIMITED )&lt;/update&gt; 给表添加备注123&lt;update id=&quot;addCommentOnTable&quot; parameterType=&quot;pd&quot;&gt; COMMENT ON TABLE $&#123;MODULE_CODE&#125; IS &apos;$&#123;MODULE_NAME&#125;&apos;&lt;/update&gt; 插入字段123&lt;update id="addItemByDdl" parameterType="pd"&gt; ALTER TABLE $&#123;MODULE_CODE&#125; ADD $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125;&lt;/update&gt; 修改字段123&lt;update id=&quot;editColumnByDdl&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; MODIFY $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125;&lt;/update&gt; 删除字段给字段添加备注123&lt;update id="addCommentOnColumn" parameterType="pd"&gt; COMMENT ON COLUMN $&#123;TABLE_COLUMN&#125; IS '$&#123;ITEM_NAME&#125;'&lt;/update&gt; 添加主键123&lt;update id=&quot;addUniquesOnTable&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; ADD CONSTRAINT $&#123;KEY_NAME&#125; PRIMARY KEY ($&#123;ALL_UNIQUES&#125;)&lt;/update&gt; 删除表上已有的主键123&lt;update id=&quot;dropUniquesOnTable&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; DROP CONSTRAINT $&#123;EXIST_UNIQUES&#125; CASCADE&lt;/update&gt;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>DDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Java接口上传下载文件]]></title>
    <url>%2F2019%2F01%2F28%2F%E9%80%9A%E8%BF%87Java%E6%8E%A5%E5%8F%A3%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Java后台上传文件代码12345678910111213@RequestMapping(value = "/importUserInfo",method = RequestMethod.POST)@ResponseBodypublic JSONObject importUserInfo(@RequestParam String isUpdateFlag,HttpServletRequest request) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("code","-1"); //转换HttpServletRequest为MultipartHttpServletRequest MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; MultipartFile file = multipartRequest.getFile("Fdata"); String fileName = file.getOriginalFilename(); String fileType = fileName.substring(fileName.indexOf(".")); InputStream is = file.getInputStream();&#125; Java后台的接口代码如下12345678910111213141516171819202122@RequestMapping(value = "/downloadExcel",method = RequestMethod.GET)@ResponseBodypublic void downloadExcel(HttpServletRequest request,HttpServletResponse response) &#123; response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=userExcle.xlsx"); try &#123; String path=PathUtil.getClasspath()+"templete/xlsx/userExcle.xlsx"; InputStream inputStream = new FileInputStream(new File(path)); OutputStream os = response.getOutputStream(); byte[] b = new byte[2048]; int length; while ((length = inputStream.read(b)) &gt; 0) &#123; os.write(b, 0, length); &#125; os.close(); inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 前端的接口代码如下直接使用window打开一个新窗口进行下载就可以了，当然也可以通过指向隐藏div进行文件的下载1window.open('http://localhost:8080/MCSForOracle/userManage/downloadExcel');]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA15搭建Maven环境]]></title>
    <url>%2F2019%2F01%2F28%2FIDEA15%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[配置Maven软件配置一次即可，所有Maven项目共享 如上图标注3 选择自己的仓库 如上图标注 2 所示，Import Maven projects automatically 表示 IntelliJ IDEA 会实时监控项目的 pom.xml 文件，进行项目变动设置 如上图标注3 所示，在 Maven 导入依赖包的时候是否自动下载源码和文档。默认是没有勾选的，也不建议勾选，原因是这样可以加快项目从外网导入依赖包的速度，如果我们需要源码和文档的时 候我们到时候再针对某个依赖包进行联网下载即可。IntelliJ IDEA 支持直接从公网下载源码和文档的 上图标注 3 所示，可以设置导入的 VM 参数。一般这个都不需要主动改，除非项目真的导入太慢了我们再增大此参数 Maven 骨架创建 Java Web 项目 File -&gt; New -&gt; Project… 如下图 如下图，GroupId和ArtifactId&lt;项目名&gt;还有Version，这三个属性目的是标识你的项目的唯一性 如下图 如下图 点Finish之后，Maven会根据刚才的配置创建一个基于Maven的Web App 创建结束，其Log如下： 创建结束，其代码结构如下 recources文件夹：一般用来存放一些资源文件webapp文件夹：用来存放web配置文件以及jsp页面等，这已经组成了一个原始的web应用启动 Java Web 项目 打开“Project Structure” 配置“Facets” 配置“Artifacts” 启动“Edit Configurations” Add New ‘Tomcat Server’ 配置 配置Deplyment 配置Server 其结果如下 启动Web Server 现在可以通过Browser访问WebServer的页面了。]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>搭建</tag>
        <tag>Maven</tag>
        <tag>Idea15</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz集成SpringMVC 的方案]]></title>
    <url>%2F2019%2F01%2F26%2FQuartz%E9%9B%86%E6%88%90springMVC-%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[废话不说，直接上干货 引入Jar包第一步，首当其冲是引jar包，当然目前我还没把项目弄成maven的，所以也就只能自己copy个jar包到自己的lib包下面 下载quartz-2.2.1.jar 新建spring-quartz.xml第二步,新建一个spring-quartz.xml文件，文件的位置放在和spingMVC的配置文件同级目录即可，spring-quartz.xml可以配置多个任务，列如quartzJobA、quartzJobB，并配置对应的方法和时间表达式（什么时间执行），具体的任务怎么定时，怎么执行都在此文件中 spring-quartz.xml下载链接 修改web.xml第三步，将spring-quartz.xml添加到配置中，配置文件中只需要启动的时候加载上面提到spring-quartz.xml文件 具体使用第四步，具体在Java中的使用方法下载StatisticsTimer 注：cronExpression值有几种如下：123456789101112131415"0 0 12 * * ?" 每天中午12点触发"0 15 10 ? * *" 每天上午10:15触发"0 15 10 * * ?" 每天上午10:15触发"0 15 10 * * ? *" 每天上午10:15触发"0 15 10 * * ? 2005" 2005年的每天上午10:15触发"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发"0 15 10 15 * ?" 每月15日上午10:15触发"0 15 10 L * ?" 每月最后一日的上午10:15触发"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Quart定时器</category>
      </categories>
      <tags>
        <tag>定时器</tag>
        <tag>Quartz</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 Shiro授权]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-Shiro%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[授权，访问控制，在应用中控制哪些用户能够访问哪些资源（如页面/编辑数据/页面操作）。授权需要了解几个关键对象：主题（Subject）、资源（Resource）、权限（Permission）、角色（Role） 主体访问应用的用户。用户只有授权后才允许访问对应的资源 资源在应用中用户可以访问的任何东西，比如JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等都是资源。用户只有首选后才能访问。 权限安全策略中的原子授权单位。通过权限我们可以表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增删改查）式权限控制）打印文档等等 角色角色代表操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较访问。典型的如：项目经理，技术总监、CTO等等，不同的角色拥有不同的权限。 隐式角色直接通过角色来验证用户有没有操作权限，需要在代码中进行维护，比较麻烦，粒度较粗 显示角色在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设某个角色不能访问某个资源，只需要从角色对应的权限集合中移除即可；无须修改多出代码，即粒度是以资源/实例为单位的；粒度较细 授权方式Shiro支持三种方式的授权编程式：通过if/else授权代码块方式123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole("admin"))&#123; //有权限&#125;else&#123; //无权限&#125; 注解式：通过在执行的Java方法上防止相应的注解完成1234@RequiresRoles("admin")public void hello()&#123; //有权限&#125; 没有权限将抛出相应的异常JSP/GSP标签：在JSP/GSP页面通过相应的标签完成：123&lt;shiro:hasRole name="admin"&gt;&lt;!--有权限--&gt;&lt;/shiro:hasRole&gt; 后续部分将详细介绍如何使用 授权基于角色的访问控制（隐式角色）1、在ini配置文件配置用户拥有的角色（shiro-role.ini）123[users]zhang=123,role1.role2wang=123,role1 规则即：“用户名=密码,角色1,角色2”，如果需要在应用中判断用户是否拥有相应的角色，就需要在相应的Realm中返回角色信息，也就是说Shiro不负责维护用户-角色信息，需要应用提供，Shiro只是提供相应的接口方便验证，后续会介绍如何动态的获取用户角色。2、测试用例1234567891011121314151617181920212223242526/** * @ClassName RoleTest * @Description TODO * @Author zp * @Date 2018/11/615:11 * @Version 1.0 **/public class RoleTest extends BaseTest&#123; @Test public void testHasRole()&#123; login("classpath:shiro-role.ini","zhang","123"); //判断拥有角色：role1 Assert.assertTrue(subject().hasRole("role1")); //判断拥有角色：role1 and role2 Assert.assertTrue(subject().hasAllRoles(Arrays.asList("role1","role2"))); //判断拥有角色：role1 and role2 and !role3 boolean[] result = subject().hasRoles(Arrays.asList("role1","role2","role3")); Assert.assertEquals(true,result[0]); Assert.assertEquals(true,result[1]); Assert.assertEquals(false,result[2]); &#125;&#125; Shiro提供了hasRole/hasRoles用于判断用户是否拥有角色/某些权限；但是没有提供如hasAnyRole用于判断是否有某些权限中的一个。12345678@Test(expected = UnauthorizedException.class)public void testCheckRole() &#123; login("classpath:shiro-role.ini", "zhang", "123"); //断言拥有角色：role1 subject().checkRole("role1"); //断言拥有角色：role1 and role3 失败抛出异常 subject().checkRoles("role1", "role3");&#125; Shiro 提供的checkRole/checkRole和hasRole/hasAllRoles不同的地方是他在判断为假的情况下会抛出UnauthorizedException异常。到此基于角色的访问控制（隐式角色）就完成了，这种方式的缺点就是如果很多地方进行角判断，但是有一天不需要了，那么久需要修改相应代码把所有相关的地方进行删除，这就是粗粒度造成的问题。 基于资源的访问控制（显示角色）1、在ini配置文件配置用户拥有的角色角色-权限关系（shiro-permission.ini）12345678zhang=123,role1,role2wang=123,role1[roles]#对资源user拥有create、update权限role1=user:create,user:update#对资源user拥有create、delete权限role2=user:create,user:delete 规则：“用户名=密码，角色1，角色2” “角色=权限1，权限2”，即首先根据用户名找到角色，然后根据角色再找到权限；即角色时权限的集合；Shiro同样不进行权限的额维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户-角色”之间的关系即可。 2、测试用例1234567891011@Testpublic void testPermitted()&#123; login("classpath:shiro-permission.ini","zhang","123"); //判断拥有权限：user:create Assert.assertTrue(subject().isPermitted("user:create")); //判断拥有权限：user:update and user:delete Assert.assertTrue(subject().isPermittedAll("user:update","user:delete")); //断言没有权限user:view Assert.assertFalse(subject().isPermitted("user:view"));&#125; Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或者所有权限，也就是没有提供如isPermittedAny用于判断拥有某一个权限的接口12345678910111213@Test(expected = UnauthorizedException.class)public void testCHeckPermission()&#123; login("classpath:shiro-permission.ini","zhang","123"); subject().checkPermission("user:create"); subject().checkPermissions("user:delete","user:update"); try &#123; subject().checkPermissions("user:view"); &#125; catch (AuthorizationException e) &#123; e.printStackTrace(); &#125;&#125; 到此基于资源的访问控制（显示角色）就完成了，也就是基于权限的访问控制，这种方法一般规则是“资源标识符：操作”。即是资源级别的粒度；这种方式的好处是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户-角色，角色-权限（资源：操作）”之间的关系 Permission字符串通配符权限规则：“资源标识符：操作：对象实例ID”即对那个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“：”表示资源/操作/实例的分割；“，”表示操作的分割；“*”表示任意资源/操作/实例1、单个资源单个权限1subject().checkPermissions("system:user:update"); 拥护拥有资源“system:user”的update权限2、单个资源多个权限ini配置文件1role41=system:user:update,system:user:delete 通过如下代码进行判断1subject().checkPermissions("system:user:update","system:user:delete"); 用户拥有资源“system:user”的update和delete权限。如上可以简写成：ini配置文件（表示角色4拥有system:user资源的update和delete权限）1role42="system:user:update,delete" 接着可以通过如下代码判断：1subject().checkPermissions("system:user:update,delete"); 通过“system:user:update,delete”验证“system:user:update,system:user:delete”是没有问题的，但是反过来是规则不成立的。 3、单个资源全部权限ini配置1role51="system:user:create,update,delete,view" 然后通过如下代码判断1subject().checkPermissions("system:user:create,delete,update,view"); 用户拥有资源“system:user”的“create”、“update”、“delete”和“view”所有权限。如上可以简写成：ini配置文件（表示角色5拥有system:user的所有权限）1role52=system:user:* 也可以简写成（推荐上边的写法）：1role53=system:user 然后通过如下代码判断：12subject().checkPermissions("system:user:*");subject().checkPermissions("system:user"); 通过“system:user:*”验证“system:user:create,delete,update:view”可以，但是反过来是不成立的。 4、所有资源全部权限ini配置1role61=*:view 代码1subject().checkPermissions("user:view"); 用户拥有所有资源的“view”所有权限。假设判断的权限是“system:user:view”，那么需要“role5=::view”这样写才行。 5、实例级别的权限5.1、单个实例单个权限ini配置1role71=user:view:1 对资源user的1实例拥有view权限。通过下面的代码判断1subject().checkPermissions("user:view:1") 5.2、单个实例多个权限ini配置1role72=&quot;user:update,delete:1&quot; 对资源user的1实例拥有update、delete权限然后通过如下代码判断12subject().checkPermissions("user:delete,update:1");subject().checkPermissions("user:update:1","user:delete:1"); 5.3、单个实例所有权限ini配置1role73=user:*:1 对资源user的1实例拥有所有权限然后通过如下代码判断1subject().checkPermissions("user:update:1","user:delete:1","user:view:1"); 5.4、所有实例单个权限ini配置1role74=user:auth:* 对资源user的1实例拥有所有的权限然后通过如下代码判断：1subject().checkPermissions("user:auth:1","user:auth:2"); 5.5、所有实例所有权限ini配置1role75=user:*:* 对资源user的1实例拥有所有权限判断代码1subject().checkPermissions("user:view:1","user:auth:2"); 6、Shiro对权限字符串却是部分的处理如user:view等价于user:view:*；而organization等价于organization:*或者organization:*:*,这种方式实现了前缀匹配。另外如user:*可以匹配user:delete、user:delete可以匹配user:delete:1`user::1,可以匹配如user:view:1、user可以匹配user:view或user:view:1`等。即可以匹配所有，不加可以进行前缀匹配；但是如`:view不能匹配system:user:view，需要::view`，即后缀匹配必须制定前缀（多个冒号就需要多个来匹配）。7、WildcardPermission如下面两种方式是等价的：12subject().checkPermission("menu:view:1")subject.checkPermission(new WildcardPermission("menu:view:1")) 因此没什么必要的话使用字符串更方便。 8、性能问题通配符匹配方式比字符串相等的陪陪来说是更复杂，因此需要花费更长时间，但是一般系统的权限不会太多，且乐意配合缓存来提供其性能，如果这样性能还打不到要求我们可以实现操作算法实现吸能你更好的权限匹配。另外实力级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如sql查询时加上权限字符串之类的方式在查询时就完成权限匹配。 授权流程 流程如下：1、首先调用Subject.isPermitted*/hasROle*接口，其会委托给SecurityManager,而SecurityManager接着会委托给Authorizer;2、Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”),其首先会通过PermissionResolver把字符串转换成相应的Permission实例；3、在进行授权之前，其会调用相应的Real获取Subject相应的角色/权限用于匹配传入的角色/权限。4、Authorizer会判断Realm的角色/权限是否和传入的匹配，如果多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败 ModularRealmAuthorizer进行多Realm匹配流程：1、首先检查相应的Realm是否实现了Authorizer；2、如果实现了Authorizer，那么接着调用其他相应的isPermitted/hasRole接口进行匹配3、如果有一个Realm匹配那么僵返回true，否则返回false； 如果Realm进行授权的话，应该继承AuthorizingRealm，起流程是：1.1、如果调用hasRole*,则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可；1.2、首先调用如isPermitted(“user:view”),首先通过PermissionResolver，即转换为通配符的WildcardPermission；2、通过AuthoricationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo.getStringPermission得到字符串合并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）3、接着调用Permission.implies(Permission p )诸葛与传入的权限比较，如果有匹配的则返回true，否则返回false。 Authorizer、PermissionResolver及RolePermissionResolverAuthorizer的职责是进行授权（访问控制），是ShiroAPI中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其JavaDoc。SecurityManager集成了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例，而RolePermissionResolver用于根据角色解析相应的权限集合。我们可以通过如下ini配置更改Authorizer实现：12authorizer=org.apache.shiro.authz.ModularRealmAuthorizersecurityManager.authorizer=$authorizer 对于ModularRealmAuthorizer，相应的AuthorizingSecurityManager会在初始化完成后自动将相应的realm设置进去，我们也可以通过调用其setRealm()方法进行设置。对于实现自己的authorizer可以参考ModularRealmAuthorizer实现即可，再次不提供示例了。设置ModularRealmAuthorizer的permissionResolver，其会自动设置到相应的Realm上（其实现了PermissionResolverAware接口），如：12permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverauthorizer.permissionResolver=$permissionResolver 设置ModularRealmAuthorizer的rolePermissionResolver,其会自动设置到相应的Realm上（其实现了RolePermissionResolverAware接口），如：12rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolver 示例1、ini配置(shiro-authorizer.ini)12345678910111213141516[main]#自定义authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer#自定义permissionResolver#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverpermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver#自定义rolePermissionResolverrolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer#自定义realm 一定要放在securityManager.authorizer赋值之后（因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver）realm=com.github.zhangkaitao.shiro.chapter3.realm.MyRealmsecurityManager.realms=$realm 设置securityManager的realms一定要放在最后，因为在调用SecurityManager.setRealms的时候会将realms设置给authorizer，并为各个Realm设置permissionResolver和rolePermissionResolver。另外，不能使用IniSecurityManagerFactory创建IniRealm，因为其初始化顺序的问题可能会造成后续初始化Permission造成影响。 2、定义BitAndWildPermissionResolver及BitPermissionBitPermission用于实现位移方式权限，规则是：权限字符串格式：+资源字符串+权限位+实例ID；以+开头，中间通过+分割；权限：0表示所有权限；1表示新增（二级制0001）、2表示修改（二级制0010）、4删除（二进制0100）、8查看（二进制1000）；如+user+10表示对资源user拥有修改/查看权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.alibaba.druid.util.StringUtils;import org.apache.shiro.authz.Permission;/** * @ClassName BitPermission * @Description TODO * @Author zp * @Date 2018/11/2716:46 * @Version 1.0 **/public class BitPermission implements Permission &#123; private String resourceIdentify; private int permissionBit; private String instanceId; public BitPermission(String permissionString) &#123; String[] array = permissionString.split("\\+"); if(array.length &gt; 1) &#123; resourceIdentify = array[1]; &#125; if(StringUtils.isEmpty(resourceIdentify)) &#123; resourceIdentify = "*"; &#125; if(array.length &gt; 2) &#123; permissionBit = Integer.valueOf(array[2]); &#125; if(array.length &gt; 3) &#123; instanceId = array[3]; &#125; if(StringUtils.isEmpty(instanceId)) &#123; instanceId = "*"; &#125; &#125; public boolean implies(Permission p) &#123; if(!(p instanceof BitPermission)) &#123; return false; &#125; BitPermission other = (BitPermission) p; if(!("*".equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123; return false; &#125; if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123; return false; &#125; if(!("*".equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123; return false; &#125; return true; &#125; public String toString() &#123; return "BitPermission&#123;" + "resourceIdentify='" + resourceIdentify + '\'' + ", permissionBit=" + permissionBit + ", instanceId='" + instanceId + '\'' + '&#125;'; &#125;&#125; Permission接口提供了boolean implies(Permission p)方法，用于判断权限匹配的123456789101112131415161718192021import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.permission.PermissionResolver;import org.apache.shiro.authz.permission.WildcardPermission;/** * @ClassName BitAndWildPermissionResolver * @Description TODO * @Author zp * @Date 2018/11/2716:49 * @Version 1.0 **/public class BitAndWildPermissionResolver implements PermissionResolver &#123; public Permission resolvePermission(String s) &#123; if(s.startsWith("+"))&#123; return new BitPermission(s); &#125; return new WildcardPermission(s); &#125;&#125; BitAndWildPermissionResolver实现了PermissionResolver接口，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission 3、定义MyRolePermissionResolverPermissionResolver用于根据角色字符串来解析得到权限集合12345678910111213141516171819202122import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.permission.RolePermissionResolver;import org.apache.shiro.authz.permission.WildcardPermission;import java.util.Arrays;import java.util.Collection;/** * @ClassName MyRolePermissionResolver * @Description TODO * @Author zp * @Date 2018/11/2716:53 * @Version 1.0 **/public class MyRolePermissionResolver implements RolePermissionResolver &#123; public Collection&lt;Permission&gt; resolvePermissionsInRole(String s) &#123; if("role1".equals(s))&#123; return Arrays.asList((Permission)new WildcardPermission("menu:*")); &#125; return null; &#125;&#125; 此处的逻辑很简单，如果用户拥有role1，那么就返回“menu:*”的权限4、自定义Realm1234567891011121314151617181920212223242526272829303132333435363738394041import com.smartcore.permission.BitPermission;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.authz.permission.WildcardPermission;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @ClassName MyRealm * @Description TODO * @Author zp * @Date 2018/11/2716:43 * @Version 1.0 **/public class MyRealm extends AuthorizingRealm &#123; protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRole("role1"); authorizationInfo.addRole("role2"); authorizationInfo.addObjectPermission(new BitPermission("+user1+10")); authorizationInfo.addObjectPermission(new WildcardPermission("user1:*")); authorizationInfo.addStringPermission("+user2+10"); authorizationInfo.addStringPermission("user2:*"); return authorizationInfo; &#125; protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String username = (String)token.getPrincipal(); //得到用户名 String password = new String((char[])token.getCredentials()); //得到密码 if(!"zhang".equals(username)) &#123; throw new UnknownAccountException(); //如果用户名错误 &#125; if(!"123".equals(password)) &#123; throw new IncorrectCredentialsException(); //如果密码错误 &#125; //如果身份认证验证成功，返回一个AuthenticationInfo实现； return new SimpleAuthenticationInfo(username, password, getName()); &#125;&#125; 此时我们继承 AuthorizingRealm而不是实现Realm接口；推荐使用 AuthorizingRealm ，因为： AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)：表示获取身份验证信息 AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)：表示根据用户身份获取身份信息这种方式的好处是当需要身份验证时只需要获取身份验证信息而不需要获取授权信息。另外我们还可以使用JdbcRealm，需要如下操作： 执行 sql/ shiro-init-data.sql 插入相关的权限数据 使用shiro-jdbc-authorizer.ini 的配置文件，需要设置jdbcRealm.permissionsLookupEnabled为true来开启权限查询 此次还要注意就是不能把我们自定义的如“+user+10”配置到ini文件中即使有IniRealm完成，IniRealm在new完成后就会解析这些权限字符串，默认使用WildCardPermissionResolver，即此处是一个设计权限，如果采用生命周期（如使用初始化方法）的方式进行加载就可以解决我们自定义permissionResolver的问题。5、测试用例123456789101112131415161718192021222324252627282930import org.junit.Assert;import org.junit.Test;/** * @ClassName AuthorizerTest * @Description TODO * @Author zp * @Date 2018/11/288:47 * @Version 1.0 **/public class AuthorizerTest extends BaseTest&#123; @Test public void testIsPermitted()&#123; login("classpath:shiro-authorizer.ini", "zhang", "123"); //判断拥有权限：user:create Assert.assertTrue(subject().isPermitted("user1:update")); Assert.assertTrue(subject().isPermitted("user2:update")); //通过二级制方式表示权限 Assert.assertTrue(subject().isPermitted("+user1+2"));//新增权限 Assert.assertTrue(subject().isPermitted("+user1+8"));//查看权限 Assert.assertTrue(subject().isPermitted("+user2+10"));//新增及查看权限 Assert.assertTrue(subject().isPermitted("+user1+4"));//没有删除权限 Assert.assertTrue(subject().isPermitted("menu:view"));//通过MyRolePermissionResolver解析得到权限 &#125;&#125; 通过上面的步骤可以实现自定义验证了。另外因为不支持hasAnyRole/isPermittedAny这种方法的授权，可以参考shiro扩展实现NOT、AND、OR权限验证进行简单的扩展完成这个需求，在这篇文章中通过重写 AuthorizingRealm 里面的验证逻辑实现的。 本章节亮点BaseTest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.apache.shiro.util.ThreadContext;import org.junit.After;/** * @ClassName BaseTest * @Description TODO * @Author zp * @Date 2018/11/615:20 * @Version 1.0 **/public abstract class BaseTest &#123; @After public void tearDown() throws Exception &#123; ThreadContext.unbindSubject();//退出时请解除绑定Subject到线程 否则对下次测试造成影响 &#125; protected void login(String configFile,String username,String password)&#123; Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(configFile); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; &#125; public Subject subject() &#123; return SecurityUtils.getSubject(); &#125;&#125;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 身份认证]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[身份认证: 在应用中证明自己是谁；一般提供用户自己的ID证明自己是谁，比如用户名和密码在Shiro中，用户需要提供principals(身份)和credentials（证明）给shiro，从而验证用户的身份principals: 身份，主体的标识属性，可以是任何东西：邮箱，用户名等等，但必须唯一。一个主体可以有多个principals，但只有一个Primary principalscredentials: 证明，凭据，即主体对应的安全值，如密码/数字证书等。 环境准备Maven配置1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0-RC2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 登录/退出 用户身份凭据（shior.ini）在shiro-test\src\test\resources下创建文件shiro.ini，用来保存用户信息,通过[users]制定了两个主体 123[users]zhang=123wang=123 测试用例 123456789101112131415161718192021222324252627282930313233343536373839import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Assert;import org.junit.Test;public class LoginLogoutTest &#123; @Test public void testHelloworld()&#123; //1、获取SecurityManager工厂，此处使用ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro.ini"); //2、得到SecurityManager实例 并绑定SecurityUtil org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（用户身份证/凭据） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; //4、登录，即身份验证成功 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份认证失败 e.printStackTrace(); &#125; Assert.assertEquals(true,subject.isAuthenticated());//断言用户已经登录 //6、退出 subject.logout(); &#125;&#125; 代码解析 1、首先通过new IniSecurityManagerFactory并制定一个ini文件来创建一个SecurityManager工厂；2、接着获取SecurityManager并绑定到SecurityUtils, 这是一个全局设置，设置一次即可3、通过SecurityUtil得到Subject,其会自动绑定到当前线程；如果web环境在请求结束，需要解除绑定；然后获取身份认证的Token，如用户名/密码4、调用subject.log方法进行登录，其会自动委托给SecurityManager.login方法进行登录5、如果身份验证失败请捕获AuthenticationException或其子类，常见如：DiabledAccountExceprion(禁用的账号)、LockedAccountException(锁定的账号)、UnKnownAccountException（未知的账号）、、ExcessiveAttemptsException(登录失败次数过多)、IncorrectCredentialsException（错误凭证）、ExpiredCredentialsException(过期凭证)，对于错误消息的展示，最好使用“用户名或密码不正确”，防止提示太过详细，容易出现恶意扫描账号6、最后可以调用subject.logout退出如上代码可总结出身份验证的步骤：1、收集用户身份凭据，如用户名和密码2、调用Subject.login()进行登录，如果失败，得到相应的AuthenticationException异常；否则登录成功3、调用Subject.logout进行退出操作 身份认证的流程 首先调用Subject.login(token)进行登录，其会自动委托给SecurityManager，调用之前必须通过SecurityUtil.setSecurityManger()设置 SecurityManager负责真正的身份验证逻辑；他会委托给Authenticator进行身份验证 Authenticator才是真正的身份验证者， 可以自定义自己的实现 Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator 会把相应的token传入Realm，从Realm中获取身份验证信息，如果没有返回或者抛出异常表明身份验证失败。可以自定义多个Realm，将按照相应的顺序和策略进行访问 RealmRealm： 域,Shiro从Realm中获取安全数据（用户、角色、权限），可以理解为Realm是DataSource，安全数据源，如上面配置的ini文件使用的org.apache.shiro.realm.text.IniRealm org.apache.shiro.realm.Realm接口如下1234String getName();//返回一个唯一的Realm的名字boolean supports(AuthenticationToken token)//判断此Realm是否支持此TokenAuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;//根据Token获取认证信息 单Realm配置 自定义Realm实现 123456789101112131415161718192021222324252627import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;public class MyRealm1 implements Realm &#123; public String getName() &#123; return "myrealm1"; &#125; public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken;//仅支持UsernamePasswordToken类型的Token &#125; public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials());//得到密码 if(!"zhang".equals(userName))&#123; throw new UnknownAccountException();//用户名错误 &#125; if(!"123".equals(password))&#123; throw new IncorrectCredentialsException();//密码错误 &#125; return new SimpleAuthenticationInfo(userName,password,getName()); &#125;&#125; ini配置文件指定自定义的Realm（shiro-realm.ini） 1234# 声明一个realmmyRealm1=com.shirotest.realm.MyRealm1# 指定securityManager的realms实现securityManager.realms=$myRealm1 测试代码 123456789101112131415161718192021222324252627@Testpublic void testCustomRealm()&#123; //1、获取SecurityManager工厂，此处使用ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;); //2、得到SecurityManager实例，绑定SecurityUtil SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名和密码对应的Token Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;); try &#123; //4、登录，即身份验证成功 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份认证失败 e.printStackTrace(); &#125; Assert.assertEquals(true,subject.isAuthenticated());//断言用户已经登录 //6、退出 subject.logout();&#125; 多Realm实现1、myRealm2代码12345678910111213141516171819202122232425262728293031import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;public class MyRealm2 implements Realm &#123; @Override public String getName() &#123; return &quot;myrealm2&quot;; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials()); if(!&quot;wang&quot;.equals(userName))&#123; throw new UnknownAccountException();//账号错误 &#125; if(!&quot;123&quot;.equals(password))&#123; throw new IncorrectCredentialsException();//密码错误 &#125; //如果认证通过，返回一个AuthenticationInfo实现 return new SimpleAuthenticationInfo(userName,password,getName()); &#125;&#125; 2、ini配置文件（shiro-multi-realm.ini）12345# 声明一个realmmyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2# 指定securityManager的realms实现securityManager.realms=$myRealm1,$myRealm2 security按照realm指定的顺序进行身份认证。 此处我们使用显示指定顺序的方式指定了Realm的顺序，如果删除掉securityManager.realms=$myRealm1,$myRealm2，那么securityManager会按照realm声明的顺序进行使用（即无需声明顺序，系统会自动查找Realm），当我们显示指定realm后，其他没有指定的realm会被忽略，如securityManager.realms=$myRealm1,myRealm2会被自动忽略 3、测试代码12345678910111213141516171819@Testpublic void testCustomMultiRealm()&#123; Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro-multi-realm.ini"); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; subject.logout();&#125; Shiro默认提供的Realm 以后一般集成AuthorizingRealm(授权)即可；其集成了AuthenticatingRealm（即身份认证），而且间接集成了CachingRealm(带缓存实现)。其中主要默认实现如下：org.apache.shiro.realm.text.IniRealm: [users]部分指定用户名/密码及对应角色；[roles]部分指定角色即角色授权信息；org.apache.shiro.realm.text.PropertiesRealm: user.username=password,role1,role2指定用户/密码及角色；role.role1=permission1,permission2指定角色对应即权限；org.apache.shiro.realm.jdbc.JdbcRealm:通过sql查询相应的信息，如select password from users where username = ? 获取用户密码;select password,password_salt from users where username = ?获取用户密码及盐；select permission from role_permissions where role_name = ?获取角色对应权限；也可以调用相应的api进行自定义sql； JDBC Realm使用1、数据库及依赖(pom.xml)12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0-RC2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、数据库shiro创建三张表：users（用户名/密码）、user_roles(用户/角色)、roles_permissions(角色权限)，并添加一个用户名/密码为zhang/123;123456789101112131415161718192021222324252627282930drop database if exists shiro;create database shiro;use shiro;create table users ( id bigint auto_increment, username varchar(100), password varchar(100), password_salt varchar(100), constraint pk_users primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_users_username on users(username);create table user_roles( id bigint auto_increment, username varchar(100), role_name varchar(100), constraint pk_user_roles primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_user_roles on user_roles(username, role_name);create table roles_permissions( id bigint auto_increment, role_name varchar(100), permission varchar(100), constraint pk_roles_permissions primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_roles_permissions on roles_permissions(role_name, permission);insert into users(username,password)values('zhang','123'); 3、ini配置（shiro-jdbc.realm.ini）123456789[main]jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://192.168.2.62:3306/shirodataSource.username=rootdataSource.password=mcprdjdbcRealm.dataSource=$dataSourcesecurityManager.realms=$jdbcRealm Authenticator及AuthenticationStrategyAuthenticator的职责是验证用户账号，是Shiro API中身份验证核心的入口点：1public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException 如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败抛出相应的AuthenticationException实现。SecurityManager接口集成了Authenticator，另外还有一个ModularRealAuthenticator实现，其委托了多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：FirstSuccessfulStrategy：只要有一个Realm验证通过即可，只返回第一个Realm身份验证成功的认证信息，其他忽略AtLeastOneSuccessfulStrategy:只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同点载于，返回所有Realm身份验证成功的认证信息AllSuccessfulStrategy:所有Realm验证成功，且返回所有的Realm验证成功信息，如果有一个失败就整个失败。 ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。假设有三个Realm： myRealm1：用户名和密码分别为zhang/123的时候登录成功，并返回登录信息zhang/123 myRealm2：用户名和密码分别为wang/123的时候登录成功，并返回登录信息wang/123 myRealm3：用户名和密码分别为zhang/123的时候登录成功，并返回登录信息zhang@163.com/123myRealm3和myRealm1基本上一样，但是返回时的身份变了 1、ini配置文件（shiro-authenticator-all-success.ini）12345678910111213[main]# 指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator# 指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2myRealm3=com.shirotest.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3 2、MyRealm3的代码12345678910111213141516171819202122232425262728293031323334353637import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;/** * @ClassName MyRealm3 * @Description TODO * @Author zp * @Date 2018/11/313:47 * @Version 1.0 **/public class MyRealm3 implements Realm &#123; @Override public String getName() &#123; return "myrealm3"; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials()); if(!"zhang".equals(userName))&#123; throw new UnknownAccountException(); &#125; if(!"123".equals(password))&#123; throw new IncorrectCredentialsException(); &#125; return new SimpleAuthenticationInfo(userName+"@163.com",password,getName()); &#125;&#125; 3、测试代码3.1、测试全部验证成功并返回多条成功验证结果记录（ AllSuccessfulStrategy ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Assert;import org.junit.Test;/** * @ClassName AuthenticatorTest * @Description TODO * @Author zp * @Date 2018/11/313:59 * @Version 1.0 **/public class AuthenticatorTest &#123; @Test public void testAllSuccessfulStrategyWithSuccess()&#123; login("shiro-authenticator-all-success.ini"); Subject subject = SecurityUtils.getSubject(); //得到一个身份集合，其包含了Realm验证成功的身份信息 PrincipalCollection principalCollection = subject.getPrincipals(); Assert.assertEquals(2,principalCollection.asList().size()); &#125; /** *@Description 常规测试登录代码 *@param [configFile] *@return void *@author zp *@date 2018/11/3 15:56 **/ private void login(String configFile)&#123; Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:"+configFile); org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); subject.login(token); &#125;&#125; 3.2、测试不能通过所有验证，返回失败代码（AllSuccessfulStrategy）12345678910111213[main]# 指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator#指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2myRealm3=com.shirotest.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm2 1234@Test(expected = UnknownAccountException.class)public void testAllSucessfulStrategyWithFail()&#123; login("shior-authenticator-all-fail.ini");&#125; shiro-authenticator-all-fail.ini 与 shiro-authenticator-all-success.ini不同的配置是使用了securityManager.realms=$myRealm1,$myRealm2；即myRealm2验证失败。 对于AtLeastOneSuccessfulStrategy和FirstSuccessfulStrategy的区别，在与第一个是至少有一个满足就可以验证通过，第二个是只要找到一个就可以通过验证，并且返回第一个验证通过的Realm信息。 自定义AuthenticationStrategy实现：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 Shiro简介]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Shiro%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介 Shiro不仅可以应用在JavaSE环境，也可以用在JavaEE环境。 Shiro能够完成的任务： 认证 授权 加密 会话管理 Web集成 缓存 Authentication:身份认证/登录，验证用户是否拥有相应的身份 Authorization:授权，权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户是否对某个资源是否具有某个权限 Session Manager:会话管理，用户登录后就是一次会话，在没有退出之前，他的所有信息都会在会话中 Cryptography:加密，保护数据的安全性，如密码加密存储到数据库，而不是铭文存储 Web Support:Web支持，可以非常容易的集成到Web环境 Caching:缓存，比如用户登录后，其用户信息，拥有的角色/授权信息不必每次去查询，这样可以提高效率 Concurrency:shiro支持多线程应用的并发验证，即如果在一个线程中开一另一个线程，能够把权限自动传播过去 Testing:提供测试支持 Run As:允许一个用户假装为另一个用户的身份访问 Remember Me:记住我，下次再来不用登陆了 Shiro是不会去维护权限、用户的数据的；这些需要我们自己去设计/提供；然后通过相应的接口注入到Shiro 从上图可以看出应用程序代码直接交互的对象是Subject，也就是Shiro的对外核心API是Subject： Subject:主体，代表当前用户，不一定是具体的人，与当前应用交互的所有对象都可以使Subject；所有的Subject都是绑定到SecurityManager的，也就是最终干活的都是SecurityManager，Subject只是一个门面 SecurityManager:安全管理器，所有与安全有关的操作都会与SecurityManager交互，而且它管理着所有的Subject。它同时负责着与后面其他的组件的交互。 Realm:域，Shiro从Realm获取安全数据（用户，角色，权限）；SecurityManager验证用户的时候，需要从Realm中读取数据，验证用户数据的合法性，同时还需要从Realm中读取用户的权限和角色验证用户是否能够操作。简单的来说可以从认为Realm为一个DataSource，即安全数据源 最简单的Shiro应用设计思路： 应用通过Subject来进行认证和授权，而Subject委托给SecurityManager进行处理 我们需要给SecurityManager注入Realm，从而让SecurityManager获取到相应的用户及权限进行判断 Subject:主体，可以看到主体是任何可以与应用交互的“用户” SecurityManager:Shiro的心脏，具体的交互都通过Securitymanager进行控制；管理所有的Subject，进行权限、授权、会话及缓存的管理 Authenticator:认证器，负责主体认证，可自定义实现；其需认证策略（Authentication Strategy），即什么情况下算是用户通过了 Authrizer:授权器，用来决定主体是否有权限进行相应的操作 Realm:可以有一个或者多个，安全实体数据源，用于获取安全实体，一般是自己实现Realm SessionManager:Session的管理组件，可以通过专门的Session管理服务器实现分布式会话 SessionDao:当需要把Session存储到数据库的时候使用的工具 CacheManager:缓存控制器，来管理用户、角色、权限的缓存 Cryptograpy:密码模块，Shiro提供了一些常见的加密组件用于密码加密和解密]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS正则表达式校验手机号、邮箱、网址、日期、身份证]]></title>
    <url>%2F2019%2F01%2F25%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%A1%E9%AA%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%E3%80%81%E9%82%AE%E7%AE%B1%E3%80%81%E7%BD%91%E5%9D%80%E3%80%81%E6%97%A5%E6%9C%9F%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%2F</url>
    <content type="text"><![CDATA[常规正则表达式1234567891011121314151617181920212223验证手机号：/^1\d&#123;10&#125;$/验证邮箱：/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/验证url：/(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/日期：/^(\d&#123;4&#125;)[-\/](\d&#123;1&#125;|0\d&#123;1&#125;|1[0-2])([-\/](\d&#123;1&#125;|0\d&#123;1&#125;|[1-2][0-9]|3[0-1]))*$/证身份证：/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(x|X|\d)$)/中文：[\u4e00-\u9fa5]电话号码（国内）：[0-9-()（）]&#123;7,18&#125;邮政编码：\d&#123;6&#125;IP地址：(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)正整数：[1-9]\d*负整数：-[1-9]\d*用户名：[A-Za-z0-9_\-\u4e00-\u9fa5]+ 使用方法12345var reg=/(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/;if(!reg.test(data.field.link))&#123; layer.msg(&apos;外链格式错误，请输入以http://或https://开头的完整url！&apos;,&#123;icon: 5&#125;); return false;&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>正则校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Url中传递JSONObject、JSONArray对象]]></title>
    <url>%2F2019%2F01%2F25%2FUrl%E4%B8%AD%E4%BC%A0%E9%80%92JSONObject%E3%80%81JSONArray%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Url中传递JSONObject 首先说明下项目背景，要求用layer.open打开一个页面，但是传递的主键字段是不确定的，因此需要组装一个JSONObject，里面放入动态的主键，从而让后台通过JSON遍历得到主键，然后进行数据的查询 首先想到的是通过JSON.stringify()方法(不可行)但是发现上面的思路是不可行的，以为会出现json中的双引号，造成只能传递一个{到后台，不能传递整个JSON 第二种方法是使用encodeURI()方法(可行)12345678layer.open(&#123; 'title': '编辑数据', // 弹出框标题 'shade': [0.8, '#393D49'], // 遮盖罩 'type': 2, // 打开类型 'area': ['80%', '80%'], // 弹出框大小 'maxmin': true, // 最大化 content: basePath + 'customManage/openListChildPage.do?TYPE_ID='+ encodeURI(jsonObj) &#125;); 多扯两句，关于ajax传递json对象到后台的问题这个问题相对简单，是可以直接使用ajax的data内置参数，直接传递json对象到后台的]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSONObject</tag>
        <tag>JSONArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS setInterval()方法]]></title>
    <url>%2F2019%2F01%2F25%2FJS-setInterval-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[定义和用法setInterval是按照指定周期（毫秒）调用函数或计算表达式，会不停的调用函数，直到调用clearInterval或者窗口关闭。其中setinterval返回的ID可以用作clearInterval方法的参数 语法1setInterval(code,millisec[,"lang"]) 参数 是否必须 描述 code 是 循环调用的代码或者需要执行的代码穿 millisec 是 执行的周期，毫秒为单位 返回值可以用作clearInterval()从而取消code循环执行的ID 实例123456789101112131415161718&lt;html&gt;&lt;body&gt;&lt;input type="text" id="clock" size="35" /&gt;&lt;script language=javascript&gt;var int=self.setInterval("clock()",50)function clock() &#123; var t=new Date() document.getElementById("clock").value=t &#125;&lt;/script&gt;&lt;/form&gt;&lt;button onclick="int=window.clearInterval(int)"&gt;Stop interval&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>setInterval</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS字符串转JSON对象]]></title>
    <url>%2F2019%2F01%2F25%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACJSON%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS字符串转换成JSON对象目前发现了四种方法 1. Jquery方法示例代码:123//将json字符串转换成json对象$.parseJSON(jsonStr);jQuery.parseJSON(jsonStr) 2. 浏览器支持转换的方法（Firefox、Chrome、opera、safari、ie）1JSON.parse(jsonstr)//可以将json字符串转换成json对象 1JSON.stringify(jsonOjb)//可以将JSONObject转换成json字符串 3. Javascript支持的转换方式（不建议）1eval(&apos;(&apos; + jsonstr + &apos;)&apos;); 4. JSON官方的转换方式JSON官网提供的Github上的关于JSON转换的方法 当然还有很多方法，在官网下面有很多各个语言的处理方法，具体的链接可以查看]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态创建a标签并添加事件]]></title>
    <url>%2F2019%2F01%2F25%2Fjs%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAa%E6%A0%87%E7%AD%BE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目中有一个新需求，前后台分离，然后前台需要拿到数据后动态的创建a标签，并且给a标签上添加上事件，而且事件的参数是不一样的 下面是一种方法，可以尝试下12345678910111213for(var i=0;i &lt; datalist.length;i++)&#123; (function(i)&#123; var a=document.createElement('a'); var innerText = datalist[i].DOC_NAME a.innerHTML=innerText; a.addEventListener('click',function(e)&#123; e.preventDefault(); //取消默认事件，指a标签 alert(121); &#125;); $("#all-items").append(a); &#125;)(i);&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>动态添加事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webuploader同一页面多实例上传图片及回显]]></title>
    <url>%2F2019%2F01%2F25%2Fwebuploader%E5%90%8C%E4%B8%80%E9%A1%B5%E9%9D%A2%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%8F%8A%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[1. 业务页面JSP(goods_detail_edit.jsp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;overview &amp; stats&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;link href=&quot;static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;static/css/bootstrap-responsive.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/font-awesome.min.css&quot; /&gt;&lt;!-- 下拉框 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/chosen.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace-responsive.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace-skins.min.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;!--提示框--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery.tips.js&quot;&gt;&lt;/script&gt;&lt;!-- 上传图片 --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;plugins/webuploader/webuploader.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;plugins/webuploader/style.css&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;td input &#123; width: 97%;&#125;tr th &#123; font-size: 13px; font-weight: bold; vertical-align: middle;&#125;#wrapper &#123; margin: 0;&#125;#uploader .placeholder &#123; background: url(plugins/webuploader/image.png) center 23px no-repeat; padding-top: 88px; min-height: 110px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;goodsDetail/$&#123;msg &#125;.do&quot; name=&quot;goodsForm&quot; id=&quot;goodsForm&quot; method=&quot;post&quot;&gt; &lt;div id=&quot;zhongxin&quot;&gt; &lt;table id=&quot;table_report&quot; class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品编码:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;hidden&quot; id=&quot;checkGoodsCode&quot; value=&quot;$&#123;pd.goods_code&#125;&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;GOODS_CODE&quot; id=&quot;GOODS_CODE&quot; value=&quot;$&#123;pd.goods_code&#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入商品编码&quot; title=&quot;商品编码&quot; onblur=&quot;checkHasCode()&quot; /&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品类型:&lt;/th&gt; &lt;td&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;GOODS_TYPE&quot; id=&quot;GOODS_TYPE&quot; data-placeholder=&quot;请选择商品类型&quot; style=&quot;vertical-align:top;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;cateGoryList&#125;&quot; var=&quot;cateGory&quot;&gt; &lt;option value=&quot;$&#123;cateGory.GOODS_TYPE&#125;&quot; &lt;c:if test=&quot;$&#123;pd.goods_type==cateGory.GOODS_TYPE&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;$&#123;cateGory.DESCRIPTION &#125; &lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品名称:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;GOODS_NAME&quot; id=&quot;GOODS_NAME&quot; value=&quot;$&#123;pd.goods_name &#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入商品名称&quot; title=&quot;商品名称&quot; /&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品别名:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;GOODS_ABBR_NAME&quot; id=&quot;GOODS_ABBR_NAME&quot; value=&quot;$&#123;pd.goods_abbr_name &#125;&quot; maxlength=&quot;64&quot; placeholder=&quot;请输入商品别名&quot; title=&quot;商品别名&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;特殊商品:&lt;/th&gt; &lt;td style=&quot;vertical-align:top;&quot;&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;IS_SPECIAL&quot; id=&quot;IS_SPECIAL&quot; data-placeholder=&quot;是否特殊商品&quot; style=&quot;vertical-align:top;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Y&quot; &lt;c:if test=&quot;$&#123;pd.is_special==&apos;Y&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;特殊商品&lt;/option&gt; &lt;option value=&quot;N&quot; &lt;c:if test=&quot;$&#123;pd.is_special==&apos;N&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;非特殊商品&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;是否有效:&lt;/th&gt; &lt;td style=&quot;vertical-align:top;&quot;&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;IS_VALID&quot; id=&quot;IS_VALID&quot; data-placeholder=&quot;是否有效&quot; style=&quot;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Y&quot; &lt;c:if test=&quot;$&#123;pd.is_valid==&apos;Y&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;有效&lt;/option&gt; &lt;option value=&quot;N&quot; &lt;c:if test=&quot;$&#123;pd.is_valid==&apos;N&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;无效&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;菜单编码:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;MENU_CODE&quot; id=&quot;MENU_CODE&quot; value=&quot;$&#123;pd.menu_code &#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入菜单编码&quot; title=&quot;菜单编码&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;textarea name=&quot;GOODS_DESC&quot; id=&quot;GOODS_DESC&quot; rows=&quot;5&quot; cols=&quot;50&quot; style=&quot;width:99%;&quot; placeholder=&quot;请选输入商品描述&quot; title=&quot;请选输入商品描述&quot;&gt;$&#123;pd.goods_desc&#125;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;FILE_PATH&quot; id=&quot;FILE_PATH&quot; value=&quot;$&#123;pd.FILE_PATH&#125;&quot; /&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;container&quot; class=&quot;uploadFile&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePicker&quot;&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选5张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;detail_image_url&quot; id=&quot;detail_image_url&quot; value=&quot;$&#123;pd.detail_image_url&#125;&quot; /&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;container&quot; class=&quot;uploadFile&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePickerDetail&quot;&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选5张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align: center;&quot; colspan=&quot;4&quot;&gt; &lt;a class=&quot;btn btn-mini btn-primary&quot; onclick=&quot;save();&quot;&gt;保存&lt;/a&gt; &lt;a class=&quot;btn btn-mini btn-danger&quot; onclick=&quot;top.Dialog.close();&quot;&gt;取消&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=&quot;zhongxin2&quot; class=&quot;center&quot; style=&quot;display:none&quot;&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;img src=&quot;static/images/jiazai.gif&quot; /&gt;&lt;br /&gt; &lt;h4 class=&quot;lighter block green&quot;&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 引入 --&gt; &lt;script type=&quot;text/javascript&quot;&gt;window.jQuery || document.write(&quot;&lt;script src=&apos;static/js/jquery-1.9.1.min.js&apos;&gt;\x3C/script&gt;&quot;);&lt;/script&gt; &lt;script src=&quot;static/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/ace-elements.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/ace.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;static/js/chosen.jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 下拉框 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;plugins/webuploader/webuploader.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/goods/goods_detail_edit.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //单选框 $(&quot;.chzn-select&quot;).chosen(); $(&quot;.chzn-select-deselect&quot;).chosen(&#123;allow_single_deselect:true&#125;); &#125;); $(top.hangge()); $(document).ready(function()&#123; if($(&quot;#user_id&quot;).val()!=&quot;&quot;)&#123; $(&quot;#loginname&quot;).attr(&quot;readonly&quot;,&quot;readonly&quot;); $(&quot;#loginname&quot;).css(&quot;color&quot;,&quot;gray&quot;); &#125; &#125;); //保存 function save()&#123; //验证商品编码是否为空 if($(&quot;#GOODS_CODE&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_CODE&quot;).tips(&#123; side:3, msg:&apos;请输入商品编码&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_CODE&quot;).focus(); return false; &#125; if($(&quot;#GOODS_NAME&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_NAME&quot;).tips(&#123; side:3, msg:&apos;请输入商品名称&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_NAME&quot;).focus(); return false; &#125; if($(&quot;#GOODS_ABBR_NAME&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_ABBR_NAME&quot;).tips(&#123; side:3, msg:&apos;请输入商品别名&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_ABBR_NAME&quot;).focus(); return false; &#125; //保存之前处理图片数据 var lbfiles = uploader[0].getFiles(&quot;complete&quot;);//轮播图 var lbFilesUrl=&quot;&quot;; $(lbfiles).each(function(index,item)&#123; lbFilesUrl = lbFilesUrl+&quot;;&quot;+item.url; &#125;); $(&quot;#FILE_PATH&quot;)[0].value = lbFilesUrl; //保存之前处理图片数据 var detailfiles = uploader[1].getFiles(&quot;complete&quot;);//商品详情图 var detailFilesUrl=&quot;&quot;; $(detailfiles).each(function(index,item)&#123; detailFilesUrl = detailFilesUrl+&quot;;&quot;+item.url; &#125;); $(&quot;#detail_image_url&quot;)[0].value = detailFilesUrl; $(&quot;#goodsForm&quot;).submit(); $(&quot;#zhongxin&quot;).hide(); $(&quot;#zhongxin2&quot;).show(); &#125; //校验编码是否存在 function checkHasCode()&#123; var goodsCode = $(&quot;#GOODS_CODE&quot;)[0].value; var checkGoodsCode = $(&quot;#checkGoodsCode&quot;)[0].value; if(goodsCode == checkGoodsCode)return; $.ajax(&#123; type: &quot;GET&quot;, url: &apos;&lt;%=basePath%&gt;goodsDetail/hasCode.do?tm=&apos;+new Date().getTime() + &apos;&amp;GOODS_CODE=&apos; + goodsCode, data : &apos;&apos;, dataType : &apos;json&apos;, cache : false, success : function(data) &#123; if (data.result == &quot;error&quot;) &#123; alert(&quot;编码重复，请重新输入&quot;); $(&quot;#GOODS_CODE&quot;)[0].value = checkGoodsCode; &#125;; &#125; &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.1 对应上传的js(goods_detail_edit.js)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621(function($)&#123; // 当domReady的时候开始初始化 $(function() &#123; uploader = new Array();//创建 uploader数组 // 判断浏览器是否支持图片的base64 var isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125;; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(); if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;); break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;); break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; $(&apos;.uploadFile&apos;).each(function(index)&#123; var $wrap = $(&apos;#uploader&apos;)[index], // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ).appendTo( $(this).find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $(this).find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $(this).find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $(this).find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;; var locat = (window.location+&apos;&apos;).split(&apos;/&apos;); if(&apos;pictures&apos;== locat[3])&#123;locat = locat[0]+&apos;//&apos;+locat[2];&#125;else&#123;locat = locat[0]+&apos;//&apos;+locat[2]+&apos;/&apos;+locat[3];&#125;; uploader[index] = WebUploader.create(&#123; pick: &#123; id: index==0?&apos;#filePicker&apos;:&apos;#filePickerDetail&apos;, label: &apos;点击选择图片&apos; &#125;, dnd: &apos;#dndArea&apos;, swf: &apos;./Uploader.swf&apos;, chunked: false, chunkSize: 512 * 1024, //server: &apos;http://127.0.0.1:8080/pictures/save.do&apos;, server: &apos;goodsDetail/uploadImg.do?&apos;, //runtimeOrder: &apos;flash&apos;, accept: &#123; title: &apos;Images&apos;, extensions: &apos;gif,jpg,jpeg,bmp,png&apos;, mimeTypes: &apos;image/*&apos; &#125;, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 disableGlobalDnd: true, fileNumLimit: index==0?5:1, fileSizeLimit: 200 * 1024 * 1024, // 200 M fileSingleSizeLimit: 50 * 1024 * 1024 // 50 M &#125;); // 拖拽时不接受 js, txt 文件。 uploader[index].on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); // uploader.on(&apos;filesQueued&apos;, function() &#123; // uploader.sort(function( a, b ) &#123; // if ( a.name &lt; b.name ) // return -1; // if ( a.name &gt; b.name ) // return 1; // return 0; // &#125;); // &#125;); // 添加“添加文件”的按钮， if(index==0)&#123; uploader[index].addButton(&#123; id: &apos;#filePicker2&apos;, label: &apos;继续添加&apos; &#125;); &#125; var getFileBlob = function(url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.addEventListener(&apos;load&apos;, function() &#123; cb(xhr.response); &#125;); xhr.send(); &#125;; var blobToFile = function(blob, name) &#123; blob.lastModifiedDate = new Date(); blob.name = name; return blob; &#125;; var getFileObject = function(filePathOrUrl, cb) &#123; getFileBlob(filePathOrUrl, function(blob) &#123; cb(blobToFile(blob, &apos;test.jpg&apos;)); &#125;); &#125;; //回显图片 uploader[index].on(&apos;ready&apos;, function() &#123; window.uploader = uploader; var filePathArg = index==0?$(&quot;#FILE_PATH&quot;)[0].value.split(&apos;;&apos;):$(&quot;#detail_image_url&quot;)[0].value.split(&apos;;&apos;); var files=new Array(); var i=0; if(filePathArg.length&gt;0)&#123; $.each(filePathArg, function(tempindex,item) &#123; //如果图片是空值，就直接返回 if(item==&apos;&apos;||item==&quot;undefined&quot;||item==undefined)&#123; return true; &#125; getFileObject(item, function(fileObject) &#123; var wuFile = new WebUploader.Lib.File(WebUploader.guid(&apos;rt_&apos;), fileObject); var tempfile = new WebUploader.File(wuFile); tempfile.url=item; tempfile.setStatus(&apos;complete&apos;); uploader[index].addFiles(tempfile); &#125;); &#125;); &#125;; &#125;); uploader[index].on( &apos;uploadSuccess&apos;, function( file,response ) &#123; file.url=response.path; if(index==0)&#123; $(&quot;#FILE_PATH&quot;)[0].value = $(&quot;#FILE_PATH&quot;)[0].value+&quot;;&quot;+response.path; &#125;else&#123; $(&quot;#detail_image_url&quot;)[0].value = $(&quot;#detail_image_url&quot;)[0].value+&quot;;&quot;+response.path; &#125; &#125;); // 当有文件添加进来时执行，负责view的创建 function addFile( file ) &#123; var $li = $( &apos;&lt;li id=&quot;&apos; + file.id + &apos;&quot;&gt;&apos; + &apos;&lt;p class=&quot;title&quot;&gt;&apos; + file.name + &apos;&lt;/p&gt;&apos; + &apos;&lt;p class=&quot;imgWrap&quot;&gt;&lt;/p&gt;&apos;+ &apos;&lt;p class=&quot;progress&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;/li&gt;&apos; ), $btns = $(&apos;&lt;div class=&quot;file-panel&quot;&gt;&apos; + &apos;&lt;span class=&quot;cancel&quot;&gt;删除&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateRight&quot;&gt;向右旋转&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateLeft&quot;&gt;向左旋转&lt;/span&gt;&lt;/div&gt;&apos;).appendTo( $li ), $prgress = $li.find(&apos;p.progress span&apos;), $wrap = $li.find( &apos;p.imgWrap&apos; ), $info = $(&apos;&lt;p class=&quot;error&quot;&gt;&lt;/p&gt;&apos;), showError = function( code ) &#123; switch( code ) &#123; case &apos;exceed_size&apos;: text = &apos;文件大小超出&apos;; break; case &apos;interrupt&apos;: text = &apos;上传暂停&apos;; break; default: text = &apos;上传失败，请重试&apos;; break; &#125; $info.text( text ).appendTo( $li ); &#125;; if ( file.getStatus() === &apos;invalid&apos; ) &#123; showError( file.statusText ); &#125; else &#123; // @todo lazyload $wrap.text( &apos;预览中&apos; ); uploader[index].makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( &apos;不能预览&apos; ); return; &#125; if( isSupportBase64 ) &#123; img = $(&apos;&lt;img src=&quot;&apos;+src+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $.ajax(&apos;../../server/preview.php&apos;, &#123; method: &apos;POST&apos;, data: src, dataType:&apos;json&apos; &#125;).done(function( response ) &#123; if (response.result) &#123; img = $(&apos;&lt;img src=&quot;&apos;+response.result+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $wrap.text(&quot;预览出错&quot;); &#125; &#125;); &#125; &#125;, thumbnailWidth, thumbnailHeight ); percentages[ file.id ] = [ file.size, 0 ]; file.rotation = 0; &#125; file.on(&apos;statuschange&apos;, function( cur, prev ) &#123; if ( prev === &apos;progress&apos; ) &#123; $prgress.hide().width(0); &#125; else if ( prev === &apos;queued&apos; ) &#123; $li.off( &apos;mouseenter mouseleave&apos; ); $btns.remove(); &#125; // 成功 if ( cur === &apos;error&apos; || cur === &apos;invalid&apos; ) &#123; console.log( file.statusText ); showError( file.statusText ); percentages[ file.id ][ 1 ] = 1; &#125; else if ( cur === &apos;interrupt&apos; ) &#123; showError( &apos;interrupt&apos; ); &#125; else if ( cur === &apos;queued&apos; ) &#123; percentages[ file.id ][ 1 ] = 0; &#125; else if ( cur === &apos;progress&apos; ) &#123; $info.remove(); $prgress.css(&apos;display&apos;, &apos;block&apos;); &#125; else if ( cur === &apos;complete&apos; ) &#123; $li.append( &apos;&lt;span class=&quot;success&quot;&gt;&lt;/span&gt;&apos; ); &#125; $li.removeClass( &apos;state-&apos; + prev ).addClass( &apos;state-&apos; + cur ); &#125;); $li.on( &apos;mouseenter&apos;, function() &#123; $btns.stop().animate(&#123;height: 30&#125;); &#125;); $li.on( &apos;mouseleave&apos;, function() &#123; $btns.stop().animate(&#123;height: 0&#125;); &#125;); $btns.on( &apos;click&apos;, &apos;span&apos;, function() &#123; var tempIndex = $(this).index(), deg; switch ( tempIndex ) &#123; case 0: uploader[index].removeFile( file ); return; case 1: file.rotation += 90; break; case 2: file.rotation -= 90; break; &#125; if ( supportTransition ) &#123; deg = &apos;rotate(&apos; + file.rotation + &apos;deg)&apos;; $wrap.css(&#123; &apos;-webkit-transform&apos;: deg, &apos;-mos-transform&apos;: deg, &apos;-o-transform&apos;: deg, &apos;transform&apos;: deg &#125;); &#125; else &#123; $wrap.css( &apos;filter&apos;, &apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=&apos;+ (~~((file.rotation/90)%4 + 4)%4) +&apos;)&apos;); // use jquery animate to rotation // $(&#123; // rotation: rotation // &#125;).animate(&#123; // rotation: file.rotation // &#125;, &#123; // easing: &apos;linear&apos;, // step: function( now ) &#123; // now = now * Math.PI / 180; // var cos = Math.cos( now ), // sin = Math.sin( now ); // $wrap.css( &apos;filter&apos;, &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&quot; + cos + &quot;,M12=&quot; + (-sin) + &quot;,M21=&quot; + sin + &quot;,M22=&quot; + cos + &quot;,SizingMethod=&apos;auto expand&apos;)&quot;); // &#125; // &#125;); &#125; &#125;); $li.appendTo( $queue ); &#125; // 负责view的销毁 function removeFile( file ) &#123; var $li = $(&apos;#&apos;+file.id); delete percentages[ file.id ]; updateTotalProgress(); $li.off().find(&apos;.file-panel&apos;).off().end().remove(); &#125; function updateTotalProgress() &#123; var loaded = 0, total = 0, spans = $progress.children(), percent; $.each( percentages, function( k, v ) &#123; total += v[ 0 ]; loaded += v[ 0 ] * v[ 1 ]; &#125; ); percent = total ? loaded / total : 0; spans.eq( 0 ).text( Math.round( percent * 100 ) + &apos;%&apos; ); spans.eq( 1 ).css( &apos;width&apos;, Math.round( percent * 100 ) + &apos;%&apos; ); updateStatus(); &#125; function updateStatus() &#123; var text = &apos;&apos;, stats; if ( state === &apos;ready&apos; ) &#123; text = &apos;选中&apos; + fileCount + &apos;张图片，共&apos; + WebUploader.formatSize( fileSize ) + &apos;。&apos;; &#125; else if ( state === &apos;confirm&apos; ) &#123; stats = uploader[index].getStats(); if ( stats.uploadFailNum ) &#123; text = &apos;已成功上传&apos; + stats.successNum+ &apos;张照片至XX相册，&apos;+ stats.uploadFailNum + &apos;张照片上传失败，&lt;a class=&quot;retry&quot; href=&quot;#&quot;&gt;重新上传&lt;/a&gt;失败图片或&lt;a class=&quot;ignore&quot; href=&quot;#&quot;&gt;忽略&lt;/a&gt;&apos;; &#125; &#125; else &#123; stats = uploader[index].getStats(); text = &apos;共&apos; + fileCount + &apos;张（&apos; + WebUploader.formatSize( fileSize ) + &apos;），已上传&apos; + stats.successNum + &apos;张&apos;; if ( stats.uploadFailNum ) &#123; text += &apos;，失败&apos; + stats.uploadFailNum + &apos;张&apos;; &#125; &#125; $info.html( text ); &#125; function setState( val ) &#123; var file, stats; if ( val === state ) &#123; return; &#125; $upload.removeClass( &apos;state-&apos; + state ); $upload.addClass( &apos;state-&apos; + val ); state = val; switch ( state ) &#123; case &apos;pedding&apos;: $placeHolder.removeClass( &apos;element-invisible&apos; ); $queue.hide(); $statusBar.addClass( &apos;element-invisible&apos; ); uploader[index].refresh(); break; case &apos;ready&apos;: $placeHolder.addClass( &apos;element-invisible&apos; ); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos;); $queue.show(); $statusBar.removeClass(&apos;element-invisible&apos;); uploader[index].refresh(); break; case &apos;uploading&apos;: $( &apos;#filePicker2&apos; ).addClass( &apos;element-invisible&apos; ); $progress.show(); $upload.text( &apos;暂停上传&apos; ); break; case &apos;paused&apos;: $progress.show(); $upload.text( &apos;继续上传&apos; ); break; case &apos;confirm&apos;: $progress.hide(); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos; ); $upload.text( &apos;开始上传&apos; ); stats = uploader[index].getStats(); if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( &apos;finish&apos; ); return; &#125; break; case &apos;finish&apos;: stats = uploader[index].getStats(); if ( stats.successNum ) &#123; //alert( &apos;上传成功&apos; ); &#125; else &#123; // 没有成功的图片，重设 state = &apos;done&apos;; location.reload(); &#125; break; &#125; updateStatus(); &#125; uploader[index].onUploadProgress = function( file, percentage ) &#123; var $li = $(&apos;#&apos;+file.id), $percent = $li.find(&apos;.progress span&apos;); $percent.css( &apos;width&apos;, percentage * 100 + &apos;%&apos; ); percentages[ file.id ][ 1 ] = percentage; updateTotalProgress(); &#125;; uploader[index].onFileQueued = function( file ) &#123; fileCount++; fileSize += file.size; if ( fileCount === 1 ) &#123; $placeHolder.addClass( &apos;element-invisible&apos; ); $statusBar.show(); &#125; addFile( file ); setState( &apos;ready&apos; ); updateTotalProgress(); &#125;; uploader[index].onFileDequeued = function( file ) &#123; fileCount--; fileSize -= file.size; debugger; if ( !fileCount ) &#123; setState( &apos;pedding&apos; ); &#125; removeFile(file); updateTotalProgress(); &#125;; uploader[index].on( &apos;all&apos;, function( type ) &#123; var stats; switch( type ) &#123; case &apos;uploadFinished&apos;: setState( &apos;confirm&apos; ); break; case &apos;startUpload&apos;: setState( &apos;uploading&apos; ); break; case &apos;stopUpload&apos;: setState( &apos;paused&apos; ); break; &#125; &#125;); uploader[index].onError = function( code ) &#123; if(code == &apos;F_DUPLICATE&apos;)&#123; alert( &apos;图片重复&apos; ); &#125;else&#123; alert( &apos;Eroor: &apos; + code ); &#125; &#125;; $upload.on(&apos;click&apos;, function() &#123; if ( $(this).hasClass( &apos;disabled&apos; ) ) &#123; return false; &#125; if ( state === &apos;ready&apos; ) &#123; uploader[index].upload(); &#125; else if ( state === &apos;paused&apos; ) &#123; uploader[index].upload(); &#125; else if ( state === &apos;uploading&apos; ) &#123; uploader[index].stop(); &#125; &#125;); $info.on( &apos;click&apos;, &apos;.retry&apos;, function() &#123; uploader[index].retry(); &#125; ); $info.on( &apos;click&apos;, &apos;.ignore&apos;, function() &#123; alert( &apos;todo&apos; ); &#125; ); $upload.addClass( &apos;state-&apos; + state ); updateTotalProgress(); &#125;); &#125;);&#125;)( jQuery ); 2.后台代码上传图片12345678910111213141516171819202122232425262728 /** * 上传图片 */ @RequestMapping(value=&quot;/uploadImg&quot;) @ResponseBody public Object save(@RequestParam(required=false) MultipartFile file,String goodsCode) throws Exception&#123; logBefore(logger, &quot;GoodsDetail上传图片&quot;); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();// String ffile = DateUtil.getDays(), fileName = &quot;&quot;; PageData pd = new PageData(); String imageUrls = &quot;&quot;; if(Jurisdiction.buttonJurisdiction(menuUrl, &quot;add&quot;))&#123; if (null != file &amp;&amp; !file.isEmpty()) &#123; //上传图片到FastDFS MultipartFile[] files = new MultipartFile[1]; files[0] = file; imageUrls = fastDFSService.upload(files);// String filePath = PathUtil.getClasspath() + Const.FILEPATHIMG + ffile; //文件上传路径// fileName = FileUpload.fileUp(file, filePath, this.get32UUID()); //执行上传 &#125;else&#123; System.out.println(&quot;上传失败&quot;); &#125; &#125; map.put(&quot;result&quot;, &quot;ok&quot;);// map.put(&quot;path&quot;, ffile + &quot;/&quot; + fileName); map.put(&quot;path&quot;, imageUrls); return AppUtil.returnObject(pd, map); &#125; 保存图片路径1234567891011121314151617181920212223242526272829303132333435363738394041/** * 保存商品基础信息 */ @RequestMapping(value=&quot;/save&quot;) public ModelAndView save() throws Exception&#123; ModelAndView mv = this.getModelAndView(); PageData pd = new PageData(); pd = this.getPageData(); DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //首先判断是否有主键goods_code String goodsCode = pd.getString(&quot;GOODS_CODE&quot;); if(goodsCode!=null &amp;&amp; !&quot;&quot;.equals(goodsCode))&#123;//如果不为空，走update语句 String filePath = pd.getString(&quot;FILE_PATH&quot;)==null?&quot;&quot;:pd.getString(&quot;FILE_PATH&quot;).toString();//图片路径 String[] filePathArg = filePath.split(&quot;;&quot;); String imageUrl1 = filePathArg!=null&amp;&amp;filePathArg.length&gt;1?filePathArg[1]:&quot;&quot;; String imageUrl2 = filePathArg!=null&amp;&amp;filePathArg.length&gt;2?filePathArg[2]:&quot;&quot;; String imageUrl3 = filePathArg!=null&amp;&amp;filePathArg.length&gt;3?filePathArg[3]:&quot;&quot;; String imageUrl4 = filePathArg!=null&amp;&amp;filePathArg.length&gt;4?filePathArg[4]:&quot;&quot;; String imageUrl5 = filePathArg!=null&amp;&amp;filePathArg.length&gt;5?filePathArg[5]:&quot;&quot;; String updatedTime = df.format(new Date()); pd.put(&quot;imageUrl1&quot;, imageUrl1); pd.put(&quot;imageUrl2&quot;, imageUrl2); pd.put(&quot;imageUrl3&quot;, imageUrl3); pd.put(&quot;imageUrl4&quot;, imageUrl4); pd.put(&quot;imageUrl5&quot;, imageUrl5); pd.put(&quot;updatedTime&quot;, updatedTime); String detailImageUrl = pd.getString(&quot;detail_image_url&quot;)==null?&quot;&quot;:pd.getString(&quot;detail_image_url&quot;).toString();//商品详情 String[] detailImageUrlArg = detailImageUrl.split(&quot;;&quot;); String detailImage = detailImageUrlArg!=null&amp;&amp;detailImageUrlArg.length&gt;1?detailImageUrlArg[1]:&quot;&quot;; pd.put(&quot;detail_image_url&quot;, detailImage); &#125;else&#123;//如果为空，那就是新增数据 &#125; if(Jurisdiction.buttonJurisdiction(menuUrl, &quot;edit&quot;))&#123;goodsDetailService.save(pd);&#125; mv.addObject(&quot;msg&quot;,&quot;success&quot;); mv.setViewName(&quot;save_result&quot;); return mv; &#125;]]></content>
      <categories>
        <category>前端插件</category>
        <category>Webuploader</category>
      </categories>
      <tags>
        <tag>Webuploader</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webuploader多图上传及回显]]></title>
    <url>%2F2019%2F01%2F25%2FWebuploader%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[goods_detail_uploader.js 这个是图片上传的js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612(function($)&#123; // 当domReady的时候开始初始化 $(function() &#123; var $wrap = $(&apos;#uploader&apos;), // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ).appendTo( $wrap.find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $wrap.find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $wrap.find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $wrap.find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;, // 判断浏览器是否支持图片的base64 isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125;; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(), // WebUploader实例 uploader; if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;); break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;); break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; var locat = (window.location+&apos;&apos;).split(&apos;/&apos;); if(&apos;pictures&apos;== locat[3])&#123;locat = locat[0]+&apos;//&apos;+locat[2];&#125;else&#123;locat = locat[0]+&apos;//&apos;+locat[2]+&apos;/&apos;+locat[3];&#125;; uploader = WebUploader.create(&#123; pick: &#123; id: &apos;#filePicker&apos;, label: &apos;点击选择图片&apos; &#125;, formData: &#123; uid: 123 &#125;, dnd: &apos;#dndArea&apos;, paste: &apos;#uploader&apos;, swf: &apos;./Uploader.swf&apos;, chunked: false, chunkSize: 512 * 1024, //server: &apos;http://127.0.0.1:8080/pictures/save.do&apos;, server: &apos;goodsDetail/uploadImg.do?&apos;, //runtimeOrder: &apos;flash&apos;, accept: &#123; title: &apos;Images&apos;, extensions: &apos;gif,jpg,jpeg,bmp,png&apos;, mimeTypes: &apos;image/*&apos; &#125;, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 disableGlobalDnd: true, fileNumLimit: 5, fileSizeLimit: 200 * 1024 * 1024, // 200 M fileSingleSizeLimit: 50 * 1024 * 1024 // 50 M &#125;); // 拖拽时不接受 js, txt 文件。 uploader.on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); // uploader.on(&apos;filesQueued&apos;, function() &#123; // uploader.sort(function( a, b ) &#123; // if ( a.name &lt; b.name ) // return -1; // if ( a.name &gt; b.name ) // return 1; // return 0; // &#125;); // &#125;); // 添加“添加文件”的按钮， uploader.addButton(&#123; id: &apos;#filePicker2&apos;, label: &apos;继续添加&apos; &#125;); var getFileBlob = function(url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.addEventListener(&apos;load&apos;, function() &#123; cb(xhr.response); &#125;); xhr.send(); &#125;; var blobToFile = function(blob, name) &#123; blob.lastModifiedDate = new Date(); blob.name = name; return blob; &#125;; var getFileObject = function(filePathOrUrl, cb) &#123; getFileBlob(filePathOrUrl, function(blob) &#123; cb(blobToFile(blob, &apos;test.jpg&apos;)); &#125;); &#125;; //回显图片 uploader.on(&apos;ready&apos;, function() &#123; debugger; window.uploader = uploader; var filePathArg = $(&quot;#FILE_PATH&quot;)[0].value.split(&apos;;&apos;); var files=new Array(); var i=0; if(filePathArg.length&gt;0)&#123; $.each(filePathArg, function(index,item) &#123; //如果图片是空值，就直接返回 if(item==&apos;&apos;||item==&quot;undefined&quot;||item==undefined)&#123; return true; &#125; getFileObject(item, function(fileObject) &#123; var wuFile = new WebUploader.Lib.File(WebUploader.guid(&apos;rt_&apos;), fileObject); var tempfile = new WebUploader.File(wuFile); tempfile.url=item; tempfile.setStatus(&apos;complete&apos;); uploader.addFiles(tempfile); &#125;); &#125;); &#125;; &#125;); uploader.on( &apos;uploadSuccess&apos;, function( file,response ) &#123; file.url=response.path; $(&quot;#FILE_PATH&quot;)[0].value = $(&quot;#FILE_PATH&quot;)[0].value+&quot;;&quot;+response.path; &#125;); // 当有文件添加进来时执行，负责view的创建 function addFile( file ) &#123; var $li = $( &apos;&lt;li id=&quot;&apos; + file.id + &apos;&quot;&gt;&apos; + &apos;&lt;p class=&quot;title&quot;&gt;&apos; + file.name + &apos;&lt;/p&gt;&apos; + &apos;&lt;p class=&quot;imgWrap&quot;&gt;&lt;/p&gt;&apos;+ &apos;&lt;p class=&quot;progress&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;/li&gt;&apos; ), $btns = $(&apos;&lt;div class=&quot;file-panel&quot;&gt;&apos; + &apos;&lt;span class=&quot;cancel&quot;&gt;删除&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateRight&quot;&gt;向右旋转&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateLeft&quot;&gt;向左旋转&lt;/span&gt;&lt;/div&gt;&apos;).appendTo( $li ), $prgress = $li.find(&apos;p.progress span&apos;), $wrap = $li.find( &apos;p.imgWrap&apos; ), $info = $(&apos;&lt;p class=&quot;error&quot;&gt;&lt;/p&gt;&apos;), showError = function( code ) &#123; switch( code ) &#123; case &apos;exceed_size&apos;: text = &apos;文件大小超出&apos;; break; case &apos;interrupt&apos;: text = &apos;上传暂停&apos;; break; default: text = &apos;上传失败，请重试&apos;; break; &#125; $info.text( text ).appendTo( $li ); &#125;; if ( file.getStatus() === &apos;invalid&apos; ) &#123; showError( file.statusText ); &#125; else &#123; // @todo lazyload $wrap.text( &apos;预览中&apos; ); uploader.makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( &apos;不能预览&apos; ); return; &#125; if( isSupportBase64 ) &#123; img = $(&apos;&lt;img src=&quot;&apos;+src+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $.ajax(&apos;../../server/preview.php&apos;, &#123; method: &apos;POST&apos;, data: src, dataType:&apos;json&apos; &#125;).done(function( response ) &#123; if (response.result) &#123; img = $(&apos;&lt;img src=&quot;&apos;+response.result+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $wrap.text(&quot;预览出错&quot;); &#125; &#125;); &#125; &#125;, thumbnailWidth, thumbnailHeight ); percentages[ file.id ] = [ file.size, 0 ]; file.rotation = 0; &#125; file.on(&apos;statuschange&apos;, function( cur, prev ) &#123; if ( prev === &apos;progress&apos; ) &#123; $prgress.hide().width(0); &#125; else if ( prev === &apos;queued&apos; ) &#123; $li.off( &apos;mouseenter mouseleave&apos; ); $btns.remove(); &#125; // 成功 if ( cur === &apos;error&apos; || cur === &apos;invalid&apos; ) &#123; console.log( file.statusText ); showError( file.statusText ); percentages[ file.id ][ 1 ] = 1; &#125; else if ( cur === &apos;interrupt&apos; ) &#123; showError( &apos;interrupt&apos; ); &#125; else if ( cur === &apos;queued&apos; ) &#123; percentages[ file.id ][ 1 ] = 0; &#125; else if ( cur === &apos;progress&apos; ) &#123; $info.remove(); $prgress.css(&apos;display&apos;, &apos;block&apos;); &#125; else if ( cur === &apos;complete&apos; ) &#123; $li.append( &apos;&lt;span class=&quot;success&quot;&gt;&lt;/span&gt;&apos; ); &#125; $li.removeClass( &apos;state-&apos; + prev ).addClass( &apos;state-&apos; + cur ); &#125;); $li.on( &apos;mouseenter&apos;, function() &#123; $btns.stop().animate(&#123;height: 30&#125;); &#125;); $li.on( &apos;mouseleave&apos;, function() &#123; $btns.stop().animate(&#123;height: 0&#125;); &#125;); $btns.on( &apos;click&apos;, &apos;span&apos;, function() &#123; var index = $(this).index(), deg; switch ( index ) &#123; case 0: uploader.removeFile( file ); return; case 1: file.rotation += 90; break; case 2: file.rotation -= 90; break; &#125; if ( supportTransition ) &#123; deg = &apos;rotate(&apos; + file.rotation + &apos;deg)&apos;; $wrap.css(&#123; &apos;-webkit-transform&apos;: deg, &apos;-mos-transform&apos;: deg, &apos;-o-transform&apos;: deg, &apos;transform&apos;: deg &#125;); &#125; else &#123; $wrap.css( &apos;filter&apos;, &apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=&apos;+ (~~((file.rotation/90)%4 + 4)%4) +&apos;)&apos;); // use jquery animate to rotation // $(&#123; // rotation: rotation // &#125;).animate(&#123; // rotation: file.rotation // &#125;, &#123; // easing: &apos;linear&apos;, // step: function( now ) &#123; // now = now * Math.PI / 180; // var cos = Math.cos( now ), // sin = Math.sin( now ); // $wrap.css( &apos;filter&apos;, &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&quot; + cos + &quot;,M12=&quot; + (-sin) + &quot;,M21=&quot; + sin + &quot;,M22=&quot; + cos + &quot;,SizingMethod=&apos;auto expand&apos;)&quot;); // &#125; // &#125;); &#125; &#125;); $li.appendTo( $queue ); &#125; // 负责view的销毁 function removeFile( file ) &#123; var $li = $(&apos;#&apos;+file.id); delete percentages[ file.id ]; updateTotalProgress(); $li.off().find(&apos;.file-panel&apos;).off().end().remove(); &#125; function updateTotalProgress() &#123; var loaded = 0, total = 0, spans = $progress.children(), percent; $.each( percentages, function( k, v ) &#123; total += v[ 0 ]; loaded += v[ 0 ] * v[ 1 ]; &#125; ); percent = total ? loaded / total : 0; spans.eq( 0 ).text( Math.round( percent * 100 ) + &apos;%&apos; ); spans.eq( 1 ).css( &apos;width&apos;, Math.round( percent * 100 ) + &apos;%&apos; ); updateStatus(); &#125; function updateStatus() &#123; var text = &apos;&apos;, stats; if ( state === &apos;ready&apos; ) &#123; text = &apos;选中&apos; + fileCount + &apos;张图片，共&apos; + WebUploader.formatSize( fileSize ) + &apos;。&apos;; &#125; else if ( state === &apos;confirm&apos; ) &#123; stats = uploader.getStats(); if ( stats.uploadFailNum ) &#123; text = &apos;已成功上传&apos; + stats.successNum+ &apos;张照片至XX相册，&apos;+ stats.uploadFailNum + &apos;张照片上传失败，&lt;a class=&quot;retry&quot; href=&quot;#&quot;&gt;重新上传&lt;/a&gt;失败图片或&lt;a class=&quot;ignore&quot; href=&quot;#&quot;&gt;忽略&lt;/a&gt;&apos;; &#125; &#125; else &#123; stats = uploader.getStats(); text = &apos;共&apos; + fileCount + &apos;张（&apos; + WebUploader.formatSize( fileSize ) + &apos;），已上传&apos; + stats.successNum + &apos;张&apos;; if ( stats.uploadFailNum ) &#123; text += &apos;，失败&apos; + stats.uploadFailNum + &apos;张&apos;; &#125; &#125; $info.html( text ); &#125; function setState( val ) &#123; var file, stats; if ( val === state ) &#123; return; &#125; $upload.removeClass( &apos;state-&apos; + state ); $upload.addClass( &apos;state-&apos; + val ); state = val; switch ( state ) &#123; case &apos;pedding&apos;: $placeHolder.removeClass( &apos;element-invisible&apos; ); $queue.hide(); $statusBar.addClass( &apos;element-invisible&apos; ); uploader.refresh(); break; case &apos;ready&apos;: $placeHolder.addClass( &apos;element-invisible&apos; ); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos;); $queue.show(); $statusBar.removeClass(&apos;element-invisible&apos;); uploader.refresh(); break; case &apos;uploading&apos;: $( &apos;#filePicker2&apos; ).addClass( &apos;element-invisible&apos; ); $progress.show(); $upload.text( &apos;暂停上传&apos; ); break; case &apos;paused&apos;: $progress.show(); $upload.text( &apos;继续上传&apos; ); break; case &apos;confirm&apos;: $progress.hide(); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos; ); $upload.text( &apos;开始上传&apos; ); stats = uploader.getStats(); if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( &apos;finish&apos; ); return; &#125; break; case &apos;finish&apos;: stats = uploader.getStats(); if ( stats.successNum ) &#123; //alert( &apos;上传成功&apos; ); &#125; else &#123; // 没有成功的图片，重设 state = &apos;done&apos;; location.reload(); &#125; break; &#125; updateStatus(); &#125; uploader.onUploadProgress = function( file, percentage ) &#123; var $li = $(&apos;#&apos;+file.id), $percent = $li.find(&apos;.progress span&apos;); $percent.css( &apos;width&apos;, percentage * 100 + &apos;%&apos; ); percentages[ file.id ][ 1 ] = percentage; updateTotalProgress(); &#125;; uploader.onFileQueued = function( file ) &#123; fileCount++; fileSize += file.size; if ( fileCount === 1 ) &#123; $placeHolder.addClass( &apos;element-invisible&apos; ); $statusBar.show(); &#125; addFile( file ); setState( &apos;ready&apos; ); updateTotalProgress(); &#125;; uploader.onFileDequeued = function( file ) &#123; fileCount--; fileSize -= file.size; if ( !fileCount ) &#123; setState( &apos;pedding&apos; ); &#125; removeFile(file); updateTotalProgress(); &#125;; uploader.on( &apos;all&apos;, function( type ) &#123; var stats; switch( type ) &#123; case &apos;uploadFinished&apos;: setState( &apos;confirm&apos; ); break; case &apos;startUpload&apos;: setState( &apos;uploading&apos; ); break; case &apos;stopUpload&apos;: setState( &apos;paused&apos; ); break; &#125; &#125;); uploader.onError = function( code ) &#123; if(code == &apos;F_DUPLICATE&apos;)&#123; alert( &apos;图片重复&apos; ); &#125;else&#123; alert( &apos;Eroor: &apos; + code ); &#125; &#125;; $upload.on(&apos;click&apos;, function() &#123; if ( $(this).hasClass( &apos;disabled&apos; ) ) &#123; return false; &#125; if ( state === &apos;ready&apos; ) &#123; uploader.upload(); &#125; else if ( state === &apos;paused&apos; ) &#123; uploader.upload(); &#125; else if ( state === &apos;uploading&apos; ) &#123; uploader.stop(); &#125; &#125;); $info.on( &apos;click&apos;, &apos;.retry&apos;, function() &#123; uploader.retry(); &#125; ); $info.on( &apos;click&apos;, &apos;.ignore&apos;, function() &#123; alert( &apos;todo&apos; ); &#125; ); $upload.addClass( &apos;state-&apos; + state ); updateTotalProgress(); &#125;);&#125;)( jQuery ); 图片上传页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name="description" content="overview &amp; stats" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;link href="static/css/bootstrap.min.css" rel="stylesheet" /&gt;&lt;link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" /&gt;&lt;link rel="stylesheet" href="static/css/font-awesome.min.css" /&gt;&lt;!-- 下拉框 --&gt;&lt;link rel="stylesheet" href="static/css/chosen.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace.min.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace-responsive.min.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace-skins.min.css" /&gt;&lt;script type="text/javascript" src="static/js/jquery-1.7.2.js"&gt;&lt;/script&gt;&lt;!-- 上传图片 --&gt;&lt;link rel="stylesheet" type="text/css" href="plugins/webuploader/webuploader.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="plugins/webuploader/style.css" /&gt;&lt;style type="text/css"&gt;#wrapper &#123; margin: 0;&#125;#uploader .placeholder &#123; background: url(plugins/webuploader/image.png) center 23px no-repeat; padding-top: 88px; min-height: 110px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="goodsDetail/$&#123;msg &#125;.do" name="goodsForm" id="goodsForm" method="post"&gt; &lt;div id="zhongxin"&gt; &lt;table id="table_report" class="table table-striped table-bordered table-hover"&gt; &lt;tr&gt; &lt;th style="vertical-align: middle"&gt;轮播图:&lt;/th&gt; &lt;td colspan="3"&gt;&lt;input type="hidden" name="FILE_PATH" id="FILE_PATH" value="$&#123;pd.FILE_PATH&#125;" /&gt; &lt;div id="wrapper"&gt; &lt;div id="container"&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id="uploader"&gt; &lt;div class="queueList"&gt; &lt;div id="dndArea" class="placeholder"&gt; &lt;div id="filePicker"&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选1张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="statusBar" style="display:none;"&gt; &lt;div class="progress"&gt; &lt;span class="text"&gt;0%&lt;/span&gt; &lt;span class="percentage"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="info"&gt;&lt;/div&gt; &lt;div class="btns"&gt; &lt;div id="filePicker2"&gt;&lt;/div&gt; &lt;div class="uploadBtn"&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="text-align: center;" colspan="4"&gt; &lt;a class="btn btn-mini btn-primary" onclick="save();"&gt;保存&lt;/a&gt; &lt;a class="btn btn-mini btn-danger" onclick="top.Dialog.close();"&gt;取消&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id="zhongxin2" class="center" style="display:none"&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;img src="static/images/jiazai.gif" /&gt;&lt;br /&gt; &lt;h4 class="lighter block green"&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 引入 --&gt; &lt;script type="text/javascript"&gt;window.jQuery || document.write("&lt;script src='static/js/jquery-1.9.1.min.js'&gt;\x3C/script&gt;");&lt;/script&gt; &lt;script src="static/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script src="static/js/ace-elements.min.js"&gt;&lt;/script&gt; &lt;script src="static/js/ace.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="static/js/chosen.jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 下拉框 --&gt; &lt;script type="text/javascript" src="plugins/webuploader/webuploader.js"&gt;&lt;/script&gt; &lt;script src="static/js/goods/goods_detail_edit.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var tempqueue; $(function() &#123; //单选框 $(".chzn-select").chosen(); $(".chzn-select-deselect").chosen(&#123;allow_single_deselect:true&#125;); &#125;); //保存 function save()&#123; //获取所有在图片列表中的URL传给后台 var files = uploader.getFiles(); var filePath = ""; files.forEach(function(e)&#123; if(e.getStatus()=="complete")&#123; filePath = filePath+";"+e.url; &#125; &#125;); $("#FILE_PATH")[0].value = filePath; $("#goodsForm").submit(); $("#zhongxin").hide(); $("#zhongxin2").show(); &#125; //校验编码是否存在 function checkHasCode()&#123; var goodsCode = $("#GOODS_CODE")[0].value; var checkGoodsCode = $("#checkGoodsCode")[0].value; if(goodsCode == checkGoodsCode)return; $.ajax(&#123; type: "GET", url: '&lt;%=basePath%&gt;goodsDetail/hasCode.do?tm='+new Date().getTime() + '&amp;GOODS_CODE=' + goodsCode, data : '', dataType : 'json', cache : false, success : function(data) &#123; if (data.result == "error") &#123; alert("编码重复，请重新输入"); $("#GOODS_CODE")[0].value = checkGoodsCode; &#125;; &#125; &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; java后台上传图片代码12345678910111213141516171819202122232425262728 /** * 上传图片 */ @RequestMapping(value="/uploadImg") @ResponseBody public Object save(@RequestParam(required=false) MultipartFile file,String goodsCode) throws Exception&#123; logBefore(logger, "GoodsDetail上传图片"); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();// String ffile = DateUtil.getDays(), fileName = ""; PageData pd = new PageData(); String imageUrls = ""; if(Jurisdiction.buttonJurisdiction(menuUrl, "add"))&#123; if (null != file &amp;&amp; !file.isEmpty()) &#123; //上传图片到FastDFS MultipartFile[] files = new MultipartFile[1]; files[0] = file; imageUrls = fastDFSService.upload(files);// String filePath = PathUtil.getClasspath() + Const.FILEPATHIMG + ffile; //文件上传路径// fileName = FileUpload.fileUp(file, filePath, this.get32UUID()); //执行上传 &#125;else&#123; System.out.println("上传失败"); &#125; &#125; map.put("result", "ok");// map.put("path", ffile + "/" + fileName); map.put("path", imageUrls); return AppUtil.returnObject(pd, map); &#125;]]></content>
      <categories>
        <category>前端插件</category>
        <category>Webuploader</category>
      </categories>
      <tags>
        <tag>Webuploader</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中显示MarkDown，并且进行代码高亮]]></title>
    <url>%2F2019%2F01%2F25%2FHTML%E4%B8%AD%E6%98%BE%E7%A4%BAMarkDown%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[简述 临时个人兴趣，做一个类似API的东西，要显示具体对应的代码，因此用到了页面中显示代码插件（showdown）和高亮代码插件（highligt），两个插件的官网分别是：showdown、highlight 使用方法showdown 首先在官网下载showdown 下载完成后，引入项目，解压找到showdown.min.js文件 js代码1234567891011$('li a').click(function()&#123; $.get(this.href,function(data)&#123; var converter = new showdown.Converter();//1.首先定义converter data = "``` \n"+data+" \n ```";//转换成markdown格式的代码 var html = converter.makeHtml(data);//2. 使用convert转换成html代码 document.getElementById("code").innerHTML = html;//3. 将转换好的markdown放入对应的div $('pre code').each(function(i, block) &#123; hljs.highlightBlock(block); &#125;); &#125;)&#125;) highlight 首先官网下载highlight 下载完成后，引入项目 需要注意点： highlight提供好几种样式，可以在style文件夹下面自行查找 js代码123456789101112//展示和高亮代码 $(&apos;li a&apos;).click(function()&#123; $.get(this.href,function(data)&#123; var converter = new showdown.Converter(); data = &quot;``` \n&quot;+data+&quot; \n ```&quot;; var html = converter.makeHtml(data); document.getElementById(&quot;code&quot;).innerHTML = html; $(&apos;pre code&apos;).each(function(i, block) &#123;//这一行一定要有，否则高亮代码不生效 hljs.highlightBlock(block);//使代码高亮 &#125;); &#125;) &#125;) 这个页面有一个很巧妙的地方，是通过get请求获取到未经js和css渲染的纯html页面代码，方法的代码如下：123$.get(url,function(data)&#123; console.log(data);//这里面的data就是未经渲染的html代码内容&#125;)]]></content>
      <categories>
        <category>前端插件</category>
        <category>showdown&amp;highlight</category>
      </categories>
      <tags>
        <tag>前端插件</tag>
        <tag>showdown</tag>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageView图片预览的使用方法及代码]]></title>
    <url>%2F2019%2F01%2F25%2FImageView%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在做一个项目上图片预览的功能，常规情况下都是简单的一个类型下的图片，但目前的需求是左侧展示一个用户下的图片类型，右边显示这个用户下这个类型的图片的列表，点击列表上的图片还能看大图进行预览操作 下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;预览影像资料&lt;/title&gt; &lt;link rel="stylesheet" href="../../../main/scripts/bootstrap-3.3.7/css/bootstrap.css"/&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/main.css"&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/mine.css"&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/viewer.css"&gt; &lt;!-- Scripts --&gt; &lt;script src="../../../main/scripts/imagesview/js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script src="../../../main/scripts/imagesview/js/viewer.js"&gt;&lt;/script&gt; &lt;style&gt; .menu &#123; position: absolute; left: 0; top: 0; bottom: 0; width: 200px; padding-top: 100px; font-family: Consolas, arial, "宋体"; background-color: #ccc; &#125; .menu a &#123; display: block; height: 40px; margin: 0 0 1px 2px; padding-left: 10px; line-height: 40px; font-size: 14px; color: #333; text-decoration: none; &#125; .menu a.cur &#123; background-color: #eee; &#125; .menu a:hover &#123; background-color: #eee; &#125; /* .menu .cur &#123; color: #000; background-color: #fff !important;&#125; */ #jq22 &#123; width: 700px; margin: 0 auto; font-size: 0; &#125; #jq22 li &#123; display: inline-block; width: 32%; height: 150px; margin-left: 1%; padding-top: 1%; &#125; #jq22 li img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;!-- 左边内容 --&gt; &lt;div class="menu"&gt; &lt;a id="all-items" class="cur menu-item" href="javascript:;" onclick="initImages('')"&gt;&amp;nbsp&amp;nbsp全部影像&lt;/a&gt; &lt;a class="menu-item" href="#"&gt;&lt;/a&gt; &lt;/div&gt; &lt;!-- 右边内容 --&gt; &lt;div class="right" id="right"&gt; &lt;!--&lt;h1 style="text-align: center"&gt; &lt;p id="hname"&gt;全部影像&lt;/p&gt; &lt;/h1&gt;--&gt; &lt;ul class="docs-pictures clearfix" id="jq22"&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var viewer; var applyId = mini.getParams().applyId;//申请ID $(function () &#123; //初始化左侧的资料类型 initImageType(); initImages('');//初始化的时候加载所有的图片 //初始化viewer viewer = new Viewer(document.getElementById('jq22'), &#123; show: function () &#123; viewer.update(); &#125; &#125;); &#125;) //加载左侧的资料类型 function initImageType()&#123; $.ajax(&#123; url:eg.getRequestUrl()+'/imgManage/getImageType', type:'GET', data:&#123;applyId:applyId&#125;, async:true, dataType:'json', success:function(data)&#123; if(data.code == 0)&#123;//如果查询成功，加载遍历左侧的数据 for(var dataIndex=0;dataIndex &lt; data.datalist.length;dataIndex++)&#123; (function(dataIndex)&#123; var a=document.createElement('a'); var innerText = data.datalist[dataIndex].DOC_NAME a.innerHTML=innerText; a.addEventListener('click',function(e)&#123; e.preventDefault(); //取消默认事件，指a标签 initImages(data.datalist[dataIndex].DOC_CODE); &#125;); $("#all-items").append(a); &#125;)(dataIndex); &#125; &#125;else&#123; mini.alert(data.msg); &#125; &#125; &#125;) &#125; //加载右侧的图片信息 function initImages(docCode)&#123; $.ajax(&#123; url:eg.getRequestUrl()+'/imgManage/getImagesByApplyIdAndDocCode', type:'GET', data:&#123;applyId:applyId,docCode:docCode&#125;, dataType:'json', success:function(data)&#123; if(data.code == 0)&#123;//遍历显示图片 var imageList = data.datalist; $(this).addClass('cur').siblings('a').removeClass('cur'); //$.trim($("#hname").text($(this).text())); var li = ''; for (var i = 0, l = imageList.length; i &lt; l; i++)&#123; li += "&lt;li class='catImg'&gt;&lt;img data-original='"+eg.getRequestUrl()+imageList[i].FILE_PATH+imageList[i].FILE_ID+imageList[i].FILE_TYPE+"' src='"+eg.getRequestUrl()+imageList[i].FILE_PATH+imageList[i].FILE_ID+imageList[i].FILE_TYPE+"'&gt;&lt;/li&gt;"; &#125; $("#jq22").html(li); viewer.update(); &#125;else&#123; mini.alert(data.msg,"温馨提示"); &#125; &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端插件</category>
        <category>imageview</category>
      </categories>
      <tags>
        <tag>imageview</tag>
        <tag>图片预览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不重复随机数的产生]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BA%A7%E7%94%9F%2F</url>
    <content type="text"><![CDATA[123456int a[100]=0;for(i=0;i=99;i++)&#123;while(a[m=rand()0])a[m]=i;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP GET POST请求]]></title>
    <url>%2F2019%2F01%2F25%2FHTTP-GET-POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.oemp.common; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; /** * @author Post Method */ public class HttpPostUrl &#123; /** * 向指定URL发送POST请求 * @param url * @param paramMap * @return 响应结果 */ public static String sendPost(String url, Map&lt;String, String&gt; paramMap) &#123; PrintWriter out = null; BufferedReader in = null; String result = ""; try &#123; URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty("accept", "*/*"); conn.setRequestProperty("connection", "Keep-Alive"); conn.setRequestProperty("user-agent","Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)"); // conn.setRequestProperty("Charset", "UTF-8"); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 设置请求属性 String param = ""; if (paramMap != null &amp;&amp; paramMap.size() &gt; 0) &#123; Iterator&lt;String&gt; ite = paramMap.keySet().iterator(); while (ite.hasNext()) &#123; String key = ite.next();// key String value = paramMap.get(key); param += key + "=" + value + "&amp;"; &#125; param = param.substring(0, param.length() - 1); &#125; // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123; System.err.println("发送 POST 请求出现异常！" + e); e.printStackTrace(); &#125; // 使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125; /** * 数据流post请求 * @param urlStr * @param xmlInfo */ public static String doPost(String urlStr, String strInfo) &#123; String reStr=""; try &#123; URL url = new URL(urlStr); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setRequestProperty("Pragma:", "no-cache"); con.setRequestProperty("Cache-Control", "no-cache"); con.setRequestProperty("Content-Type", "text/xml"); OutputStreamWriter out = new OutputStreamWriter(con.getOutputStream()); out.write(new String(strInfo.getBytes("utf-8"))); out.flush(); out.close(); BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), "utf-8")); String line = ""; for (line = br.readLine(); line != null; line = br.readLine()) &#123; reStr += line; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return reStr; &#125; /** * 测试主方法 * @param args */ public static void main(String[] args) &#123; Map&lt;String, String&gt; mapParam = new HashMap&lt;String, String&gt;(); mapParam.put("name", "张三"); mapParam.put("validation","test"); String pathUrl = "http://localhost/testPost.action"; String result = sendPost(pathUrl, mapParam); System.out.println(result); &#125; &#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>公共类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP请求</tag>
        <tag>GET</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json树组装TreeBuilder(适用在bootstrap_treeview)]]></title>
    <url>%2F2019%2F01%2F25%2FJson%E6%A0%91%E7%BB%84%E8%A3%85TreeBuilder-%E8%AF%95%E7%94%A8%E5%9C%A8bootstrap-treeview%2F</url>
    <content type="text"><![CDATA[数据的结构如下： 节点ID 父节点ID 显示的内容 其他内容 01 “” 01 “” 02 “” 02 “” 0101 01 0101 “” 0102 01 0102 “” 010101 0101 010101 “” 12345SELECT ID, ORG_NO, ORG_NAME, P_LEVEL, PARENT_ID FROM SYS_ORG START WITH PARENT_ID = '0'CONNECT BY PRIOR ID = PARENT_IDORDER SIBLINGS BY LEVEL_SORT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package com.ms.module.fw.biki;import java.util.*;import net.sf.json.JSONArray;public class TreeBuilder &#123; List&lt;TreeBuilder.Node&gt; nodes = new ArrayList&lt;TreeBuilder.Node&gt;(); public TreeBuilder(List&lt;Node&gt; nodes) &#123; super(); this.nodes = nodes; &#125; /** * 构建JSON树形结构 * @return */ public String buildJSONTree() &#123; List&lt;Node&gt; nodeTree = buildTree(); JSONArray jsonArray = JSONArray.fromObject(nodeTree); return jsonArray.toString(); &#125; /** * 构建树形结构 * @return */ public List&lt;Node&gt; buildTree() &#123; List&lt;Node&gt; treeNodes = new ArrayList&lt;Node&gt;(); List&lt;Node&gt; rootNodes = getRootNodes(); for (Node rootNode : rootNodes) &#123; buildChildNodes(rootNode); treeNodes.add(rootNode); &#125; return treeNodes; &#125; /** * 递归子节点 * @param node */ public void buildChildNodes(Node node) &#123; List&lt;Node&gt; children = getChildNodes(node); if (!children.isEmpty()) &#123; for (Node child : children) &#123; buildChildNodes(child); &#125; node.setMenus(children); &#125; &#125; /** * 获取父节点下所有的子节点 * @param nodes * @param pnode * @return */ public List&lt;Node&gt; getChildNodes(Node pnode) &#123; List&lt;Node&gt; childNodes = new ArrayList&lt;Node&gt;(); for (Node n : nodes) &#123; if (pnode.getId().equals(n.getPid())) &#123; childNodes.add(n); &#125; &#125; return childNodes; &#125; /** * 判断是否为根节点 * 遍历所有节点，如果能找到他们的节点ID = 当前节点的父节点ID，说明不是root节点 * @param nodes * @param inNode * @return */ public boolean rootNode(Node node) &#123; boolean isRootNode = true; for (Node n : nodes) &#123; if (node.getPid().equals(n.getId())) &#123; isRootNode = false; break; &#125; &#125; return isRootNode; &#125; /** * 获取集合中所有的根节点 * @param nodes * @return */ public List&lt;Node&gt; getRootNodes() &#123; List&lt;Node&gt; rootNodes = new ArrayList&lt;Node&gt;(); for (Node n : nodes) &#123; if (rootNode(n)) &#123; rootNodes.add(n); &#125; &#125; return rootNodes; &#125; public static class Node &#123; private String id; private String pid; private String text; private String url; private List&lt;Node&gt; menus; public Node() &#123; &#125; public Node(String id, String pid, String text, String url) &#123; super(); this.id = id; this.pid = pid; this.text = text; this.url = url; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getPid() &#123; return pid; &#125; public void setPid(String pid) &#123; this.pid = pid; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public List&lt;Node&gt; getMenus() &#123; return menus; &#125; public void setMenus(List&lt;Node&gt; menus) &#123; this.menus = menus; &#125; &#125; public static void main(String[] args) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); Node p1 = new Node("01", "", "01", ""); Node p6 = new Node("02", "", "02", ""); Node p7 = new Node("0201", "02", "0201", ""); Node p2 = new Node("0101", "01", "0101", ""); Node p3 = new Node("0102", "01", "0102", ""); Node p4 = new Node("010101", "0101", "010101", ""); Node p5 = new Node("010102", "0101", "010102", ""); nodes.add(p1); nodes.add(p2); nodes.add(p3); nodes.add(p4); nodes.add(p5); nodes.add(p6); nodes.add(p7); TreeBuilder treeBuilder = new TreeBuilder(nodes); System.out.println(treeBuilder.buildJSONTree()); &#125;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>公共类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TreeBuilder</tag>
        <tag>bootstrap_treeview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据request获取用户IP地址公共方法]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%A0%B9%E6%8D%AErequest%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7IP%E5%9C%B0%E5%9D%80%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获取用户真实IP地址，不使用request.getRemoteAddr();的原因是有可能用户使用了代理软件方式避免真实IP地址,可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值，究竟哪个才是真正的用户端的真实IP呢？答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。如：X-Forwarded-For：192.168.1.110, 192.168.1.120, 192.168.1.130,192.168.1.100用户真实IP为： 192.168.1.110 具体的代码如下：12345678910111213141516171819public static String getIpAddress(HttpServletRequest request) &#123; String ip = request.getHeader("x-forwarded-for"); if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("Proxy-Client-IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("WL-Proxy-Client-IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("HTTP_CLIENT_IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("HTTP_X_FORWARDED_FOR"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return ip;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>用户IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA小知识点]]></title>
    <url>%2F2019%2F01%2F24%2FJAVA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[创建List的技巧方法,简单高效、暴力1List&lt;String&gt; list = Arrays.asList("role1","role2","role3"); 数据类型…的使用（不确定参数数量的方法使用）当出现方法的参数不确定个数的时候（参数的类型一样）可以使用数据类型...目前测试了String、int是可以使用的12345678910@Testpublic void testString()&#123; testStrings(&quot;123123&quot;,&quot;123234234&quot;,&quot;asdasd&quot;);&#125;protected void testStrings(String... strargs)&#123; for(String tempStr:strargs)&#123; System.out.println(tempStr); &#125;&#125; 数字数据格式化有些需要格式化为001、002的需求1new DecimalFormat("000").format(123) Java后台获取项目路径(classpath和resourcepath)123456789101112131415public static String getClasspath()&#123; String path = (String.valueOf(Thread.currentThread().getContextClassLoader().getResource(""))+"../../").replaceAll("file:/", "").replaceAll("%20", " ").trim(); if(path.indexOf(":") != 1)&#123; path = File.separator + path; &#125; return path;&#125;public static String getClassResources()&#123; String path = (String.valueOf(Thread.currentThread().getContextClassLoader().getResource(""))).replaceAll("file:/", "").replaceAll("%20", " ").trim(); if(path.indexOf(":") != 1)&#123; path = File.separator + path; &#125; return path;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片验证码，解决了Session不同步的问题]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86Session%E4%B8%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package cn.gov.csrc.servlet; import java.awt.Color; import java.awt.Font; import java.awt.Graphics; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGImageEncoder; public class CodeServlet extends HttpServlet &#123; /** * 产生验证码图片 */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("image/jpeg"); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "No-cache"); response.setDateHeader("Expires", 0L); int width = 80; int height = 30; BufferedImage image = new BufferedImage(width, height, 1); Graphics g = image.getGraphics(); Random random = new Random(); g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font("Arial", 0, 25)); g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width + 100); int y = random.nextInt(height + 100); int xl = random.nextInt(10); int yl = random.nextInt(12); g.drawOval(x, y, x + xl, y + yl); &#125; String code = request.getParameter("code"); String sRand = code; for (int i = 0; i &lt; sRand.length(); i++) &#123; String rand = sRand.substring(i, i + 1); g.setColor(new Color(20 + random.nextInt(110), 20 + random .nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 14 * i + 5, 25); &#125; g.dispose(); javax.servlet.ServletOutputStream imageOut = response.getOutputStream(); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(imageOut); encoder.encode(image); &#125; private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; &#125; Web.xml文件： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.gov.csrc.servlet.CodeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/CodeServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; index.jsp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/"; %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;验证码测试&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;script language="javascript" type="text/javascript"&gt; var code ; //在全局 定义验证码 function createCode()&#123; code = ""; var codeLength = 5;//验证码的长度 //所有候选组成验证码的字符，可以用中文 var selectChar = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C', 'D','E','F','G','H','I','J','K','L','M','N','O','P', 'Q','R','S','T','U','V','W','X','Y','Z','a','b','c', 'd','e','f','g','h','i','j','k','l','m','n','o','p', 'q','r','s','t','u','v','w','x','y','z'); for(var i=0;i&lt;codeLength;i++)&#123; var charIndex = Math.floor(Math.random()*60); code +=selectChar[charIndex]; &#125; return code; &#125; function validate ()&#123; var inputCode = document.getElementById("vcode").value.toLowerCase(); if(inputCode.length &lt;=0)&#123; alert("请输入验证码！"); return false; &#125; else if(inputCode != code.toLowerCase())&#123; alert("验证码输入错误！"); show();//刷新验证码 return false; &#125;else&#123; alert("^-^ OK"); return true; &#125; &#125; function show()&#123; //显示验证码 document.getElementById("code").src="CodeServlet?code="+createCode(); &#125; window.onload = function() &#123; //document.onload=show(); show();//页面加载时加载验证码 //这时无论在ie还是在firefox中，js没有加载完，页面的东西是不会被执行的； &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form onsubmit="return validate();" action="" method="post"&gt; &lt;h3&gt;jsp+js+servlet实现验证码&lt;/h3&gt; &lt;br /&gt; 用户名：&lt;input type="text" name="" /&gt;&lt;br /&gt; 请输入验证码： &lt;input type="text" id="vcode" style="width: 60;" maxLength="5" /&gt; &lt;img src="" id="code" /&gt; &lt;a href="#" mce_href="#" onclick="javascript:show();return false;"&gt;看不清,换一张!&lt;/a&gt;&lt;br /&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>功能相关</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat错误信息界面版本信息泄露]]></title>
    <url>%2F2019%2F01%2F24%2FTomcat%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%95%8C%E9%9D%A2%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[问题描述Tomcat报错页面出现Tomcat版本信息的泄露，具体的效果图见下图 解决方案 进入tomcat/lib下，使用电脑自带的软件解压开文件夹下面的catalina.jar文件，然后找到路径\org\apache\catalina\util路径下的ServerInfo.properties 编辑ServerInfo.properties文件，修改最后三行代码，去掉对应的版本信息，修改后的效果如下图所示 改完后保存，替换到lib包下面的jar包，重启Tomcat，查看报错页面显示的错误信息]]></content>
      <categories>
        <category>安全测评</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx版本信息泄露漏洞解决]]></title>
    <url>%2F2019%2F01%2F24%2Fnginx%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题描述 nginx版本信息的泄露有可能会造成攻击者获取更多的信息 nginx在curl的时候是能看到nginx版本信息的，具体的界面显示如下图所示,可以看到其中有个Server:nginx/1.15.8： 解决方案 修改nginx主配置文件：nginx.conf,取消注释或添加配置语句 12345http &#123; # ...省略一些配置 server_tokens off; #默认是注释掉的 # ...省略一些配置&#125; 编辑php-fpm配置文件，如fastcgi.conf或fcgi.conf（这个配置文件名也可以自定义的，根据具体文件名修改） 12345# 找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;# 修改为fastcgi_param SERVER_SOFTWARE nginx; 重新加载nginx配置文件 12# /etc/init.d/nginx reload 或# service nginx reload 验证是否生效1234567# curl -v -X 192.168.31.7HTTP/1.1 200 OKServer: nginxDate: Tue, 13 Jul 2010 14:26:56 GMTContent-Type: text/html; charset=UTF-8Connection: keep-aliveVary: Accept-Encoding]]></content>
      <categories>
        <category>安全测评</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread 基础使用方法]]></title>
    <url>%2F2019%2F01%2F24%2FJava-Thread-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[线程运行状态的几个方法 start方法 用来启动一个线程，当调用start方法的时候，系统才会开启一个新的线程来执行用户定义的子任务，并为线程分配需要的资源 run方法 run()方法不需要用户调用，当通过start启动一个线程的时候，当线程或得了CPU执行时间，便会自动进入到run方法去执行具体的任务。*继承Thread类必须要重写run方法，在run中定义具体要执行的任务。 sleep方法 12sleep(long millis) //参数为毫秒sleep(long millis,int nanoseconds) // 第一个参数为毫秒，第二个参数为纳秒 sleep相当于让线程睡眠，交出CPU，去执行其他任务。 但是sleep方法不会释放锁，某个对象加锁，则即使调用sleep方法，其他线程也无法访问这个对象： 123456789101112131415161718192021222324252627282930313233public class Test &#123; private int i = 10; private Object object = new Object(); public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; synchronized (object) &#123; i++; System.out.println("i:"+i); try &#123; System.out.println("线程"+Thread.currentThread().getName()+"进入睡眠状态"); Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println("线程"+Thread.currentThread().getName()+"睡眠结束"); i++; System.out.println("i:"+i); &#125; &#125; &#125;&#125; 输出结果如下： 123456789i:11线程Thread-0进入睡眠状态线程Thread-0睡眠结束i:12i:13线程Thread-1进入睡眠状态Disconnected from the target VM, address: '127.0.0.1:13332', transport: 'socket'线程Thread-1睡眠结束i:14 *从上面的输出结果可以看出，当Thread0进入睡眠状态之后，Thread1并没有去执行具体的任务，只有当Thread0执行完成后，此时Thread0释放了对象锁，Thread1才开始执行 yield方法 调用yield方法会让当前线程交出CPU权限，让CPU去执行其他线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体交出的CPU时间，另外yield方法只能让拥有相同优先级的线程获取CPU执行时间的机会。 * 调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点和sleep方法不一样的 join方法 123join()join(long millis) //参数为毫秒join(long millis,int nanoseconds) //第一个参数为毫秒，第二个参数为纳秒 假如在main线程中，调用thread.join方法,则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread方法执行完毕，如果调用的是指定时间join方法，则等待一定的时间 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; System.out.println("进入线程"+Thread.currentThread().getName());//执行顺序① Test test = new Test(); MyThread thread1 = test.new MyThread(); thread1.start(); try &#123; System.out.println("线程"+Thread.currentThread().getName()+"等待");//执行顺序② thread1.join(); System.out.println("线程"+Thread.currentThread().getName()+"继续执行");//执行顺序⑤ &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println("进入线程"+Thread.currentThread().getName());//执行顺序③ try &#123; Thread.currentThread().sleep(5000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println("线程"+Thread.currentThread().getName()+"执行完毕");//执行顺序④ &#125; &#125;&#125; 输出结果如下： 12345①进入线程main②线程main等待③进入线程Thread-0④线程Thread-0执行完毕⑤线程main继续执行 可以看出，当调用thread1.join()方法后，main线程会进入等待，然后等待thread1执行完之后再继续执行。 interrupt方法 中断方法，单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就是说，它可以用来中断一个正处在阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("进入睡眠状态"); Thread.currentThread().sleep(10000); System.out.println("睡眠完毕"); &#125; catch (InterruptedException e) &#123; System.out.println("得到中断异常"); &#125; System.out.println("run方法执行完毕"); &#125; &#125;&#125; 输出结果如下： 123进入睡眠状态得到中断异常run方法执行完毕 从上面的结果输出可以看出： 当线程调用interrupt的时候，中断处于阻塞状态的线程。12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; &#125;&#125; 上面的程序会一直执行下去，执行到Int的最大值，说明了一点interrupt方法不能中断正在运行中的线程 但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志置为true，那么可以通过调用isInterrupted()判断中断标志是否被置为中断。1234567891011121314151617181920212223242526272829package com.xydtech.controller.prdman.prdconfig;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(!isInterrupted()&amp;&amp;i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; &#125;&#125; 上面这段代码中，设置thread为interrupt之后，内部while循环的时候查询到不满足条件了，自然退出了循环，但是一般不建议通过这种方式来中断线程，一般会在Thread中添加一个属性isStop来指标是否结束while循环，然后再在while循环中判断isStop的值123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); thread.setStop(true); &#125; catch (InterruptedException e) &#123; &#125; &#125; class MyThread extends Thread&#123; boolean isStop = false; @Override public void run() &#123; int i = 0; while(!isStop &amp;&amp; i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; public void setStop(boolean stop) &#123; isStop = stop; &#125; &#125; stop方法destroy方法这两个方法基本上被废弃了，基本上不会被使用到 线程相关属性的方法 getId() 得到线程的IDgetName()和setName() 用来得到或者设置线程的名称getPriority和setPriority 用来获取和设置线程的优先级setDaemon和isDaemon用来设置线程为守护线程和判断线程是否为守护线程。 *重点：守护线程和用户线程的却别是，守护线程依赖于创建它的线程，而用户线程不依赖于创建它的线程，当mian方法运行完毕后，守护线程会随之消亡。但是用户线程不会消失，直至其运行完毕。在JVM中，垃圾收集器线程就是守护线程。Thread类中有一个比较常用的静态类方法currentThread用来获取当前线程。 方法调用和Thread的生命周期关系]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java子线程执行完毕之后，主线程继续执行]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[业务说明：项目中经常会出现将一个庞大的业务拆分成多个小部分，独自在分内运行，但前后任务之间又需要一定的执行顺序，所以就用到了标题中的“主线程执行过程中等待子线程都异步执行完成后才继续执行的问题” 第一个简单的例子123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); &#125; System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程在执行!"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面这段代码输出如下结果，很明显，这个是主线程执行完成之后，子线程又执行的，这个先后顺序不确定，因为有可能若干个子线程执行完后，主线程才执行到执行结束1234567891011主线程已经执行结束了!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行! 能解决问题的第一个例子12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); try &#123; for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); myThread.join(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程在执行!"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面这段代码是能够实现子线程执行完毕之后，再执行主线程，但是存在一个问题就是子线程是一个一个顺序执行的，也就没有了意义，所以可以看下下面的异步执行的代码1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); long beginTime = System.currentTimeMillis(); Vector&lt;MyThread&gt; myThreadVector = new Vector&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); myThreadVector.add(myThread); &#125; for(MyThread tempMyThread : myThreadVector)&#123; try &#123; tempMyThread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("一共执行了"+(System.currentTimeMillis() - beginTime)+"ms"); System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程开始执行！"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 简单解析一下上面的代码：首先上面的代码输出如下：12345678910111213子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！Disconnected from the target VM, address: &apos;127.0.0.1:14413&apos;, transport: &apos;socket&apos;一共执行了1027ms主线程已经执行结束了! 首先创建一个Vector，然后通过创建Thread塞入到Vector中，然后再遍历Vector进行join动作，这样就可以不需要考虑子线程中sleep，动态的启动所有的线程]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编码规范]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[版权说明：本文档摘抄自《阿里巴巴Java开发手册（详尽版）》 摘抄不意味着单纯的Copy，而是对别人知识汲取和吸收的同时添加自己的个人理解 Java 编码规则手册 版本号 更新时间 备注 V1.0 2018-11-22 初始化版本 一、编程规约（一）命名风格 【强制】代码中的命名不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例：_name/__name/$name/name_/name$/name__ 【强制】代码中命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式 说明：正确的英文拼写和语法可以让阅读者易于理解，便面歧义 反例：DaZhePromotion()[打折]/getPingFenByName()[获取评分]/int 某变量=3 【强制】类名使用UpperCameCase风格，但以下情况例外DO/BO/DTO/VO/AO/PO/UID等 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCameCase风格，必须遵从驼峰形式。 正例：localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，尽量将语义表达清楚，不要害怕变量长度太长。 正例：MAX_STOCK_COUNT 反例：MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾 【强制】类型与中括号紧挨相连来表示数组 正例：定义整形数组 int[] arrayDemo 反例：在 main 参数中，使用 String args[]来定义 【强制】POJO 类中布尔类型的变量，都不要加 is前缀，否则部分框架解析会引起序列化错误 反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式 正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils 【强制】杜绝完全不规范的缩写，避免望文不知义 反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【强制】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意 正例：在JDK中，表达原子更新的类名为：AtomicReferenceFieldUpdater 反例：变量 int a 的随意命名方式 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念 正例：public class OrderFactory;,public class LoginProxy;,public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量 正例：接口方法签名void commit();接口基础常量 String COMPANY = &quot;alibaba&quot;; 反例：接口方法定义 public abstract void f(); 说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现 接口和实现类的命名有两套规则 1）【强制】对于 Service和DAO类，基于 SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别 正例：CacheServiceImpl 实现 CacheService接口 2）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形式） 正例：AbstractTranslator 实现 Translatable接口 【参考】枚举类名建议带上 Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开 说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有 正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON 【参考】 Service/DAO层方法命名规则 获取单个对象的方法用 get做前缀 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects 获取统计值的方法用 count 做前缀 插入的方法用 save/insert做前缀 删除的方法用 remove/delete 做前缀 修改的方法用 update做前缀 领域模型命名规约 数据对象：xxxDO，xxx 即为数据表名 数据传输对象：xxxDTO，xxx为业务领域相关的名称 展示对象：xxxVO，xxx一般为网页名称 POJO是 DO/DTO/BO/VO的统称，禁止命名成 xxxPOJO （二）常量定义 【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中反例： 1234//Magic values, except for predefined, are forbidden in coding.if (key.equals("Id#taobao_1")) &#123; //...&#125; 正例： 1234String KEY_PRE = "Id#taobao_1"; if (KEY_PRE.equals(key)) &#123; //...&#125; 【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护 说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护 正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下 反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量 ​ 类 A 中：public static final String YES = &quot;yes&quot;; ​ 类 B 中：public static final String YES = &quot;y&quot;; ​ A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题 子工程内部共享常量：即在当前子工程的 constant 目录下 包内共享常量：即在当前包下单独的constant目录下 类内共享常量：直接在类内部 private static final 定义 【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义（扩展enmu的使用方法）说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节正例： 12345678public enum SeasonEnum &#123; SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4); private int seq; SeasonEnum(int seq) &#123; this.seq = seq; &#125;&#125; （三）代码格式 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则 左大括号前不换行 左大括号后换行 右大括号前换行 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行 【强制】左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。详见第 5 条下方正例提示 反例：if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格 【强制】任何二目、三目运算符的左右两边都需要加一个空格 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等 【强制】采用 4 个空格缩进，禁止使用 tab 字符说明：如果使用tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character（扩展IDEA设置按TAB时输入四个空格的方法）；而在 eclipse 中，必须勾选 insert spaces for tabs正例： 12345678910111213141516171819public static void main(String[] args) &#123; // 缩进 4 个空格 String say = "hello"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println("world"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println("ok"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 【强制】注释的双斜线与注释内容之间有且仅有一个空格正例： 12// 这是示例注释，请注意在双斜线之后有一个空格String ygb = new String(); 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则- 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例- 运算符与下文一起换行- 方法调用的点符号与下文一起换行- 方法调用中的多个参数需要换行时，在逗号后进行- 在括号前不要换行，见反例正例： 123456StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append("zi").append("xin") .append("huang") .append("huang") .append("huang"); 反例： 1234567StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，不要在括号前换行sb.append("zi").append("xin")...append("huang");// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行method(args1, args2, args3, ..., argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格 正例：下例中实参的args1，后边必须要有一个空格 method(args1, args2, args3); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows格式 【推荐】单个方法的总行数不超过 80 行 说明：包括方法签名、结束右大括号、方法内代码、注释、空行、回车及任何不可见字符的总行数不超过 80 行 正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐正例： 1234int one = 1;long two = 2L;float three = 3F;StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情 【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性 说明：任何情形，没有必要插入多个空行进行隔开 （四）OOP规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可 【强制】所有的覆写方法，必须加@Override 注解 说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）正例： 1public List&lt;User&gt; listUsers(String type, Long... ids) &#123;...&#125; 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么正例： 1234@Deprecatedpublic static String toJson(Object obj) &#123; return toJson(getAttributes(obj));&#125; 【强制】不能使用过时的类或方法 说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么 【强制】Object 的 equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 正例：&quot;test&quot;.equals(object); 反例：object.equals(&quot;test&quot;) 说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断 关于基本数据类型与包装数据类型的使用标准如下 【强制】所有的 POJO 类属性必须使用包装数据类型 【强制】RPC 方法的返回值和参数必须使用包装数据类型 【推荐】所有的局部变量使用基本数据类型 说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE(空指针异常)问题，或者入库检查，都由使用者来保证 正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险 反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出 【强制】定义 DO/DTO/VO 等 POJO类时，不要设定任何属性默认值 反例：POJO 类的 gmtCreate 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中 【强制】POJO 类必须写toString 方法。使用 IDE 中的工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题 【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和getXxx()方法 说明：框架在调用属性 xxx的提取方法时，并不能确定哪个方法一定是被优先调用到 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险说明： 1234String str = "a,b,c,,";String[] ary = str.split(",");// 预期大于 3，结果是 3System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 16 条规则 【推荐】类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度反例： 1234567public Integer getData() &#123; if (condition) &#123; return this.data + 100; &#125; else &#123; return this.data - 100; &#125;&#125; 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费(扩展Java中的String，StringBuilder，StringBuffer三者的区别)反例： 1234String str = "start";for (int i = 0; i &lt; 100; i++) &#123; str = str + "hello";&#125; 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字 不允许被继承的类，如：String 类 不允许修改引用的域对象 不允许被重写的方法，如：POJO 类的 setter 方法 不允许运行过程中重新赋值的局部变量 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构 【推荐】慎用 Object 的 clone方法来拷贝对象 说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现域对象的深度遍历式拷贝 【推荐】类成员与方法访问控制从严 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private 工具类不允许有 public 或 default 构造方法 类非 static 成员变量并且与子类共享，必须是 protected 类非 static成员变量并且仅在本类使用，必须是 private 类 static 成员变量如果仅在本类使用，必须是 private 若是 static成员变量，考虑是否为 final 类成员方法只供类内部调用，必须是 private 类成员方法只对继承类公开，那么限制为 protected 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的 （五）集合处理 【强制】关于 hashCode 和 equals的处理，遵循如下规则 只要重写 equals，就必须重写 hashCode 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals 说明：String重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用 【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList 说明：subList 返回的是ArrayList 的内部类SubList，并不是 ArrayList 而是ArrayList的一个视图，对于 SubList子列表的所有操作最终会反映到原列表上 【强制】在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()说明：使用toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致正例： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add("guan");list.add("bao");String[] array = new String[list.size()];array = list.toArray(array); 反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常 说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组 12String[] str = new String[] &#123; "you", "wu" &#125;;List list = Arrays.asList(str) 第一种情况：list.add(&quot;yangguanbao&quot;); 运行时异常 第二种情况：str[0] = &quot;gujin&quot;; 那么 list.get(0)也会随之修改 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而&lt;? super T&gt;不能使用 get 方法，作为接口调用赋值时易出错 说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt; 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁正例： 12345678910List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("1");list.add("2");Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 反例： 12345for (String item : list) &#123; if ("1".equals(item)) &#123; list.remove(item); &#125;&#125; 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗 【强制】在 JDK7 版本及以上，Comparator（扩展Java] 用 Comparator 实现排序） 实现类要满足如下三个条件，不然Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常 说明：三个条件如下 x，y 的比较结果和 y，x 的比较结果相反 x&gt;y，y&gt;z，则 x&gt;z x=y，则 x，z 比较结果和 y，z 比较结果相同 反例：下例中没有处理相等的情况，实际使用中可能会出现异常 123456new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125;; 【推荐】集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略说明：菱形泛型，即 diamond，直接使用&lt;&gt;来指代前边已经指定的类型正例： 1234// &lt;&gt; diamond 方式HashMap&lt;String, String&gt; userCache = new HashMap&lt;&gt;(16);// 全省略方式ArrayList&lt;User&gt; users = new ArrayList(10); 【推荐】集合初始化时，指定集合初始值大小 说明：HashMap使用 HashMap(int initialCapacity)初始化 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法 正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合 【推荐】高度注意 Map 类集合K/V能不能存储null 值的情况，如下表格 | 集合类 | Key | Value | Super | 说明 || —————– | ————————————– | ————————————– | ———– | ———————- || Hashtable | 不允许为 null | 不允许为 null | Dictionary | 线程安全 || ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 锁分段技术（JDK8:CAS） || TreeMap | 不允许为 null | 允许为 null | AbstractMap | 线程不安全 || HashMap | 允许为 null | 允许为 null | AbstractMap | 线程不安全 | 反例：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常 【推荐】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响 说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是order/sort 【推荐】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List的contains 方法进行遍历、对比、去重操作 （六）并发处理 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全 说明：资源驱动类、工具类、单例工厂类都需要注意 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯正例： 123456public class TimerTaskThread extends Thread &#123; public TimerTaskThread() &#123; super.setName("TimerTaskThread"); ... &#125;&#125; 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程（扩展Java并发编程：线程池的使用） 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 说明：Executors返回的线程池对象的弊端如下 FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类 正例：注意线程安全，使用 DateUtils。亦推荐如下处理： 123456private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat("yyyy-MM-dd"); &#125;&#125;; 说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次 【强制】多线程并行处理定时任务时，Timer运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService则没有这个问题 【强制】禁止在循环中调用synchronized（同步）方法说明：方法的同步需要消耗相当大的资源，不要在循环中调用同步方法反例： 1234567891011import java.util.Vector;public class SYN &#123; public synchronized void method (Object o) &#123; &#125; private void test () &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; method (vector.elementAt(i)); // violation &#125; &#125; private Vector vector = new Vector (5, 5);&#125; 正例： 12345678910111213import java.util.Vector;public class SYN &#123; public void method (Object o) &#123; &#125;private void test () &#123;synchronized&#123;//在一个同步块中执行非同步方法 for (int i = 0; i &lt; vector.size(); i++) &#123; method (vector.elementAt(i)); &#125; &#125; &#125; private Vector vector = new Vector (5, 5);&#125; 【强制】禁止在循环中使用表达式说明：在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快反例： 1234567import java.util.Vector;class CEL &#123; void method (Vector vector) &#123; for (int i = 0; i &lt; vector.size (); i++) // Violation ; // ... &#125;&#125; 正例： 1234567class CEL_fixed &#123; void method (Vector vector) &#123; int size = vector.size () for (int i = 0; i &lt; size; i++) ; // ... &#125;&#125; 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果 说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降（扩展多线程下生成随机数） 说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式 正例：在 JDK7 之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型反例： 1234567891011class LazyInitDemo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125;// other methods and fields...&#125; （七）控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件 说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替 反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止 【强制】在 if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成 12345 if (condition) &#123; ... return obj; &#125;// 接着写 else 的业务逻辑代码; 说明：如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层 正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下 123456789101112public void today() &#123; if (isBusy()) &#123; System.out.println(“change time.”); return; &#125; if (isFree()) &#123; System.out.println(“go to travel.”); return; &#125; System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return;&#125; 【推荐】除常用方法（如getXxx/isXxx等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢正例： 12345// 伪代码如下final boolean existed = (file.open(fileName, "w") != null) &amp;&amp; (...) || (...);if (existed) &#123; ...&#125; 反例： 123if ((file.open(fileName, "w") != null) &amp;&amp; (...) || (...)) &#123; ...&#125; 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外） 【推荐】避免采用取反逻辑运算符 说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法 正例：使用if (x &lt; 628)来表达 x 小于 628 反例：使用 if (!(x &gt;= 628)) 来表达 x 小于 628 【推荐】接口入参保护，这种场景常见的是用作批量操作的接口 【推荐】下列情形，需要进行参数校验： 调用频次低的方法 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失 需要极高稳定性和可用性的方法 对外提供的开放接口，不管是 RPC/API/HTTP 接口 敏感权限入口 【推荐】下列情形，不需要进行参数校验 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO的参数校验，可以省略 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数 （八）注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容\/格式，不得使用// xxx 方式 说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：对子类的实现要求，或者调用注意事项，请一并说明 【强制】所有的类都必须添加创建者和创建日期 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可 反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义 【推荐】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除 说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码） 【推荐】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 【推荐】核心代码注释量不得低于文件总行数的30%，非核心代码注释量不得低于文件总行数的20% （九）其他 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”) 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法 说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime() 说明：如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类 【强制】删除未引用类，避免使用以”.*”结尾的引用，引用的顺序如下： JDK标准包（例如：import java.io.IOException等） 第三方的包（例如：import org.dom4j.Node等） 项目的公共包 【强制】禁止在循环体中生命并实例化变量说明：在循环体中声明并实例化临时变量将会增加内存消耗，增加垃圾回收的次数；尤其是大对象，严格禁止在循环体内声明并实例化对象反例： 123456789import java.util.Vector;public class LOOP &#123; void method (Vector v) &#123; for (int i=0;i &lt; v.size();i++) &#123; Object o = new Object(); // 不建议 o = v.elementAt(i); &#125; &#125;&#125; 正例： 123456789import java.util.Vector;public class LOOP &#123; void method (Vector v) &#123; Object o; for (int i=0;i&lt;v.size();i++) &#123; o = v.elementAt(i); &#125; &#125;&#125; 【推荐】不要在视图模板中加入任何复杂的逻辑 说明：根据 MVC理论，视图的职责是展示，不要抢模型和控制器的活 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存 【推荐】及时清理不再使用的代码段或配置信息 说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余 正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由 二、异常日志（一）异常处理 【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过 catch NumberFormatException 来实现 正例：if (obj != null) {...} 反例：try { obj.method(); } catch (NullPointerException e) {…} 【强制】异常不要用来做流程控制，条件控制 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多 【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理 说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch 说明：如果 JDK7 及以上，可以使用 try-with-resources 方式（扩展Java进阶知识点3：更优雅地关闭资源 - try-with-resource及其异常抑制） 【强制】不要在 finally 块中使用 return 说明：finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值 说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null 的情况 【强制】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE 数据库的查询结果可能为 null 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null 远程调用返回对象时，一律要求进行空指针判断，防止 NPE 对于 Session 中获取的数据，建议 NPE 检查，避免空指针 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE 正例：使用JDK8 的 Optional 类来防止 NPE 问题。（扩展Java8 如何正确使用 Optional） 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等 【推荐】对于公司外的 http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息” 说明：关于 RPC 方法返回方式使用 Result 方式的理由 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题 【推荐】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化 正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {...} （二）日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式 appName_logType_logName.log logType:日志类型，如 stats/monitor/access 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找 正例：mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式 说明：logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印 正例：（条件）建设采用如下方式 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);&#125; 正例：（占位符） 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml中设置 additivity=false。 正例：&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出 正例：logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e); 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从 三、安全规约 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库 【强制】用户请求传入的任何参数必须做有效性验证 说明：忽略参数校验可能导致 page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS 说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据 【强制】表单、AJAX 提交必须执行 CSRF 安全验证 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 四、MySQL数据库（一）建表规约 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否） 说明：任何字段如果是非负数，必须是unsigned 注意：POJO类中任何布尔类型的变量，都不要加is前缀，所以，需要在设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取之含义与取值范围 正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL在Windows下不区分大小写，单在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdConfig，level_3_name 【强制】表名不适用复数名词 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 【强制】禁用保留字，如desc、range、match、delayed等，请参照MySQL官方保留字 【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名为idx_字段名。 说明：pk_即primary key；uk_即unique key;idx_即index的简称。 【强制】小数类型为decimal，禁止使用float和double 说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成证书和小数部分分开存储。 【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出一张表，用主键来对应，避免影响其他字段索引效率。 【强制】表必备三个字段：id，gmt_create，gmt_modified 说明：其中id必为主键，类型为bigint unsigned、表单时自增，步长为1。gmt_create，gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新 【推荐】表的命名最好是“业务名称_表的作用” 正例：alipay_task/force_project/trade_config 【推荐】库名尽量与应用名保持一致 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 不是频繁修改的字段 不是varchar超长字段，更不能是text字段 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间，节约索引存储，更重要的是提升检索速度 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围 | 对象 | 年龄区间 | 类型 | 字节 | 表示范围 || ——– | ——— | ——————- | —- | ——————– || 人 | 150岁之内 | tinyint unsigned | 1 | 无符号：0~255 || 龟 | 数百岁 | smallint unsigned | 2 | 无符号：0~65535 || 恐龙化石 | 数千万年 | int unsigned | 4 | 无符号：0~约42.9亿 || 太阳 | 约50亿年 | bigint unsigned | 8 | 无符号：0~10的19次方 | （二）索引规约 【强制】业务上具有唯一特性的字段，及时是多个字段的组合，也必须建成唯一索引 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高了查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生 【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双标join也要注意表索引和SQL性能 【强制】在varchar字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会打到90%以上，可以使用count(distinct left(列名，索引长度))/count(*)的区分度来确定. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引：a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b;索引a_b无法排序 【推荐】利用覆盖索引来进行查询操作，避免全表。 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的中类分别为朱建索引、唯一索引、普通索引三种，而覆盖索引知识一种查询的一种效果，用explain的结果，extra列会出现using index 【推荐】利用延迟关联或者子查询优化超多分页场景 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的地下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联 1SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】防止因字段类型不同造成隐式转换，导致索引失效 【参考】创建索引避免有如下极端误解 宁滥勿缺：任务一个查询就需要建一个索引 宁缺毋滥：认为索引会小号控件、严重拖慢更新和新增速度 地址唯一索引：任务业务的唯一性一律需要在应用层通过“先查后插”方式解决 （三）SQL语句 【强制】不要使用count(列名)或者count(常量)来代替count(\*),count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL或非NULL无关。 说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 【强制】count(distinct col)计算该列除NULL之外的不重复行数，注意count(distinct col1,col2)如果其中一列全为NULL，那么及时另一列有不同的值，也返回0 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但是sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题 正例：可以使用如下方式来避免sum的NPE问题： 1SELECT IF(ISNULL(SUM(g)),0,SUM(g))FROM table; 【强制】使用ISNULL()来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL NULL&lt;&gt;NULL的返回结果是NULL，而不是false NULL=NULL的结果返回值是NULL，而不是true NULL&lt;&gt;1的返回结果是NULL，而不是true 【强制】在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句 【强制】不得使用外检或级联，一切外键概念必须在应用层解决 说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误后才能执行更新语句 【推荐】in操作能避免则避免，是在避免不了，需要仔细评估in后边集合元素数量，控制在1000个内。 【参考】注意字符串统计函数的区别说明： SELECT LENGTH(“轻松工作”);返回12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4 如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码区别 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同 （四）ORM映射 【强制】在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明说明： 增加查询分析器解析成本 增减字段容易与resultMap配置不一致 无用字段增加网络小号，尤其是text类型字段 【强制】不要用resultClass当返回参数，及时所有的类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必须有一个POJO类与之对应 说明：配置映射关系，是字段与DO类解耦，方便维护 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL 注入 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控 【强制】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等 五、Oracle数据库（一）对象命名规范 【强制】数据库名称定义为系统名+模块名说明： 全局数据库名和SID名要求一致 因SID名只能包含字符和数字，所以全局数据库和SID名中不能含有“_”等字符 【强制】表空间命名规范 面向用户的专用数据表空间以用户名+_+data命名 ，如Aud 用户专用数据表空间可命名为Aud_data 面向用户的专用索引表空间以用户名+_+idx命名 面向用户的专用临时表空间以用户名+_+tmp命名 面向用户的专用回滚段表空间以用户名+_+rbs命名 面向应用的表空间以应用名+_data/应用名+_idx/应用名+_tmp/应用名+_rbs 命名 LOB 段数据专用表空间以其数据表空间+_+lobs 命名，如上例中数据表空间为Aud_data，则LOB 段表空间可命名为Aud_data_lobs 表空间文件命名以表空间名+两位数序号(序号从01开始)组成，如Aud_data01 等 【强制】表名的命名规范- 一般表采用系统名+t_+模块名+_+表义名 格式构成- 若数据库中只含有单个模块，命名可采用系统名+t_+表义名格式构成- 模块名或表义名均以其汉语拼音的首字符命名，表义名中汉语拼音均采用小写，且字符间不加分割符- 表别名命名规则：取表义名的前3 个字符加最后一个字符。如果存在冲突，适当增加字符（如取表义名的前4 个字符加最后一个字符等）- 临时表采用系统名+t_tmp_+表义名 格式构成 正例： 123dft_gy_cbap：系统名（电费 df）+t_+模块名（高压 gy）+_+表义名（抄表安排 cbap）dft_cbbj: 系统名（电费 df）+t_+表义名（抄表标记 cbbj）dft_tmp_hj: 系统名（电费 df）+tmp+表义名（合计hj）(此处为临时表) 【强制】属性（列或字段）命名规则 采用有意义的列名，为实际含义的汉语拼音的首字符，且字符间不加任何分割符 属性名前不要加表名等作为前缀 属性后不加任何类型标识作为后缀 不要使用“ID”作为列名 关联字段命名以 cd+_+关联表的表义名（或缩写）+_+字段名进行 【强制】主键命名规则 任何表都必须定义主键 表主键命名为：pk+_+表名(或缩写)+_+主键标识如pk_YHXX_IDKH等 【强制】外键命名规则 表外键命名为： fk+_+表名(或缩写)+_主表名(或缩写)+_+主键标识如fk_YHLX_YHXX_SFZH等 【强制】CHECK约束命名规则 CHECK 约束命名为： chk+_+CHECK约束的列名（或缩写） 【强制】UNIQUE约束命名规则 UNIQUE 约束命名为： unq+_+UNIQUE约束的列名（或缩写） 【强制】索引命名规则 索引的命名为：表名（或缩写）+_+列名+_idx，其中多单词组成的属性列列名取前几个单词首字符再加末单词首字符组成如yd_kh 表khid上的index: yd_kh_khid_idx 【强制】视图命名规则 视图命名以系统名v_+模块名作为前缀，其他命名规则和表的命名类似 （二）SQL编写规范 【强制】表面使用数据库类型的自动转换功能反例： 1SELECT * FROM category WHERE id = '123'; -- id如果是数字类型的，在这就需要内置转换，所以尽量保持数据类型一致 【参考】SELECT语句编写规范 关键字大写，列表名表名小写 由SELECT 开头，后跟一个显示查询结果的列表 由FROM 开头，后跟一个或多个获取数据所涉及的表 由WHERE 开头，后跟一个或多个确定所需值的条件 由GROUP BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行汇总 由ORDER BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行排序 【参考】尽量避免在循环中使用SQL语句 【参考】避免在WHERE子句中对列施以函数；正例： 123456SELECT *FROM service_promotionWHERE gmt_modified&gt;= TO_DATE('2001-9-01','yyyy-mm-dd')AND gmt_modified&lt; TO_DATE('2001-9-02','yyyy-mm-dd'); 反例： 1234SELECT *FROM service_promotionWHERE TO_CHAR(gmt_modified,’yyyy-mm-dd’)= '20001-09-01'; （三）类型选择 【强制】不同的数据类型选择不同的数据存储类型，不要什么都用varchar2 用char(1)代表布尔值 应尽量使用varchar2代替char类型 varchar2最多4000字符 date精确到微秒，而非天 使用clob代替long,blob代替long raw oracle只有number一种数据类型，使用时请给定长度 附件：专有名词解释 POJO（Plain Ordinary Java Object）：在本手册中，POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等 OOP（Object Oriented Programming）：本手册泛指类、对象的变成处理方式 ORM（Object Relation Mapping）：对象关系映射，对象领域模型与底层数据之间的转换，本文繁殖iBATIS，mybatis等框架 NPE（java.lang.NullPointterException）：空指针异常 IDE（Integrated Development Environment）：用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本手册泛指IDEA和Eclipse OOM（Out of Memory）：源于java.lang.OutOfMemoryError，当JVM没有足够的内存来为对象分配空间并且垃圾回收无法回收空间时，系统出现的严重状况]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户登录对账号和密码加解密]]></title>
    <url>%2F2019%2F01%2F23%2F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%AF%B9%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[背景说明闲的无聊，F12看了下项目上的登录，一看账号和密码都是明文发送的，因此找了下网络上的一些文章，对项目进行了优化 背景目前的项目登录的时候都是明文的传递账号和密码，具体如下图所示 解决方案准备资源 jar包(使用Maven引入jar包，如果不是Maven项目可以去Maven仓库将jar下载下来，然后导入项目中) 12345&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt; &lt;version&gt;1.46&lt;/version&gt;&lt;/dependency&gt; 加密js文件在Github上找到这个项目https://github.com/travist/jsencrypt的bin目录下下载jsencrypt.min.js进行 具体步骤 （后台）创建一个RSA工具类(RSAUtil.java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import java.security.*;import java.security.interfaces.RSAPublicKey;/** * @ClassName RASUtil * @Description TODO * @Date 2018/12/109:52 * @Version 1.0 **/public class RSAUtil&#123; //KeyPair is a simple holder for a key pair. private static final KeyPair keyPair = initKey(); /** * 初始化方法，产生key pair，提供provider和random * @return KeyPair instance */ private static KeyPair initKey() &#123; try &#123; //添加provider Provider provider = new org.bouncycastle.jce.provider.BouncyCastleProvider(); Security.addProvider(provider); //产生用于安全加密的随机数 SecureRandom random = new SecureRandom(); KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA", provider); generator.initialize(1024, random); return generator.generateKeyPair(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 产生public key * @return public key字符串 */ public static String generateBase64PublicKey() &#123; PublicKey publicKey = (RSAPublicKey)keyPair.getPublic(); //encodeBase64(): Encodes binary data using the base64 //algorithm but does not chunk the output. //getEncoded():返回key的原始编码形式 return new String(Base64.encodeBase64(publicKey.getEncoded())); &#125; /** * 解密数据 * @param string 需要解密的字符串 * @return 破解之后的字符串 */ public static String decryptBase64(String string) &#123; //decodeBase64():将Base64数据解码为"八位字节”数据 return new String(decrypt(Base64.decodeBase64(string.getBytes()))); &#125; private static byte[] decrypt(byte[] byteArray) &#123; try &#123; Provider provider = new org.bouncycastle.jce.provider.BouncyCastleProvider(); Security.addProvider(provider); //Cipher: 提供加密和解密功能的实例 //transformation: "algorithm/mode/padding" Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", provider); PrivateKey privateKey = keyPair.getPrivate(); //初始化 cipher.init(Cipher.DECRYPT_MODE, privateKey); //doFinal(): 加密或者解密数据 byte[] plainText = cipher.doFinal(byteArray); return plainText; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; （后台）编写一个生成公钥的接口 12345678910111213141516171819202122/** *@Description 生成公钥 *@param *@return java.lang.String *@date 2018/12/10 9:48 **/@RequestMapping("/genPubKey")@ResponseBodypublic String genPubKey()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("code",-1); String publicKey = ""; try &#123; publicKey = RSAUtil.generateBase64PublicKey(); map.put("pubkey",publicKey); map.put("code",1); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put("msg",e.getMessage()); &#125; return publicKey;&#125; （前台）登录界面引入jsencrypt.min.js，初始化登录页的同时初始化公钥 123456789101112131415161718192021//页面初始化，调取公钥var publicKey = &apos;&apos;;$(function()&#123; getPublicKey();&#125;)//调取后台生成公钥接口function getPublicKey()&#123; $.ajax(&#123; url: &quot;user/genPubKey&quot;, type: &quot;post&quot;, dataType: &quot;text&quot;, data:&#123;&#125;, success: function(data) &#123; if(data) publicKey = data; if(publicKey==null)&#123; alert(获取publicKey失败，请联系管理员！); &#125; &#125; &#125;);&#125; （前台）点击登录时，使用公钥生成私钥，加密账号和密码 1234567891011var uname = $.trim($(&quot;#userName&quot;).val());var upwd = $.trim($(&quot;#passWord&quot;).val());var encrypt = new JSEncrypt();if(publicKey)&#123;encrypt.setPublicKey(publicKey);//设置公钥到前端生成私钥uname = encrypt.encrypt(uname);//加密用户名upwd = encrypt.encrypt(upwd);//加密密码//通过ajax发送加密的账号和密码到后台.....&#125; （后台）后台账号和密码解密 12String loginID = RSAUtil.decryptBase64(username);String pwd = RSAUtil.decryptBase64(passwd); 总结前台页面加载时调用生成公钥方法生成公钥，然后用户点击登录时，获取用户名和密码，根据之前生成的公钥，进行私钥加密，传入后台的数据就是已经加密过的数据，然后我们在后台进行解密，得到用户输入的原始密码和账户]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>功能相关</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>登录</tag>
        <tag>加解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 操作页面打印操作（不使用插件）]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[页面打印​ 打印之前没怎么接触过，最近项目有需求在系统中实现打印合同的功能，系统中的合同是用Bootstrap实现的html页面，因此就查阅资料，发现window.print方法可以在不使用外部打印插件的前提下，可以进行页面的打印操作，这种既简单又好操作，但是存在一个缺点是：页面内容的替换 实现原理实现原理很简单：是通过页面替换到window.document.body中的内容，然后就可以用window.print就可以打印window.document.body中的内容 实现代码123456789101112131415&lt;body&gt;...&lt;div id="print-content" class="container" style="clear: both;width: 210mm;height: 297mm"&gt; ....&lt;/div&gt;....&lt;script&gt; var bdhtml = window.document.body.innerHTML;//获取当前页的html代码 //获取需要打印的html代码 window.document.body.innerHTML = $("#print-content")[0].innerHTML; window.print(); window.document.body.innerHTML = bdhtml;//还原页面内容&lt;/script&gt;&lt;/body&gt; 效果Chrome Firfox和IE这两个浏览器是没有打印预览的，是直接弹出打印页面的 扩展Chrome打印的时候会出现页眉和页脚中有地址的问题，可以直接点击上图中左侧的页眉页脚中取消勾选]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 遍历JSON]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E9%81%8D%E5%8E%86JSON%2F</url>
    <content type="text"><![CDATA[背景说明：常规下一般是用不到Json对象的遍历的，但是如果要做一些公共方法的时候，有可能会用到，比如说后端扔给你一个json串，需要你把数据反显到页面上，这种就需要进行处理了，遍历扔给你json串，然后获取和页面上匹配的内容，进行赋值操作，当然这个过程中还得需要判断控件的类型，毕竟存在一些特殊类型的控件，比如说文件上传和回显、复选框、单选框等等特殊控件 遍历有规律的JSON对象12345678910111213packJson = [&#123;"name":"nikita", "password":"1111"&#125;,&#123;"name":"tony", "password":"2222"&#125;];for(var p in packJson)&#123;//遍历json数组时，这么写p为索引，0,1 alert(packJson[p].name + " " + packJson[p].password);&#125; 遍历无规律的JSON对象123456789101112&lt;script&gt;var json = [ &#123;dd:'SB',AA:'东东',re1:123&#125;, &#123;cccc:'dd',lk:'1qw'&#125;];for(var i=0,l=json.length;i&lt;l;i++)&#123; for(var key in json[i])&#123; alert(key+':'+json[i][key]); &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 基础知识]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[js字符串转int(parseInt)1alert(parseInt(childNode)+1); js删除Object对象中的属性1delete obj.attr]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
