<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS7安装SVN]]></title>
    <url>%2F2019%2F02%2F19%2FCentOS7%E5%AE%89%E8%A3%85SVN%2F</url>
    <content type="text"><![CDATA[安装SVN 通过 yum install subversion来安装 提示已经安装。查看svn版本使用: svnserve –-version 使用命令: svnadmin create svn/repo 进入版本库中的配置目录conf，此目录有三个文件： svn服务综合配置文件、 用户名口令文件、权限配置文件 配置权限配置文件authz说明：两个站点为bbs,blog,所以分为三个组超级管理组admin、bbs管理组bbsadmin、blog管理组blogadmin。超级管理组admin可以读写所有站点内容，而bbsadmin对bbs站点可以读写，而只能读blog站点。以及blogadmin对blog站点可以读写,对bbs站点只读。 配置用户口令文件passwd,添加组用户以及密码 配置 svn服务综合配置文件svnserve.conf，取消以下项目的注释，其中一定要注意anon-access=none，因为这个是要看历史版本用的 启用/关闭svn 启动SVNsvnserve -d -r /home/svn/project/ 关闭svn通过ps -aux|grep svn 查看到的svn进程id来进行关闭]]></content>
      <categories>
        <category>软件安装</category>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>软件安装</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN问题集合]]></title>
    <url>%2F2019%2F02%2F19%2FSVN%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[SVN安装完成后没有svn.exe的问题 在安装的SVN的时候，有时候会出现安装完之后，没有svn.exe的问题，解决该问题的办法是在安装的时候选择安装command line client tools 打开小三角然后选择里面的Will be installed on local hard drive IDEA中SVN报错E230001Server SSL certificate verification failedcertificate issue 首先执行cmd命令 1svn ls http://xxxx 其中http://xxx指的是svn服务器的地址 然后会显示(R)eject, accept (t)emporarily or accept (p)ermanently?,这个时候输入p 执行完成后会出现让输入Administrator的密码，直接输入电脑的Administrator的密码，如果没有密码，直接回车即可 然后根据提示输入svn的账号和密码 最后就可以直接在IDEA中进行checkout操作了]]></content>
      <categories>
        <category>办公知识</category>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
        <tag>问题集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6安装Git]]></title>
    <url>%2F2019%2F02%2F19%2FCentOS6%E5%AE%89%E8%A3%85Git%2F</url>
    <content type="text"><![CDATA[1. git卸载 如果是之前安装过git，需要先进行卸载操作 1rpm -e --nodeps git 2. 下载最新版本的git 去Git的下载地址查找自己的Git版本，页面地址为Git下载地址，这个地方可以按照日期进行查询，找当年的最新发布的版本，文件名的格式为“git-2.18.0.tar.gz”，这里使用的下载地址为https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.18.0.tar.gz 1234567891011121314151617181920# 下载源程序包cd /home/Downloadwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.18.0.tar.gz# 安装依赖包yum -y install libcurl-devel expat-devel curl-devel gettext-devel openssl-devel zlib-develyum -y install gcc perl-ExtUtils-MakeMaker# 解压编译程序tar -zxvf git-2.18.0.tar.gzcd git-2.18.0make prefix=/usr/local/git allmake prefix=/usr/local/git install# 添加git到环境变量echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc# 查看git版本git --version 问题：git clone的时候报SSL错误 问题 123[root@localhost temp]# git clone https://github.com/alibaba/anyproxy.gitCloning into &apos;anyproxy&apos;...fatal: unable to access &apos;https://github.com/alibaba/anyproxy.git/&apos;: SSL connect error 解决方案 更新系统的NNS1yum -y update nss]]></content>
      <categories>
        <category>软件安装</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github学习]]></title>
    <url>%2F2019%2F02%2F19%2FGithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Git Flow如何工作初始分支所有在Master分支上Commit应该Tag Feature分支分支名feature/*Feature分支做完之后，必须合并回Develop分支，合并完之后一般会删除这个Feature分支，但是我们也是可以保留的 Release分支分支名release/*Release分支基于Develop分支创建，打完Release分支之后，我们可以在Release分支上测试，修改BUG，同时，其他研发人员可以基于开发新的Feature（一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支）发布Release分支时，合并Release到Master和Develop，同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了 维护分支Hotfix分支名hotfix/*hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个Tag Git Flow代码示例 创建develop分支 12git branch developgit push -u origin develop 开始新Feature开发 123456789#基于develop创建feature分支 git checkout -b new-feature develop #可选，是否推送feature分支到remote端 git push -u origin new-feature#做一些改动git statusgit add some-file #或者 git add *git commit 完成feature 12345678910#拉取开发库远端，保证合并代码不覆盖git pull orgin developgit checkout developgit merge --no-ff new-featuregit push origin develop#删除功能分支git branch -d new-feature#如果你把功能分支推送到远端了git push origin --delete new-feature 开始Release 12345#创建基于develop的release分支git checkout -b release-0.1.0 develop#可选项：Bump version number，commit#Prepare release，commit 这个地方还没看懂 完成Release 12345678910111213141516171819#将release代码合并到主分支上git checkout mastergit merge --no-ff release-0.1.0git push#将release分支合并到develop分支上git checkout developgit merge --no-ff release-0.1.0git push#删除release分支git branch -d release-0.1.0#如果远端也有release分支，需要进行删除操作git push origin --delete release-0.1.0#给主分支打标签git tag -a v0.1.0 mastergit push --tags 开始Hotfix 12#首先clone master分支git checkout -b hotfix-0.1.9 master 完成Hostfix 12345678910111213141516#切换到master分支上，将hotfix合并到master分支上git checkout mastergit merge --no-ff hotfix-0.1.0git push#然后将分支内容合并到develop分支上git checkout developgit merge --no-ff hotfix-0.1.0git push#删除hotfix分支git branch -d hotfix-0.1.0#给master分支打标签git tag -a v0.1.1 mastergit push --tags 引用自：https://www.cnblogs.com/cnblogsfans/p/5075073.html，没事的可以看下 Git Flow确实是一个很好的Git开发流程]]></content>
      <categories>
        <category>办公知识</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10安装Maven]]></title>
    <url>%2F2019%2F02%2F19%2FWin10%E5%AE%89%E8%A3%85Maven%2F</url>
    <content type="text"><![CDATA[准备工作 电脑安装JDK1.7以上 Win10操作系统 Maven安装包 下载地址 解压Maven安装包 下载完之后，把Maven安装包解压到你想要解压的目录下，本人解压到D:\Program Files\apache-maven-3.5.3下,解压完成后，目录下会有bin、boot、conf、lib文件夹及ReadMe文件等配置环境变量 我的电脑-右键-属性-高级系统设置-环境变量-系统变量-新建 变量名称：M2_HOME 变量值：D:\Program Files\apache-maven-3.5.3 找到Path在环境变量值尾部加入：;%M2_HOME%\bin; //前面注意分号 检查JDK和Maven配置是否成功 Win键+R，输入cmd，打开dos界面 输入mvn -v ,出现以下说明安装成功 1234567C:\Users\Daniel&gt;mvn -vApache Maven 3.5.3 (3383c37e1f9e9b3bc3df5050c29c8aff9f295297; 2018-02-25T03:49:05+08:00)Maven home: D:\Program Files\apache-maven-3.5.3\bin\..Java version: 1.7.0_80, vendor: Oracle CorporationJava home: D:\Program Files\Java\jdk1.7.0_80\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 8.1", version: "6.3", arch: "amd64", family: "windows" 修改本地仓库位置Maven会将下载的类库（jar包）放置到本地的一个目录下（一般默认情况下maven在本机的仓库位于C:\我的文档中.m2.\repository），如果想重新定义这个目录的位置就需要修改Maven本地仓库的配置 在自己喜欢的位置创建文件夹，此处本人创建的位置是（F:\Maven\repo） 在安装Maven的目录下找到conf文件夹，在文件夹中找到settings.xml文件，复制settings.xml文件放于F:\Maven，如下图所示： 3.修改settings.xml文件，如下图所示： 在安装Maven的目录下找到conf文件夹，在文件夹中找到settings.xml文件，更改默认的仓库位置如下图所示：（注意两个地方的settings.xml都要修改） 校验修改的配置是否成功，控制台输入：mvn help:system，如果成功，maven会从远程中央仓库下载jar包到本地的repo文件夹中]]></content>
      <categories>
        <category>软件安装</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok内网映射使用]]></title>
    <url>%2F2019%2F02%2F19%2Fngrok%E5%86%85%E7%BD%91%E6%98%A0%E5%B0%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装将本地Web服务器公开到Internetngrok允许您将在本地计算机上运行的Web服务器公开到Internet。只需告诉ngrok您的Web服务器正在侦听的端口。 如果您不知道您的Web服务器正在侦听的端口，则可能是端口80，HTTP的默认端口。 1ngrok http 80 当您启动ngrok时，它将在您的终端中显示您的隧道的公共URL以及有关通过隧道进行的连接的其他状态和指标信息。 其中 http://127.0.0.1:4040 可以查看具体的映射请求情况12345678910ngrok by @inconshreveableTunnel Status onlineVersion 2.0/2.0Web Interface http://127.0.0.1:4040Forwarding http://92832de0.ngrok.io -&gt; localhost:80Forwarding https://92832de0.ngrok.io -&gt; localhost:80Connnections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 检查您的流量ngrok提供了一个实时网络用户界面，您可以在这里查看隧道上运行的所有HTTP流量。启动ngrok后，只需在Web浏览器中打开http：// localhost：4040以检查请求详细信息。尝试向您的公开网址发送请求。有了之后，请回顾一下检查用户界面。您将看到请求和响应的所有详细信息，包括时间，持续时间，标题，查询参数和请求负载以及线路上的原始字节。 安装authtoken注册一个账号，可以获取到一个authtoken，然后通过下面的命令添加到自己的ngrok1ngrok authtoken &lt;YOUR_AUTHTOKEN&gt; HTTP 隧道自定义子域名常规情况下，ngrok会提供一个16进制随机的域名，然后开通一个http隧道，如果需要自定义的subdomain，可以使用以下方法1ngrok http -subdomain=inconshreveable 80 12345ngrok by @inconshreveable...Forwarding http://inconshreveable.ngrok.io -&gt; 127.0.0.1:80Forwarding https://inconshreveable.ngrok.io -&gt; 127.0.0.1:80 使用密码保护隧道可以使用 -auth 保证交换数据的安全性1ngrok http -auth=&quot;username:password&quot; 8080 自定义域名（收费就不记录了）1ngrok http -region=us -hostname=dev.example.com 8000 暂时比较忙，先写到这里，具体可以见这个地址]]></content>
      <categories>
        <category>软件安装</category>
        <category>ngrok</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>内网映射</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frp-内网映射 服务端部署]]></title>
    <url>%2F2019%2F02%2F19%2Ffrp-%E5%86%85%E7%BD%91%E6%98%A0%E5%B0%84-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[frp作用 利用处于内网或者防火墙后的服务器，对外网环境提供HTTP或HTTPS服务 对于http、https服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口 对往往提供tcp和udp服务，可以在夹中ssh访问处于公司内网的主机 配置说明 配置前准备公网服务器1台及独立固定IP地址 服务器安装 首先下载frp，下载页面点击frp下载地址，下载的时候根据自己服务器和映射主机的需求进行判断下载 服务器(Linux) 123456cd /usr/localmkdir frp#上传frp解压出来的内容到该目录下#删除和客户端相关的内容 frpc*(删掉frpc、frpc.ini两个文件)rm -rf frpc* 1234#编辑frps.ini[common]bind_port = 7000 #与客户端绑定的进行通信的端口vhost_http_port = 6081 #访问客户端web服务自定义的端口号,可以直接定义为80端口 123#启动服务./frps -c ./frps.ini # 前台启动nohup ./frps -c frps.ini &gt; ./temp/print.out 2&gt;&amp;1 &amp; #后台启动命令，并输出日志到print.out 这个地方要提前创建好文件路径 客户端首先删掉frps、frps.ini两个文件,然后再进行配置,然后编辑frpc.ini 1234567891011121314151617[common]server_addr = 120.56.37.48 #公网服务器ipserver_port = 7000 #与服务端bind_port一致##公网通过ssh访问内部服务器[ssh]type = tcp #连接协议local_ip = 192.168.2.62 #内网服务器iplocal_port = 22 #ssh默认端口号remote_port = 6000 #自定义的访问内部ssh端口号## 公网访问内部web服务器以http方式[web]type = http #访问协议local_ip = 192.168.2.62local_port = 8081 #内网web服务的端口号custom_domains = repo.iwi.com #所绑定的公网服务器域名，一级、二级域名都可以]]></content>
      <categories>
        <category>软件安装</category>
        <category>frp</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>frp</tag>
        <tag>内网映射</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键]]></title>
    <url>%2F2019%2F02%2F19%2FIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[高频使用 Ctrl+Shift+Enter : 语句填补（获取建议里面的第一条补全）Ctrl+Shift+Space:代码提示输入Ctrl+E :打开最近打开的文档、对话框（TODO、Structure等等）Shift+Click :（左键点击标签可以关闭当前文件）Ctrl+[ or ]:可跳转到大括号的开始和结束Ctrl+F12 :打开当前文档的文档结构Ctrl+N:快速打开类Ctrl+Shift+N:快速打开文件Ctrl+Shift+Insert,Ctrl+Shift+V:选择剪切板并快速插入Alt+Insert:可以生成构造器Getter/Setter等 Ctrl+Alt+T: 代码块使用代码包裹起来，例如：try/catchAlt+Enter:导入包，选择修正（需要在异常的对象后面使用该快捷键）Ctrl+Alt+L:当前整个文档格式化代码Ctrl+Alt+I:选中代码格式化Shift+F6:重构-重命名文件（类、jsp、js等等）Ctrl+Shift+UP/DOWN,Alt+Shift+UP/DOWN:选中代码向上或向下移动一行Ctrl+X:删除光标所在当前行Ctrl+Y:删除选中行Ctrl+D:复制光标所在行Ctrl+/orCtrl+Shift+/:注释选中代码或者光标所在当前行 Alt+left/right:切换代码视图 Alt+up/down:在方法间快速切换 F2 or Shift+F2:代码异常快速定位位置Alt+F8:计算变量值 Ctrl+B/Ctrl+Click:快速打开光标处的类或方法（跳转到定义处）Ctrl+O:Overrider:重写Ctrl+Shift+J:整合两行Ctrl+Shift+U:大小写转化Ctrl+Alt+S:打开设置对话框 Alt+Shift+Inert:开启/关闭列选择模式 Ctrl+BackSpace:按单词删除 查找/替换 Ctrl+R:替换文本Ctrl+F:查找文本F3: 查找时，跳转到下一个Shift+F3:查找时，跳转到上一个Ctrl+Shift+F:指定路径下全文搜索Ctrl+Shift+R:指定路径下全文替换Alt+F1:查找代码所在位置Ctrl+Alt+left/right:代码浏览的位置切换Ctrl+Shift+BackSpace:返回到上次编辑的位置Ctrl+Alt+Up/Down:快速跳转搜索结果 Ctrl+G:定位行 调试/运行 Ctrl+F2:停止Alt+Shift+F9:选择Debug模式启动Alt+Shift+F10:选择Run模式启动Ctrl+Shift+F9:编译Ctrl+Shift+F10:运行Ctrl+Shift+F8:查看断点F8:步进F9:恢复程序，直到下一个断点，如果没有断点，直接运行完成Alt+F9:运行至光标处Ctrl+Alt+F9:强制运行至光标处 代码提交 Ctrl+K:打开代码提交界面：Commit ChangesCtrl+T:更新（Update Project） 较少使用 Ctrl+F7 :当前选中元素在当前文件中的引用，按F3可以在找到的多个引用元素间跳转Alt+Q:快速查看当前方法的声明Ctrl+Alt+O:优化导入的类和包Ctrl+Shift+Alt+N:查找类中的方法或变量Ctrl+J:自动代码（例如：serr）Ctrl+Alt+J:用动态模板环绕Ctrl+H:显示类结构图（类的继承层次）Ctrl+Q:显示注释文档Tab:代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7:高亮显示所有该文本，按 Esc 高亮消失，类似选中文本然后Ctrl+FAlt+F3:逐个往下查找相同文本，并高亮显示Ctrl+Up/Down:光标中转到第一行或最后一行下Ctrl+Alt+Space:类名自动完成Shift+Esc:不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12:把焦点从编辑器移到最近使用的工具窗口Alt+Home:跳转到导航栏Ctrl+”+/-”:(小键盘数字)当前方法展开、折叠Ctrl+Shift+”+/-”:(小键盘数字)全部展开、折叠Ctrl+Enter:上插一行Alt+1:项目Alt+2:收藏Alt+6:TODOAlt+7:结构Ctrl+Alt+Shift+C:复制引用，必须选择类名Shift+F12:还原默认布局 不生效Ctrl+Shift+S:搜索结构Ctrl+Shift+M:替换结构]]></content>
      <categories>
        <category>办公知识</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>快捷键</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA安装免重启服务生效配置的插件]]></title>
    <url>%2F2019%2F02%2F19%2FIDEA%E5%AE%89%E8%A3%85%E5%85%8D%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%95%88%E9%85%8D%E7%BD%AE%E7%9A%84%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前开发过程中总是修改完xml、添加类、方法的时候，重启Tomcat服务，今天有同事提到了一个插件，可以在不用重启Tomcat的时候，就能完成部署操作，这个插件叫JreBel，具体的安装步骤和操作方法如下 下载插件和破解的相关资料链接：https://pan.baidu.com/s/12sU2m7pfE4qVk1EDg98uLg提取码：79an百度网盘路径：我的网盘&gt;安装文件&gt;IDE&gt;IDEA&gt;服务免重启插件 安装 点击File找到Settings 打开Settings,找到Plugins 点击Install from disk，打开选择本地插件选择的对话框 选择刚刚从百度云上下载的插件 选择本地的文件 安装完成后显示如下，需要重启下IDEA才能生效 激活 按照图示将地址和账号输入进去，选择I Agree，点击激活，激活完成后会弹出如下图效果 设置激活完成之后，还需要设置离线可用操作，具体操作方法见下图所示： 使用]]></content>
      <categories>
        <category>软件安装</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>插件安装</tag>
        <tag>服务免重启</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer知识点]]></title>
    <url>%2F2019%2F02%2F19%2FSQLServer%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[RTRIM是去除第一个参数中的第二个参数的元素 ，第二个参数不填的话，默认为空格例：去掉FIRSTNAME字段中的空格，RTRIM（FIRSTNAME），RTRIM一般用在计算字段的长度时使用，例如计算FIRSTNAME的长度的SQL是 SELECT FIRSTNAME,LENGTH(RTRIM(FIRSTNAME)) FROM CHARACTERS TO_CHAR将其他数据类型转换为字符型]]></content>
      <categories>
        <category>数据库</category>
        <category>SQLServer</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>数据库</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle SQL性能优化]]></title>
    <url>%2F2019%2F02%2F19%2FOracle-SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Oracle SQL查询对于大数据量的查询，通常会因为一些SQL编写上不规范造成效率低的问题，比如在查询中使用START WITH 造成分页的时候，拼接外部，从而改变内部执行策略，本来3S能执行完的SQL，到最后执行了20S+，因此Copy了这篇文章大家看看 SQL语句的执行顺序语法分析&gt; 语义分析&gt; 视图转换 &gt;表达式转换&gt; 选择优化器 &gt;选择连接方式 &gt;选择连接顺序 &gt;选择数据的搜索路径 &gt;运行“执行计划” 选择适合的Oracle优化器RULE（基于规则） COST（基于成本） CHOOSE（选择性） 访问TABLE的方式全表扫描 全表扫描就是顺序地访问表中每条记录，ORACLE采用一次读入多个数据块(database block)的方式优化全表扫描 通过ROWID访问表 ROWID包含了表中记录的物理位置信息，ORACLE采用索引实现了数据和存放数据的物理位置(ROWID)之间的联系，通常索引提供了快速访问ROWID的方法，因此那些基于索引列的查询就可以得到性能上的提高 共享 SQL 语句 Oracle提供对执行过的SQL语句进行高速缓冲的机制。被解析过并且确定了执行路径的SQL语句存放在SGA的共享池中 Oracle执行一个SQL语句之前每次先从SGA共享池中查找是否有缓冲的SQL语句，如果有则直接执行该SQL语句 可以通过适当调整SGA共享池大小来达到提高Oracle执行性能的目的 选择最有效率的表名顺序 ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，因此FROM子句中写在最后的表(基础表 driving table)将被最先处理 当ORACLE处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表(FROM子句中最后的那个表)并对记录进行排序，然后扫描第二个表(FROM子句中最后第二个表)，最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并 只在基于规则的优化器中有效 简单来说，就是把数据多的放在左侧，数据少的放在右侧（描述有待大家考证） 举例： 表 TAB1 16,384 条记录 表 TAB2 1 条记录 12345 /*选择TAB2作为基础表 (最好的方法)*/select count(*) from tab1,tab2 执行时间0.96秒 /*选择TAB2作为基础表 (不佳的方法)*/select count(*) from tab2,tab1 执行时间26.09秒 如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。 EMP:交叉表，包含LOCATION和CATEGORY的关联关系 1234SELECT * FROM LOCATION L, CATEGORY C, EMP EWHERE E.EMP_NO BETWEEN 1000 AND 2000 AND E.CAT_NO = C.CAT_NO AND E.LOCN = L.LOCN 将比下列SQL更有效率 1234SELECT * FROM EMP E, LOCATION L, CATEGORY CWHERE E.CAT_NO = C.CAT_NO AND E.LOCN = L.LOCN AND E.EMP_NO BETWEEN 1000 AND 2000 Where子句中的连接顺序Oracle采用自下而上的顺序解析WHERE子句。 根据这个原理,表之间的连接必须写在其他WHERE条件之前，那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾 1234567/*低效,执行时间156.3秒*/SELECT … FROM EMP EWHERE SAL &gt; 50000 AND JOB = ‘MANAGER’ AND 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR = E.EMPNO) 1234567/*高效,执行时间10.6秒*/SELECT … FROM EMP EWHERE 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR=E.EMPNO) AND SAL &gt; 50000 AND JOB = ‘MANAGER’ SELECT子句中避免使用“*” Oracle在解析SQL语句的时候，对于“*”将通过查询数据库字典来将其转换成对应的列名。 如果在Select子句中需要列出所有的Column时，建议列出所有的Column名称，而不是简单的用“*”来替代，这样可以减少多于的数据库查询开销 减少访问数据库的次数当执行每条SQL语句时, ORACLE在内部执行了许多工作： 解析SQL语句 &gt; 估算索引的利用率 &gt; 绑定变量 &gt; 读数据块等等 由此可见, 减少访问数据库的次数 , 就能实际上减少ORACLE的工作量 整个简单无关联的数据库访问如果有几个简单的数据库查询语句，你可以把它们整合到一个查询中（即使它们之间没有关系），以减少多于的数据库IO开销。 虽然采取这种方法，效率得到提高，但是程序的可读性大大降低，所以还是要权衡之间的利弊 使用Truncate而非Delete Delete表中记录的时候，Oracle会在Rollback段中保存删除信息以备恢复。Truncate删除表中记录的时候不保存删除信息，不能恢复。因此Truncate删除记录比Delete快，而且占用资源少 删除表中记录的时候，如果不需要恢复的情况之下应该尽量使用Truncate而不是Delete Truncate仅适用于删除全表的记录 尽量多使用COMMIT只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少 COMMIT所释放的资源： 回滚段上用于恢复数据的信息 被程序语句获得的锁 redo log buffer 中的空间 ORACLE为管理上述3种资源中的内部花费 计算记录条数123Select count(*) from tablename;Select count(1) from tablename;Select max(rownum) from tablename; 一般认为，在没有索引的情况之下，第一种方式最快。 如果有索引列，使用索引列当然最快 用Where子句替换Having子句避免使用HAVING子句，HAVING 只会在检索出所有记录之后才对结果集进行过滤。这个处理需要排序、总计等操作。 如果能通过WHERE子句限制记录的数目，就能减少这方面的开销 减少对表的查询操作在含有子查询的SQL语句中，要注意减少对表的查询操作 12345678/*低效的查询方式*/SELECT TAB_NAME FROM TABLESWHERE TAB_NAME =（SELECT TAB_NAME FROM TAB_COLUMNS WHERE VERSION = 604） AND DB_VER =（SELECT DB_VER FROM TAB_COLUMNS WHERE VERSION = 604） 12345SELECT TAB_NAME FROM TABLESWHERE （TAB_NAME，DB_VER）= （SELECT TAB_NAME，DB_VER FROM TAB_COLUMNS WHERE VERSION = 604） 使用表的别名（Alias）当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。 Column歧义指的是由于SQL中不同的表具有相同的Column名,当SQL语句中出现这个Column时,SQL解析器无法判断这个Column的归属。 用EXISTS替代IN在许多基于基础表的查询中，为了满足一个条件 ，往往需要对另一个表进行联接。在这种情况下，使用EXISTS(或NOT EXISTS)通常将提高查询的效率 123456/*低效*/SELECT * FROM EMP (基础表)WHERE EMPNO &gt; 0 AND DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB’) 1234567/*高效*/SELECT * FROM EMP (基础表)WHERE EMPNO &gt; 0 AND EXISTS (SELECT ‘X’ FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB’) 用NOT EXISTS替代NOT IN在子查询中，NOT IN子句将执行一个内部的排序和合并，对子查询中的表执行一个全表遍历，因此是非常低效的。 为了避免使用NOT IN，可以把它改写成外连接（Outer Joins）或者NOT EXISTS。 123456/*低效*/SELECT … FROM EMPWHERE DEPT_NO NOT IN （SELECT DEPT_NO FROM DEPT WHERE DEPT_CAT=’A’） 1234567/*高效*/SELECT …. FROM EMP EWHERE NOT EXISTS （SELECT ‘X’ FROM DEPT D WHERE D.DEPT_NO = E.DEPT_NO AND DEPT_CAT = ‘A’） 用表连接替换EXISTS通常来说 ，采用表连接的方式比EXISTS更有效率 。 1234567/*低效*/SELECT ENAME FROM EMP EWHERE EXISTS （SELECT ‘X’ FROM DEPT WHERE DEPT_NO = E.DEPT_NO AND DEPT_CAT = ‘A’） 12345/*高效*/SELECT ENAME FROM DEPT D，EMP EWHERE E.DEPT_NO = D.DEPT_NO AND DEPT_CAT = ‘A’ 用EXISTS替换DISTINCT当提交一个包含对多表信息（比如部门表和雇员表）的查询时，避免在SELECT子句中使用DISTINCT。 一般可以考虑用EXIST替换。 EXISTS 使查询更为迅速，因为RDBMS核心模块将在子查询的条件一旦满足后，立刻返回结果 1234/*低效*/SELECT DISTINCT DEPT_NO，DEPT_NAME FROM DEPT D，EMP E WHERE D.DEPT_NO = E.DEPT_NO 123456/*高效*/SELECT DEPT_NO，DEPT_NAME FROM DEPT D WHERE EXISTS （SELECT ‘X’ FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO 识别低效的SQL语句下面的SQL工具可以找出低效SQL 123456789SELECT EXECUTIONS, DISK_READS, BUFFER_GETS, ROUND ((BUFFER_GETS-DISK_READS)/BUFFER_GETS, 2) Hit_radio, ROUND (DISK_READS/EXECUTIONS, 2) Reads_per_run, SQL_TEXTFROM V$SQLAREAWHERE EXECUTIONS&gt;0AND BUFFER_GETS &gt; 0AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8ORDER BY 4 DESC 另外也可以使用SQL Trace工具来收集正在执行的SQL的性能状态数据，包括解析次数，执行次数，CPU使用时间等 用Explain Plan分析SQL语句EXPLAIN PLAN 是一个很好的分析SQL语句的工具, 它甚至可以在不执行SQL的情况下分析语句. 通过分析, 我们就可以知道ORACLE是怎么样连接表, 使用什么方式扫描表(索引扫描或全表扫描)以及使用到的索引名称 SQL PLUS的TRACE1234567891011121314SQL&gt; list SELECT * FROM dept, emp 3* WHERE emp.deptno = dept.deptnoSQL&gt; set autotrace traceonly /*traceonly 可以不显示执行结果*/SQL&gt; /rows selected.Execution Plan---------------------------------------------------------- SELECT STATEMENT Optimizer=CHOOSE 0 NESTED LOOPS 1 TABLE ACCESS (FULL) OF 'EMP' 1 TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' 3 INDEX (UNIQUE SCAN) OF 'PK_DEPT' (UNIQUE) 用索引提高效率 特点 优点：提高效率 主键的唯一性验证 代价：需要空间存储 定期维护 重构索引： 1ALTER INDEX &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt; Oracle对索引的两种访问模式 索引唯一扫描 (Index Unique Scan) 索引范围扫描 (Index Range Scan) 基础表的选择 基础表(Driving Table)是指被最先访问的表(通常以全表扫描的方式被访问)。 根据优化器的不同，SQL语句中基础表的选择是不一样的 如果你使用的是CBO (COST BASED OPTIMIZER)，优化器会检查SQL语句中的每个表的物理大小，索引的状态，然后选用花费最低的执行路径 如果你用RBO (RULE BASED OPTIMIZER)， 并且所有的连接条件都有索引对应，在这种情况下，基础表就是FROM 子句中列在最后的那个表 多个平等索引 当SQL语句的执行路径可以使用分布在多个表上的多个索引时，ORACLE会同时使用多个索引并在运行时对它们的记录进行合并，检索出仅对全部索引有效的记录 在ORACLE选择执行路径时，唯一性索引的等级高于非唯一性索引。然而这个规则只有当WHERE子句中索引列和常量比较才有效。如果索引列和其他表的索引类相比较。这种子句在优化器中的等级是非常低的 如果不同表中两个相同等级的索引将被引用，FROM子句中表的顺序将决定哪个会被率先使用。 FROM子句中最后的表的索引将有最高的优先级 如果相同表中两个相同等级的索引将被引用，WHERE子句中最先被引用的索引将有最高的优先级 等式比较优先于范围比较 DEPTNO上有一个非唯一性索引，EMP_CAT也有一个非唯一性索引 1234SELECT ENAME FROM EMP WHERE DEPTNO &gt; 20 AND EMP_CAT = ‘A’; 这里只有EMP_CAT索引被用到,然后所有的记录将逐条与DEPTNO条件进行比较. 执行路径如下: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON CAT_IDX 即使是唯一性索引，如果做范围比较，其优先级也低于非唯一性索引的等式比较 不明确的索引等级 当ORACLE无法判断索引的等级高低差别，优化器将只使用一个索引,它就是在WHERE子句中被列在最前面的 DEPTNO上有一个非唯一性索引，EMP_CAT也有一个非唯一性索引 1234SELECT ENAME FROM EMP WHERE DEPTNO &gt; 20 AND EMP_CAT &gt; ‘A’; 这里, ORACLE只用到了DEPT_NO索引. 执行路径如下: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON DEPT_IDX 强制索引失效 如果两个或以上索引具有相同的等级，你可以强制命令ORACLE优化器使用其中的一个(通过它,检索出的记录数量少) 。 12345SELECT ENAMEFROM EMPWHERE EMPNO = 7935 AND DEPTNO + 0 = 10 /*DEPTNO上的索引将失效*/AND EMP_TYPE || ‘’ = ‘A’ /*EMP_TYPE上的索引将失效*/ 避免在索引上使用计算 WHERE子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描 自动选择索引 如果表中有两个以上（包括两个）索引，其中有一个唯一性索引，而其他是非唯一性索引。在这种情况下，ORACLE将使用唯一性索引而完全忽略非唯一性索引 1234SELECT ENAME FROM EMPWHERE EMPNO = 2326 AND DEPTNO = 20 ; 这里，只有EMPNO上的索引是唯一性的，所以EMPNO索引将用来检索记录。 TABLE ACCESS BY ROWID ON EMP INDEX UNIQUE SCAN ON EMP_NO_IDX 避免在索引上使用NOT 通常，我们要避免在索引列上使用NOT，NOT会产生在和在索引列上使用函数相同的影响。当ORACLE遇到NOT，它就会停止使用索引转而执行全表扫描 1234/*低效*/ SELECT … FROM DEPT WHERE NOT DEPT_CODE = 0 用&gt;=代替&gt; 如果DEPTNO上有一个索引 1234/*高效*/SELECT * FROM EMP WHERE DEPTNO &gt;=4 两者的区别在于，前者DBMS将直接跳到第一个DEPT等于4的记录，而后者将首先定位到DEPTNO等于3的记录并且向前扫描到第一个DEPT大于3的记录. 用Union替换OR（适用于索引列）通常情况下，用UNION替换WHERE子句中的OR将会起到较好的效果。对索引列使用OR将造成全表扫描。 注意，以上规则只针对多个索引列有效 12345678/*高效*/SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 UNION SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE REGION = “MELBOURNE” 1234/*低效*/SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 用IN替换OR123456/*低效*/SELECT…. FROM LOCATIONWHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 123SELECT… FROM LOCATIONWHERE LOC_IN IN （10，20，30） 实际的执行效果还须检验，在ORACLE8i下， 两者的执行路径似乎是相同的 避免在索引上使用IS NULL 和IS NOT NULL避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引 1234/*低效*/SELECT … FROM DEPARTMENTWHERE DEPT_CODE IS NOT NULL; 1234/*高效*/SELECT … FROM DEPARTMENTWHERE DEPT_CODE &gt;=0; 总是使用索引的第一列如果索引是建立在多个列上， 只有在它的第一个列(leading column)被where子句引用时， 优化器才会选择使用该索引。 12345678SQL&gt; create index multindex on multiindexusage(inda,indb);Index created.SQL&gt; select * from multiindexusage where indb = 1;Execution Plan---------------------------------------------------------- SELECT STATEMENT Optimizer=CHOOSE 0 TABLE ACCESS (FULL) OF 'MULTIINDEXUSAGE' 很明显, 当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引。 使用UNION ALL替换UNION当SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION-ALL的方式被合并，然后在输出最终结果前进行排序。如果用UNION ALL替代UNION，这样排序就不是必要了，效率就会因此得到提高。 由于UNION ALL的结果没有经过排序，而且不过滤重复的记录，因此是否进行替换需要根据业务需求而定。 对UNION的优化由于UNION会对查询结果进行排序，而且过滤重复记录，因此其执行效率没有UNION ALL高。 UNION操作会使用到SORT_AREA_SIZE内存块，因此对这块内存的优化也非常重要。 可以使用下面的SQL来查询排序的消耗量 ： 1234select substr（name，1，25） "Sort Area Name"， substr（value，1，15） "Value"from v$sysstatwhere name like 'sort%' 避免改变索引列的类型当比较不同数据类型的数据时， ORACLE自动对列进行简单的类型转换。 123456789/*假设EMP_TYPE是一个字符类型的索引列.*/SELECT … FROM EMP WHERE EMP_TYPE = 123/*这个语句被ORACLE转换为:*/SELECT … FROM EMP WHERE TO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换，这个索引将不会被用到 几点注意： 当比较不同数据类型的数据时，ORACLE自动对列进行简单的类型转换 如果在索引列上面进行了隐式类型转换，在查询的时候将不会用到索引 注意当字符和数值比较时，ORACLE会优先转换数值类型到字符类型 为了避免ORACLE对SQL进行隐式的类型转换，最好把类型转换用显式表现出来 几种不能使用索引的WHERE子句 下面的例子中，‘!=’ 将不使用索引 ，索引只能告诉你什么存在于表中，而不能告诉你什么不存在于表中 1234/*不使用索引*/SELECT ACCOUNT_NAME FROM TRANSACTION WHERE AMOUNT !=0； 1234/*使用索引*/SELECT ACCOUNT_NAME FROM TRANSACTION WHERE AMOUNT &gt; 0； 下面的例子中，‘||’是字符连接函数。就象其他函数那样，停用了索引 1234/*不使用索引*/SELECT ACCOUNT_NAME，AMOUNT FROM TRANSACTIONWHERE ACCOUNT_NAME||ACCOUNT_TYPE=’AMEXA’； 12345/*使用索引*/SELECT ACCOUNT_NAME，AMOUNT FROM TRANSACTIONWHERE ACCOUNT_NAME = ‘AMEX’ AND ACCOUNT_TYPE=’ A’； 下面的例子中，‘+’是数学函数。就象其他数学函数那样，停用了索引。 1234/*不使用索引*/SELECT ACCOUNT_NAME，AMOUNT FROM TRANSACTIONWHERE AMOUNT + 3000 &gt;5000； 1234/*使用索引*/SELECT ACCOUNT_NAME，AMOUNTFROM TRANSACTIONWHERE AMOUNT &gt; 2000 ； 下面的例子中，相同的索引列不能互相比较，这将会启用全表扫描 1234/*不使用索引*/SELECT ACCOUNT_NAME, AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME = NVL(:ACC_NAME, ACCOUNT_NAME) 1234/*使用索引*/SELECT ACCOUNT_NAME，AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME LIKE NVL(:ACC_NAME, ’%’) 连接多个扫描如果对一个列和一组有限的值进行比较，优化器可能执行多次扫描并对结果进行合并连接 举例： 123SELECT * FROM LODGING WHERE MANAGER IN (‘BILL GATES’, ’KEN MULLER’) 优化器可能将它转换成以下形式： 1234SELECT * FROM LODGING WHERE MANAGER = ‘BILL GATES’ OR MANAGER = ’KEN MULLER’ CBO下使用更具选择性的索引 基于成本的优化器（CBO，Cost-Based Optimizer）对索引的选择性进行判断来决定索引的使用是否能提高效率 如果检索数据量超过30%的表中记录数，使用索引将没有显著的效率提高 在特定情况下，使用索引也许会比全表扫描慢。而通常情况下，使用索引比全表扫描要块几倍乃至几千倍 避免使用耗费资源的操作 带有DISTINCT，UNION，MINUS，INTERSECT，ORDER BY的SQL语句会启动SQL引擎执行耗费资源的排序（SORT）功能。DISTINCT需要一次排序操作，而其他的至少需要执行两次排序 通常，带有UNION，MINUS，INTERSECT的SQL语句都可以用其他方式重写 优化GROUP BY提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉 123456 /*低效*/ SELECT JOB ，AVG（SAL） FROM EMP GROUP BY JOBHAVING JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ 123456/*高效*/SELECT JOB，AVG（SAL） FROM EMPWHERE JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’GROUP BY JOB 使用日期当使用日期时，需要注意如果有超过5位小数加到日期上，这个日期会进到下一天 123456789SELECT TO_DATE（‘01-JAN-93’+.99999） FROM DUALReturns：’01-JAN-93 23:59:59’SELECT TO_DATE（‘01-JAN-93’+.999999） FROM DUALReturns：’02-JAN-93 00:00:00’ 使用显示游标（CURSORS）使用隐式的游标，将会执行两次操作。第一次检索记录，第二次检查TOO MANY ROWS 这个exception。而显式游标不执行第二次操作。 分离表和索引 总是将你的表和索引建立在不同的表空间内（TABLESPACES） 决不要将不属于ORACLE内部系统的对象存放到SYSTEM表空间里 确保数据表空间和索引表空间置于不同的硬盘上]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>性能优化</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle知识点]]></title>
    <url>%2F2019%2F02%2F19%2FOracle%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Oracle分组拼接函数123SELECT LISTAGG(ID, ’, ’) WITHIN GROUP(ORDER BY DEPON) FROM TEST_1 GROUP BY DEPON 注意：分组拼接函数在Oracle11g之前是没有的 Sql函数 Oracle中的日期时间函数：在Oracle中以字符串表示的数据是不能自动转换为日期时间类型的，必须使用TO_DATE()函数来手动将字符串转换为日期时间类型，比如 TO_DATE(‘2010-10-10’,’YYYY-MM-DD HH24:MI:SS’)。 Oracle取得系统当前时间：Oracle中没有提供取得当前日期时间的函数，不过我们可以到系统表DUAL中查询SYSTIMESTAMP的值来得到当前的时间戳。如下： 12345Select SYSTIMESTAMPFrom DUAL同样我们可以到系统表DUAL中查询SYSDATE的值来得到当前日期时间。如下：Select SYSDATEFrom DUAL 使用TO_CHAR(时间日期值，’YYYY-MM-DD’)可以得到日期时间值的日期部分，因此下面的SQL语句可以得到当前的日期值： 12Select TO_CHAR(SYSDATE,’YYYY-MM-DD’)From DUAL 日期增减：有时我们需要在一个日期的基础上增加某个时间长度或者减去某个时间长度，比如我们知道每个员工的出生日期，而想计算出他出生后10000 天的日期，再如我们想计算所有合同的到期日的三月后的日期。Oracle中可以直接使用加号“+”来进行日期的加法计算，其计算单位为“天”，比如date+3就表示在日期date的基础上增加三天；同理使用减号“-”则可以用来计算日期前的特定时间段的时间，比如date-3就表示在日期date的三天前的日期。比如下面的sql语句用于计算每个人出生日期3天后以及10天前的日期； 1234Select FBirthDay，FBirthDay+3，FBirthDay-10From T_Person Oracle中提供了ADD_MONTHS()函数用于以月为单位的日期增减运算，ADD_MONTHS()函数的参数格式如下：ADD_MONTHS(date，number) 其中参数date为待计算的日期，参数number为要增加的月份数，如果number为负数则表示进行日期的减运算。下面的SQL语句用于计算每个人的出生日期两个月后以及10个月前的日期： 1234Select FBirthDay,ADD_MONTHS(FBirthDay,2),ADD_MONTHS(FBirthDay,-10)From T_Person 计算日期差额：在Oracle中，可以在两个日期类型的数据之间使用减号运算符“-”，其计算结果为两个日期之间的天数差。比如执行下面的SQL语句用于计算注册日期FRegDay和出生日期FBirthDay之间的时间间隔： 12Select FRegDay,FBirthDay,FRegDay – FbirthDayFrom T_Person 计算一个日期是星期几：Oracle中提供了TO_CHAR（）函数用于将数据转换为字符串类型，当针对时间日期类型数据进行转换的时候，它接受两个参数，其参数格式如下：TO_CHAR(date,format)其中参数date为待转换的日期，参数format为格式化字符串，数据库系统将按照这个字符串对date进行转换。如下是以2008-08-08这样的形式显示出生日期： 123Select FBirthDay，TO_CHAR(FbirthDay，’YYYY-MM-DD’) as 出生日期From TPerson 取得日期的指定部分：提取日期的特定不是非常有必要的，比如检索本年的每个月的16日的销售量、检索访问用户集中的时间段，这些都需要对日期的特定部分进行提取。使用TO_CHAR()函数就可以提取日期的任意部分，比如下面的SQL用于提取每个人员的出生年份、出生时是当年的第几天、出生时是当年的第几周： 123456SelectFBirthDay,TO_CHAR(FBirthDay,’YYYY’) AS y,TO_CHAR(FBirthDay,’DDD’) AS d,TO_CHAR(FBirthDay,’WW’) AS uFrom T_Person 类型转换：在使用SQL语句的时候，我们使用的数据的类型不一定符合函数或者运算符的需要，比如函数需要整数类型的数据而我们使用的则是一个字符串，在一些情况下数据库系统会替我们自动将字符串类型转换为整数类型，这种转换称为隐式转换。但是在有的情况下数据库系统不会进行隐式转换，这时就要使用类型转换函数了，这种转换称为显式转换。使用类型转换函数不仅可以保证类型转换的正确性，而且可以提高数据处理的速度，因此应该使用显式转换，尽量避免使用隐式转换。Oracle提供了针对TO_CHAR()、TO_DATE()、TO_NUMBER()等函数，这些函数可以将数据显示的转换为字符串类型、日期时间类型或者数值类型。Oracle中还提供了HEXTORAW()、RAWTOHEX()、TO_MULTI_BYTE()、TO_SINGLE_BYTE()等函数用于存储格式的转换。1） TO_CHAR()TO_CHAR()函数用来将时间日期类型或者数值类型的数据转换为字符串，其参数格式如下：TO_CHAR(expression，format)，参数expression为待转换的表达式，参数format为转换后的字符串格式，参数format可以省略，如果省略参数format将会按照数据库系统内置的转换规则进行转换。2） TO_DATE()函数用来将字符串转换为时间类型，其参数格式如下：TO_DATE(expression，format)，参数expression为待转换的表达式，参数format为转换格式，参数format可以省略，如果省略参数format将会按照数据库系统内置的转换规则进行转换。下面的SQL语句用于将字符串形式的数据按照特定的格式解析为日期类型： 1234SelectTO_DATE('2008-08-08 08:09:10', 'YYYY-MM-DD HH24:MI:SS') as dt1,TO_DATE('20080808 080910', 'YYYYMMDD HH24MISS') as dt2From DUAL TO_NUMBER()函数用法类似3） HEXTORAW()、RAWTOHEX()：HEXTORAW()用于将十六进制格式的数据转换为原始值，而RAWTOHEX()函数用来将原始值转换为十六进制格式的数据4） TO_MULTI_BYTE()、TO_SINGLE_BYTE()：TO_MULTI_BYTE()函数用于将字符串中的半角字符转换为全角字符，而TO_SINGLE_BYTE()`函数则用来将字符串中的全角字符转换为半角字符。 空值处理：主流数据库系统都支持COLAESCE()函数，这个函数主要用来进行空值处理，其参数格式如下：COLAESCE(expression，valuel,value2……,valuen)COLAESEC()函数的第一个参数expression为待检测的表达式，而其后的参数个数不定。COLAESEC()函数将会返回包括expression在内的所有参数中的第一个非空表达式。如果expression不为空值则返回expression；否则不、判断value1是否是空值，如果value1不为空值则返回value1；否则判断value2是否是空值，如果value2不为空值则返回value3；……以此类推，如果所有的表达式都为空值，则返回NULL。Oracle中NVL(expression1,expression2)函数将NULL转变为实际值，如果expression1不为NULL则返回expression1，若为NULL则返回expression2，两个表达式可以是任意数据类型，但两个表达式的数据类型必须一致。而函数NVL2(expr1,expr2,expr3)，如果expr1不是NULL，则返回expr2；如果expr1是NULL，则返回expr3。参数expr1可以是任意数据类型，而expr2和expr3可以是除LONG类型之外的任何数据类型，但三者的数据类型必须保持一致。 自动增长字段：在Oracle中可以通过SEQUENCE序列来实现自动增长字段，在Oracle中SEQUENCE被称为序列，每次取的时候它会自动增加，一般用在需要按序列号排序的地方。在使用SEQUENCE前需要首先定义一个SEQUENCE，定义SEQUENCE的语法如下： 123CREATE SEQUENCE sequence_nameINCREMENT BY stepSTART WITH startvalue; 其中sequence_name 为序列的名字，每个序列都必须有唯一的名字；startvalue 参数值为起始数字，step 参数值为步长，即每次自动增长时增加的值。一旦定义了SEQUENCE，你就可以用CURRVAL来取得SEQUENCE的当前值，也可以通过NEXTVAL来增加SEQUENCE，然后返回 新的SEQUENCE值。比如： 12sequence_name.CURRVALsequence_name.NEXTVAL 如果SEQUENCE不需要的话就可以将其删除：DROP SEQUENCE sequence_name; ORACLE中的分析函数（即开窗函数） 按照FSALARY进行排序，ROWS 按照行数进行范围定位; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM T_PERSON; 按照FSALARY进行排序，RANGE 按照FSALARY值范围进行定位; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM T_PERSON; 按照FSALARY进行排序，计算从当前行的前两行与当前行的后两行的和; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) FROM T_PERSON; 按照FSALARY进行排序，计算从当前行的后一行到当前行的后三行的和，注意：最后一行没有后续行，其计算结果为空值NULL而非0; 1234SELECT FNAME, FAGE, SUM(FSALARY) OVER(ORDER BY FSALARY ROWS BETWEEN 1 FOLLOWING AND 3 FOLLOWING) FROM T_PERSON; Oracle中的聚合函数MAX() 该函数用于取得列或表达式的最大值，它适用于任何数据类型；MIN() 该函数用于取得列或表达式的最小值，它适用于任何数据类型；AVG() 该函数用于取得列或表达式的平均值，它适用于任何数据类型；SUM() 该函数用于取得列或表达式的总和，它适用于任何数据类型；COUNT() 该函数用于取得总计行数；VARIANCE() 该函数用于取得列或表达式的方差，并且该函数只适用于数字类型。当只有一行数据时，其值返回为0；当存在多行数据时，方差是按照如下公式计算取得：(SUM(EXPR)2-SUM(EXPR)2/COUNT(EXPR))/(COUNT(EXPR)-1);STDDEV() 该函数用于取得列或表达式的标准偏差，并且该函数只适用于数字类型。当只有一行数据时，其值返回为0；当存在多行数据时，Oracle按照方差的平方根来计算标准偏差。 创建表空间12CREATE TABLESPACE USER_IRS_SPACE DATAFILE'D:\oracle\product\10.1.0\oradata\orcl\USER_IRS_TBS_temp01.dbf'SIZE 500M AUTOEXTEND ON NEXT 50MCREATE TABLESPACE USER_IRS_TBS DATAFILE 'D:\oracle\product\10.1.0\oradata\orcl\USER_IRS_TBS_temp01.dbf'size 500M autoextend on next 50M 备份数据库 如果所有数据都对，但是就是倒不出来的话，可以看下Oracle的基本服务是不是开了，例如Services服务是不是开了exp sgirs/sgirsdb@orcl file=&#39;D :\db.dmp&#39; 数据库导入imp sgirs/sgirsdb file=&#39;D:\dba.dmp&#39; ORACLE查询表死锁 查看锁表进程SQL语句1： 12345678910select sess.sid, sess.serial#, lo.oracle_username, lo.os_user_name, ao.object_name, lo.locked_mode from v$locked_object lo, dba_objects ao, v$session sesswhere ao.object_id = lo.object_id and lo.session_id = sess.sid; 查看锁表进程SQL语句2： 1select * from v$session t1, v$locked_object t2 where t1.sid = t2.SESSION_ID; 杀掉锁表进程如有記錄則表示有lock，記錄下SID和serial# ，將記錄的ID替換下面的738,1429，即可解除LOCK 1alter system kill session '738,1429';]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL对于大小写敏感问题的处理方式]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Linux上安装MySQL默认是数据库的表大小写敏感的。修改很简单，只要该一个mysql的配置文件就可以了。 修改配置文件my.cnf 编辑my.cnf文件 1vim /etc/my.cnf 添加lower_case_table_names=1，添加完成后的效果如下 12345[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockskip-grant-tableslower_case_table_names=1 重启数据库123[root@chicago init.d]# service mysql restartShutting down MySQL.. [ OK ]Starting MySQL...................................... [ OK ] 验证]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>大小写敏感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自动扣款存储过程Demo]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E8%87%AA%E5%8A%A8%E6%89%A3%E6%AC%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8BDemo%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CREATEPROCEDURE charge.seven_days_auto_pay()BEGIN#订单编号DECLARE orderId VARCHAR (32);#租户IDDECLARE tenantId VARCHAR (20);#用户充电金额DECLARE chargePrice DECIMAL (10,2);#用户余额DECLARE ownCoin DECIMAL(10,2);#充电记录IDDECLARE chargesId VARCHAR(500);#遍历数据结束标志DECLARE done INT DEFAULT FALSE;#Routine body goes here...DECLARE cur CURSOR FOR SELECT id,tenant_id,charge_priceFROM t_order INNER JOIN t_user_person ON userid = tenant_idWHERE t_order.create_time &lt; DATE_ADD(NOW(), INTERVAL - 7 DAY)AND order_state = 4AND del = 0#测试服务器上出现userid在t_user_person没有的情况AND charge_price &gt; 0 ORDER BY tenant_id;#将结束标志绑定到游标DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;OPEN cur;#开始循环read_loop:LOOP #提取游标中的数据 FETCH cur INTO orderId,tenantId,chargePrice;IF done THEN LEAVE read_loop;END IF;#使用事务START TRANSACTION;#获取一个订单的充电记录SELECT GROUP_CONCAT(id) INTO chargesId FROM t_charging WHERE order_id = orderId AND del = 0 AND valid = 0 GROUP BY order_id;#首先判断用户的余额是否大于订单金额SELECT charging_coins INTO ownCoin FROM t_user_person WHERE userid = tenantId LIMIT 1 FOR UPDATE;IF ownCoin &gt;= chargePrice THEN #处理订单表中的订单为已付款、充电币支付等 UPDATE t_order SET pay_time = NOW(),order_state=5,coins_flag=1,consume_coins = charge_price WHERE id = orderId AND order_state = 4; SELECT ROW_COUNT() INTO @rc; IF @rc = 0 THEN ROLLBACK; ITERATE read_loop; END IF; #处理用户表中充电币数据 UPDATE t_user_person SET charging_coins = (ownCoin-chargePrice) WHERE userid = tenantId AND deleted = 0; #处理t_pay表中的充电记录数据 INSERT INTO t_pay (id,order_id,pay_success,defray_time,charges,total_price,create_time,has_inqueue) VALUES (CONCAT('10',UNIX_TIMESTAMP()*10000,FLOOR(1000+RAND()*9000)),orderId,1,NOW(),chargesId,chargePrice,NOW(),0); #处理t_chargingcoins_pay_record中数据 INSERT INTO t_chargingcoins_pay_record (id,userid,pay_money,order_no,pay_time,create_time,remain_coins) VALUES(CONCAT('10',UNIX_TIMESTAMP()*10000,FLOOR(1000+RAND()*9000)),tenantId,chargePrice,orderId,NOW(),NOW(),(ownCoin-chargePrice)); #处理t_charging表中的充电记录数据 UPDATE t_charging SET pay_time = NOW(), pay_flag=2 WHERE order_id = orderId AND del = 0 AND valid = 0;END IF;COMMIT;END LOOP;CLOSE cur;END]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.1安装MySQL]]></title>
    <url>%2F2019%2F02%2F19%2FCentos7-1%E5%AE%89%E8%A3%85MySQL%2F</url>
    <content type="text"><![CDATA[安装MySQL12345# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm# rpm -ivh mysql-community-release-el7-5.noarch.rpm# yum install mysql-community-server安装成功后重启mysql服务。# service mysqld restart 登录MySQL1[root@yl-web yl]# mysql -u root 显示已有数据库1mysql&gt; show databases; 设置密码不需要重启数据库即可生效。1mysql&gt; set password for 'root'@'localhost' =password('password'); 修改配置文件配置Mysqlmysql配置文件为/etc/my.cnf 远程设置123456mysql&gt;create user 'username'@'%' identified by 'password'; //创建用户mysql&gt; grant all privileges on *.* to root@'%'identified by 'password';//把在所有数据库的所mysql&gt; flush privileges;# 有表的所有权限赋值给位于所有IP地址的root用户。# 查看mysql授权用户列表 select distinct contact('user:',user,'host:',host) from mysql.user; 开放服务器对应的3306端口号12firewall-cmd --add-port=3306/tcp --permanent //添加端口号firewall-cmd --reload //重新加载端口 其他设置mysql数据库不区分大小写 在/etc/mg.cnf的[msqld]节点下面增加lower_case_table_names=1然后重启mysql`数据库就可以了]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>MySQL</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中授权及撤销]]></title>
    <url>%2F2019%2F02%2F19%2Fmysql%E4%B8%AD%E6%8E%88%E6%9D%83%E5%8F%8A%E6%92%A4%E9%94%80%2F</url>
    <content type="text"><![CDATA[grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权力 12345grant select on testdb.* to common_user@'client_ip' identified by 'password';grant insert on testdb.* to common_user@'client_ip' identified by 'password';grant update on testdb.* to common_user@'client_ip' identified by 'password';grant delete on testdb.* to common_user@'client_ip' identified by 'password';grant select, insert, update, delete on testdb.* to common_user@'%' identified by 'password'; grant 数据库开发人员，创建表、索引、视图、存储过程、函数等权限, 12345678910111213141516171819202122grant 创建、修改、删除 MySQL 数据表结构权限。grant create on testdb.* to developer@'192.168.0.%' identified by 'password'; grant alter on testdb.* to developer@'192.168.0.%' identified by 'password'; grant drop on testdb.* to developer@'192.168.0.%' identified by 'password';grant 操作 MySQL 外键权限：grant references on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 临时表权限：grant create temporary tables on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 索引权限：grant index on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 视图、查看视图源代码权限：grant create view on testdb.* to developer@'192.168.0.%'; grant show view on testdb.* to developer@'192.168.0.%';grant 操作 MySQL 存储过程、函数权限：grant create routine on testdb.* to developer@'192.168.0.%';grant alter routine on testdb.* to developer@'192.168.0.%';grant execute on testdb.* to developer@'192.168.0.%'; grant 普通 DBA 管理某个 MySQL 数据库的权限 1grant all privileges on testdb to dba@'localhost' grant 高级 DBA 管理 MySQL 中所有数据库的权限 1grant all on *.* to dba@'localhost' MySQL grant 权限，分别可以作用在多个层次上 12345grant 作用在单个数据库上：grant select on testdb.* to dba@localhost; -- dba 可以查询 testdb 中的表。 grant 作用在单个数据表上：grant select, insert, update, delete on testdb.orders to dba@localhost; 这里在给一个用户授权多张表时，可以多次执行以上语句。例如： 123456789grant select(user_id,username) on smp.users to mo_user@'%' identified by '123345'; grant select on smp.mo_sms to mo_user@'%' identified by '123345'; grant 作用在表中的列上：grant select(id, se, rank) on testdb.apache_log to dba@localhost;grant 作用在存储过程、函数上：grant execute on procedure testdb.pr_add to 'dba'@'localhost' grant execute on function testdb.fn_add to 'dba'@'localhost' 查看 MySQL 用户权限查看当前用户（自己）权限： 1show grants; 查看其他 MySQL 用户权限： 1show grants for dba@localhost; 撤销已经赋予给 MySQL 用户权限的权限。 1revoke all on *.* from dba@localhost;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>授权及撤销</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库备份脚本]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[之前的项目中用到了MySQL数据库的备份功能，因此做了如下记录，以便后期用到 123456789101112131415backup_date=`date +'%Y-%m-%d %H:%M:%S'`backup_path="/home/3uadmin/backups"removedate=`date -d "7 day ago" +"%Y-%m-%d"`# 冷备charge库/usr/bin/mysqldump -uhssydbuser --password='hs3u@16171246' --database charge &gt; "$backup_path/charge/$backup_date.db"bzip2 "$backup_path/charge/$backup_date.db"rm -f "$backup_path/charge/$removedate*.db.bz2"# 冷备m2m库/usr/bin/mysqldump -um2m --password='m2mdbroot' --database m2m &gt; "$backup_path/m2m/$backup_date.db"bzip2 "$backup_path/m2m/$backup_date.db"rm -f "$backup_path/m2m/$removedate*.db.bz2"]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL跨数据库查询]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[数据库是否支持第一步是要验证数据库是否支持federated输入show engines，检查显示情况，如果显示support为NO说明已经安装了federated服务，但是没有启动，但是如果没有federated这一行，说明服务都没有启动; 安装服务只需要在my.cnf（一般是在/etc/my.cnf下面）中的[mysqld]的最后一行，添加federated 验证查询的SQL如下12345678CREATE TABLE federated_table ( id int(20) NOT NULL auto_increment, name varchar(32) NOT NULL default '', other int(20) NOT NULL default '0', PRIMARY KEY (id), KEY name (name), KEY other_key (other)) ENGINE=FEDERATED CONNECTION='mysql://username:password@remote_host:3306/db_name/table_name';]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>跨库查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双数据源配置SpringMVC+Spring+Mybatis]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AESpingMVC-Sping-Mybatis%2F</url>
    <content type="text"><![CDATA[最近下载了一个SSM的框架，然后项目上要用到双数据源的情况，因此在这方面查资料查了很久，最终完成了，具体过程如下，有误之处麻烦各位大神指出，及时更新 首当其冲第一步就是修改数据库配置文件，我这里叫dbconfig.properties，修改的时候，只需要把原来的数据库的配置文件复制一套，然后在前面加上对应数据库的标识就行了 修改Sping的配置文件ApplicationContext.xml，复制一套org.springframework.jdbc.datasource.DataSourceTransactionManager对应的bean，修改对应的name值为transactionManager2，然后复制一套数据库连接的配置，改为数据源2的数据信息 再就是DAO层面的修改了，只需要修改两个地方，一个地方是sqlSessionTemplate2对应到上面Spring配置文件中的sqlSessionTemplate2，在一个就是DaoSupport的声明了吧 下面就可以直接使用了 附件源码：双数据源配置代码下载]]></content>
      <categories>
        <category>后端开发框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>双数据源</tag>
        <tag>Mybatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2019%2F02%2F19%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MySQL 插入数据MySQL使用INSERT INTO 语句插入数据 语法1INSERT INTO table_name (filed1, field2, field3) VALUES (value1, value2, value3); 例子：1INSERT INTO tt_area (id, name, pid) VALUES (&apos;1&apos;, &apos;北京&apos;, &apos;0&apos;); MySQL 查询数据123SELECT * FROM TABLE LIMIT 10; #查询前10条数据SELECT * FROM TABLE LIMIT 5,10;#查询6-15条数据，第一个参数是从那条数据开始，第二个参数是指查询多少条SELECT * FROM tt_users A ORDER BY reg_time DESC,reco_name ASC #按照多个字段进行排序，DESC是倒序，ASC是正序，其中 MySQL Update更新数据123456/*通过查询一个表里面的数据更新另一个表中的数据*/UPDATE tableA, tableBSET tableA.columnA = tableB.columnBWHERE tableA.clumnC = tableB.columnD 数据库层面的操作 常规的update 12345mysql -u root -p password #登录mysql数据库use database name #使用哪个数据库实例drop database #删除某个数据库实例mysqldump -u root -p database_name&gt; /usr/data/mysqldata_bak_20171110.db #数据泵导出mysqldump -u root -p database_name&lt; /usr/data/mysqldata_bak_20171011.db #数据泵导入 非常规update(通过子查询更新主表，子查询中牵扯GROUP BY 和 查询条件)首先在数据库创建表，并插入数据，具体的sql如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647DROP TABLE IF EXISTS `demo_value`;CREATE TABLE `demo_value` ( `id` int(5) NOT NULL, `user_id` int(5) DEFAULT NULL, `value` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of demo_value-- ----------------------------INSERT INTO `demo_value` VALUES (&apos;1&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;2&apos;, &apos;1&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;3&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;4&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;5&apos;, &apos;2&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;6&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;7&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;8&apos;, &apos;3&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;9&apos;, &apos;4&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;10&apos;, &apos;4&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;11&apos;, &apos;5&apos;, &apos;40&apos;);INSERT INTO `demo_value` VALUES (&apos;12&apos;, &apos;6&apos;, &apos;20&apos;);DROP TABLE IF EXISTS `demo_value`;CREATE TABLE `demo_value` ( `id` int(5) NOT NULL, `user_id` int(5) DEFAULT NULL, `value` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of demo_value-- ----------------------------INSERT INTO `demo_value` VALUES (&apos;1&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;2&apos;, &apos;1&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;3&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;4&apos;, &apos;1&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;5&apos;, &apos;2&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;6&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;7&apos;, &apos;2&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;8&apos;, &apos;3&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;9&apos;, &apos;4&apos;, &apos;20&apos;);INSERT INTO `demo_value` VALUES (&apos;10&apos;, &apos;4&apos;, &apos;30&apos;);INSERT INTO `demo_value` VALUES (&apos;11&apos;, &apos;5&apos;, &apos;40&apos;);INSERT INTO `demo_value` VALUES (&apos;12&apos;, &apos;6&apos;, &apos;20&apos;); 1234567891011UPDATE demo_nameSET sum_value = ( SELECT SUM(`value`) FROM demo_value WHERE demo_value.user_id = demo_name.id GROUP BY user_id) 其他 在Navicat中，Ctrl+Q是创建一个查询界面 MySQL底层实现是从右往左进行解析执行，因此把]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 MySQL5.7免安装版安装教程]]></title>
    <url>%2F2019%2F02%2F19%2FWindows10-MySQL5-7%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[首先是下载 最近发现官网上下载版本直接跳到8.0了，下载的时候一定要注意找之前的版本 打开mysql的官网mysql下载地址 找到顶部的DOWNLOADS ，如果地址没换的话，应该是下面这个地址下载地址 选择社区版本（Community），然后选择左侧的菜单中的MySQL Community Server 滑动滚轮，向下，一直到选择系统和下载版本 选择完之后选择列表中展示的（ZIP Archive）版本的进行下载，我下载的版本是5.7.20，下载完成成解压 添加环境变量 首先是添加MYSQL_HOME，设置的VALUE值是MYSQL的解压目录，我是解压在了D:\Program Files\mysql，所以对应的MYSQL_HOME就是这个值 设置PATH在PATH的最后添加%MYSQL_HOME%\bin; 配置文件 在mysql文件夹下，新建一个my.ini的文件此处需要注意：保存文件的编码集一定是ANSI，这个地方不要用记事本编辑，记事本默认是UTF-8，因为他是个坑，用专业的Notepad++ 或者UE进行编辑，具体my.ini的内容如下,内容解释下面的文件中都已经有了，就不再废话了，另外这个地方先开启skip-grant-tables是为了给root修改密码123456789[mysqld]basedir=D:\Program Files\mysqldatadir=D:\Program Files\mysql\data\port=3306skip-grant-tables#basedir表示mysql安装路径#datadir表示mysql数据文件存储路径#port表示mysql端口#skip-grant-tables表示忽略密码 安装 然后以管理员的权限进入cmd窗口界面，管理员权限进入方式：搜索cmd，右键在对应程序上，以管理员的权限启动 切换到mysql/bin文件夹下，也就是你解压的出来的文件夹的bin目录下，怎么切换我就不讲了 各种cd，然后执行命令，命令如下，执行完成后会显示“Service successfully installed” 1mysqld --install 生成data数据。不要着急于启动，先生成mysql的data数据，上面的my.cnf中设置了datadir=D:\Program Files\mysql\data\，因此我们需要先手动在mysql文件夹下面新建一个data文件夹，否则接下来的步骤会报错 1mysqld --initialize-insecure --user=mysql; 然后看下data目录下会生成一堆文件夹和文件 启动 在刚刚的cmd窗口中直接输入 net start mysql，然后会提示启动成功1net start mysql 登录 输入命令mysql -u root -p，这个时候是没有密码的，所以输入完之后直接回车，就可以进入mysql中了1mysql -u root -p 更新密码 输入以下命令修改密码，当然密码需要修改成你自己想要修改的内容,再就是刷新下quanxian 1update mysql.user set authentication_string=password(&apos;123456789&apos;) where user=&apos;root&apos; and Host = &apos;localhost&apos;; 1flush privileges; 恢复my.ini配置文件 现在修改完密码了，需要删除或注释my.ini文件中的skip-grant-tables选项，一定注意不要用记事本，那是个坑 停止和启动mysql服务12net start mysqlnet stop mysql 常规错误提示及可能遇到的问题 出现这个问题的原因一般是my.ini文件的编码格式出现问题了，保存的时候一定要记得是ANSI mysqld: [ERROR] Found option without preceding group in config file D:\Program Files\mysql\my.ini at line 1!mysqld: [ERROR] Fatal error in defaults handling. Program aborted! 如果你电脑的性能没啥问题的话，一般4-5S就能启动，像这种一直冒点的情况，可以在“计算机管理”界面查看Windows应用程序日志，翻一翻，MySQL相关错误 D:\Program Files\mysql\bin&gt;net start mysqlMySQL 服务正在启动 ……………. sc delete mysql 服务的时候回提示服务正在启动，不能删除，或者已经标记为删除的情况，但是服务就是删不掉的情况，这种情况下，第一确认你的服务是否已经停止（有时候 net stop mysql 不好使，可以直接在任务管理器里面，把mysql的进程结束掉） 第二、关闭你的services.msc界面 然后再执行sc 命令进行服务删除操作]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>免安装版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB资料]]></title>
    <url>%2F2019%2F02%2F19%2FMongoDB%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[MongoDB数据表基本操作http://www.cnblogs.com/libingql/archive/2011/06/09/2076440.html mongodb安全认证http://www.cnblogs.com/silentjesse/p/4676440.html mongodb Replica Sets +Sharding高可用集群搭建(含认证)http://www.cnblogs.com/ylh1223/archive/2013/04/23/3037301.html MongoDB的授权和权限http://blog.csdn.net/lixiaoweihubin/article/details/8620552 mongodb key文件报 permissions on xxx are too openhttps://blog.csdn.net/lixiaoweihubin/article/details/8620552 mongodb 添加用户及权限设置详解http://www.jb51.net/article/52485.htm mongodb-常见问题http://www.cnblogs.com/cyhe/p/5526662.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat性能优化]]></title>
    <url>%2F2019%2F02%2F19%2FTomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文转自闲谈Tomcat性能优化,tomcat服务器优化 转不意味着Copy，而是对别人知识的汲取和吸收的同时加上自己的理解 Tomcat默认配置作为生产环境，尤其是内存和线程的配置，默认都是很低，容易成为性能的瓶颈，下面对Tomcat的内存、线程、IO三个方面的优化进行详解： Tomcat内存优化（内存调优的最直接方式）启动Tomcat的时候告诉JVM（java虚拟机）分配一块大内存 打开Linux服务器下bin文件夹下的catalina.sh文件，修改虚拟机配置 修改的主要内容包含如下：123# -Xms&lt;size&gt; JVM初始化堆的大小# -Xmx&lt;size&gt; JVM堆的最大值 实际参数大小根据服务器配置或者项目具体设置.JAVA_OPTS='-server -Xms512m -Xmx512m' 参数解析 -server:一定要作为第一个参数，在多个CPU时性能佳 -Xms:初始Heap大小，使用的最小内存,一般建议堆的最大值配置为可用内存的最大值的80% -Xmx:java heap最大值，使用的最大内存,一般建议堆的最大值配置为可用内存的最大值的80% -XX:PermSize:内存永久保留区域 -XX:MaxPermSize:内存最大永久保留区域 -Xmn:jvm最小内存* 服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小 123# 32G 内存配置示例：JAVA_OPTS="-server -Xms10g -Xmx10g -XX:PermSize=1g -XX:MaxPermSize=2g -Xshare:off -Xmn1024m" Tomcat线程优化server.xml文件中修改以下内容，从而优化线程12&lt;Connector port="80" protocol="HTTP/1.1" maxThreads="600" minSpareThreads="100" maxSpareThreads="500" acceptCount="700"connectionTimeout="20000" /&gt; maxThread:最大并发数，默认设置 200，一般建议在 500 ~ 800，根据硬件设施和业务来判断 minSpareThread:Tomcat 初始化时创建的线程数，默认设置 25 maxSpareThread:最多可以有多少个线程，一个超过这个数，则会关闭不再需要的线程 acceptCount:当同时连接的人数达maxThread时，还可以排队，排队大小为这个数，超过这个数就不进行处理 maxQueueSize，最大的等待队列数，超过则拒绝请求 Tomcat IO优化 同步阻塞IO（java BIO），服务器实现模式为一个连接一个线程，线程是宝贵资源，所以可以通过线程池机制改善。 Java NIO:分为同步非阻塞IO，异步IO与BIO最大的区别是可以通过一个线程处理多个connection（多路复用） 异步非阻塞IO（Java NIO2又叫AIO） BIO:适用于连接数目比较小且固定架构，这种方式对服务器资源要求比较高，而且局限于应用中，JDK1.4以前的唯一选择，但程序只管简单易理解 NIO:适用于连接数目比较多且连接比较短（轻操作）架构，比如聊天服务器，并且局限于应用中，编程比较复杂 AIO:连接数目比较多且连接比较长（重操作），比如相册服务器，充分调用OS参与并发操作，编程比较复杂，从JDK1.7开始支持 配置方法： 在server.xml中： 1234567&lt;Connector executor="tomcatThreadPool" port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol"connectionTimeout="20000" maxConnections="10000"redirectPort="8443" enableLookups="false" acceptCount="100" maxPostSize="10485760" compression="on" disableUploadTimeout="true"compressionMinSize="2048" acceptorThreadCount="2"compressableMimeType="text/html,text/xml,text/plain,text/css,text/javascript,application/javascript" URIEncoding="utf-8"/&gt; 参数解析 protocol：Tomcat 8 设置 nio2 更好：org.apache.coyote.http11.Http11Nio2Protocol（如果这个用不了，就用下面那个） protocol：Tomcat 6、7 设置 nio 更好：org.apache.coyote.http11.Http11NioProtocol acceptCount，指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认设置 100 maxPostSize，以 FORM URL 参数方式的 POST 提交方式，限制提交最大的大小，默认是 2097152(2兆)，它使用的单位是字节。10485760 为 10M。如果要禁用限制，则可以设置为 -1。 acceptorThreadCount，用于接收连接的线程的数量，默认值是1。一般这个指需要改动的时候是因为该服务器是一个多核CPU，如果是多核 CPU 一般配置为 2. APRAPR是从操作系统级别来解决异步IO问题，大幅度提高性能，具体可见链接地址APR(Apache Portable Runtime)是一个高可移植库,它是Apache HTTP Server 2.x的核心.能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器.在局域网环境测，就算是400个并发，也是一瞬间就处理/传输完毕，但是在真实的Internet环境下，页面处理时间只占0.1%都不到，绝大部分时间都用来页面传输.如果不用APR，一个线程同一时间只能处理一个用户，势必会造成阻塞。所以生产环境下用apr是非常必要的. 安装Apache Tomcat Native Library，直接启动就支持apr(http://tomcat.apache.org/native-doc/)它本身是基于APR的. 具体安装方法可以参考其他博客和文章. 排除代码问题Tomcat优化到这个层次,可以应对大部分性能需求]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>中间件</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.5中Tomcat部署及单机多Tomcat部署]]></title>
    <url>%2F2019%2F02%2F19%2FCentOS6-5%E4%B8%ADTomcat%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%8D%95%E6%9C%BA%E5%A4%9ATomcat%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Tomcat下载Tomcat的下载地址，根据自己的需求进行版本的下载12cd /usr/localwget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.73/bin/apache-tomcat-7.0.73.tar.gz Tomcat安装（Linux）解压tomcat并进行目录重命名12345tar -zxvf apache-tomcat-7.0.73.tar.gz # 解压mv apache-tomcat-7.0.73 tomcat1 # 重命名为tomcat1tar -zxvf apache-tomcat-7.0.73.tar.gz # 解压mv apache-tomcat-7.0.73 tomcat2 # 重命名为tomcat2rm -rf apache-tomcat-7.0.73.tar.gz # 删除安装包 修改配置文件修改两个tomcat的配置文件server.xml，修改的内容如下图所示 tomcat1 tomcat2 验证修改完成，启动Tomcat，访问对应的端口号进行验证]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>多节点</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+Tomcat 负载均衡配置]]></title>
    <url>%2F2019%2F02%2F19%2FNginx-Tomcat-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nginx 安装依赖安装首先由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，这些依赖库主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel 所以执行如下命令安装1234$ yum install gcc-c++ $ yum install pcre pcre-devel $ yum install zlib zlib-devel $ yum install openssl openssl--devel 安装步骤验证是否安装过ngnix如果已经安装过，需要进行卸载 yum remove nginx$ find -name nginx 下载Ngnix$ wget http://nginx.org/download/nginx-1.7.4.tar.gz 解压压缩包$ tar -zxvf nginx-1.7.4.tar.gz 安装进入解压的文件夹，接下来安装，使用–prefix参数指定nginx安装的目录,make、make install安装123$ ./configure $默认安装在/usr/local/nginx $ make $ make install 查看安装位置$ whereis nginx 负载均衡配置修改nginx的配置文件修改/usr/local/nginx/conf文件夹下面的nginx.conf文件12cd /usr/local/nginx/confvim nginx.conf 定义一个mysite，然后定义这个mysite对应需要负载均衡的服务器12345upstream mysite&#123;server 192.168.1.148:8080;server 192.168.1.148:8081;ip_hash;&#125; ip_hash 是为了保证访问的时候只对一个服务器，使session能够保持住 启动、停止nginx进入nginx的安装文件夹下123456cd /usr/local/nginx/sbin./nginx //启动./nginx -s stop //停止./nginx -s reload //重新加载./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat指定JDK启动]]></title>
    <url>%2F2019%2F02%2F19%2FTomcat%E6%8C%87%E5%AE%9AJDK%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[项目上出现一个服务器上多个版本JDK的问题，而且目前要用的JDK和默认JDK版本不一致的时候，就需要在Tomcat启动的时候，设置对应的JDK版本，特别是在Linux服务器上 配置Windows服务器找到Tomcat的目录下的bin文件夹，打开bin文件夹下面的setclasspath.bat文件，在文件顶部添加如下代码： 12set JAVA_HOME=D:\Program Files\Java\jdk7\jdk1.7.0_51set JRE_HOME=D:\Program Files\Java\jdk7\jre7 Linux服务器找到Tomcat目录下的bin文件夹，打开bin文件夹下面的setclasspath.sh文件，在文件顶部添加如下代码： 一定要注意Linux是Export而Windows是set12345678910# -----------------------------------------------------------------------------# Set JAVA_HOME or JRE_HOME if not already set, ensure any provided settings# are valid and consistent with the selected start-up options and set up the# endorsed directory.# -----------------------------------------------------------------------------# Make sure prerequisite environment variables are setexport JAVA_HOME=/usr/local/java/jdk1.8.0_191export JRE_HOME=/usr/local/java/jdk1.8.0_191/jre... 校验在tomcat启动的时候，会报Tomcat JRE信息，可以看下JRE信息是否和配置的位置一致，如果位置一致，说明没有问题 原理Tomcat启动的时候会执行start.sh(Linux)或者start.bat(Win)，启动的时候会分别调用catalina.sh(Linux)，然后调用setclasspath.sh(Linux)文件，因此在setclasspath文件中设置JAVA_HOME和JRE之后，就可以指向特定的JDK 扩展基于上面的原理，也可以用下面的方法设置Tomcat指定的JDK 修改tomcat/bin/catalina.sh，增加 export JAVA_HOME=…]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>JDK</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat启动失败问题解决]]></title>
    <url>%2F2019%2F02%2F19%2FTomcat%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[未安装JDK或JDK配置错误 新建JAVA_HOME 他的值为JDK的安装绝对路径 例如：C:\Program Files\Java\jdk1.5.0_18\ 新建Classpath（如果已经有的话，直接点击编辑，用分号隔开），他的值为 .;%JAVA_HOME%\lib 新建Path，如果已经有了，可以直接加分号隔开他的值为：%JAVA_HOME%\bin 已安装，启动bat闪退 在startup.bat文件末尾添加pause，启动tomcat，查看输出日志 如果是JDK的问题，可在start.bat顶部添加如下代码Windows: 12set JAVA_HOME=D:\Program Files\Java\jdk7\jdk1.7.0_51set JRE_HOME=D:\Program Files\Java\jdk7\jre7 Linux 12export JAVA_HOME=/home/jdk/Java\jdk7\jdk1.7.0_51export JRE_HOME=/home/jdk/Java\jdk7\jre7]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>中间件</tag>
        <tag>启动失败</tag>
        <tag>闪退</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx开启Gzip压缩大幅提高页面加载速度]]></title>
    <url>%2F2019%2F02%2F18%2FNginx%E5%BC%80%E5%90%AFGzip%E5%8E%8B%E7%BC%A9%E5%A4%A7%E5%B9%85%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[刚刚给博客加了一个500px相册插件，lightbox引入了很多js文件和css文件，页面一下子看起来非常臃肿，所以还是把Gzip打开了。环境：Debian 6 Vim打开Nginx配置文件vim /usr/local/nginx/conf/nginx.conf 找到如下一段，进行修改 12345678gzip on;gzip_min_length 1k;gzip_buffers 4 16k;#gzip_http_version 1.0;gzip_comp_level 2;gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;gzip_vary off;gzip_disable "MSIE [1-6]\."; 解释一下第1行：开启Gzip第2行：不压缩临界值，大于1K的才压缩，一般不用改第3行：buffer，就是，嗯，算了不解释了，不用改第4行：用了反向代理的话，末端通信是HTTP/1.0，有需求的应该也不用看我这科普文了；有这句的话注释了就行了，默认是HTTP/1.1第5行：压缩级别，1-10，数字越大压缩的越好，时间也越长，看心情随便改吧第6行：进行压缩的文件类型，缺啥补啥就行了，JavaScript有两种写法，最好都写上吧，总有人抱怨js文件没有压缩，其实多写一种格式就行了第7行：跟Squid等缓存服务有关，on的话会在Header里增加”Vary: Accept-Encoding”，我不需要这玩意，自己对照情况看着办吧第8行：IE6对Gzip不怎么友好，不给它Gzip了 :wq保存退出，重新加载Nginx/usr/local/nginx/sbin/nginx -s reload 用curl测试Gzip是否成功开启 123456789curl -I -H "Accept-Encoding: gzip, deflate" "http://www.slyar.com/blog/"HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:13:09 GMTContent-Type: text/html; charset=UTF-8Connection: keep-aliveX-Powered-By: PHP/5.2.17p1X-Pingback: http://www.slyar.com/blog/xmlrpc.phpContent-Encoding: gzip 页面成功压缩12345678910curl -I -H "Accept-Encoding: gzip, deflate" "http://www.slyar.com/blog/wp-content/plugins/photonic/include/css/photonic.css"HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:21:25 GMTContent-Type: text/cssLast-Modified: Sun, 26 Aug 2012 15:17:07 GMTConnection: keep-aliveExpires: Mon, 27 Aug 2012 06:21:25 GMTCache-Control: max-age=43200Content-Encoding: gzip css文件成功压缩12345678910curl -I -H &quot;Accept-Encoding: gzip, deflate&quot; &quot;http://www.slyar.com/blog/wp-includes/js/jquery/jquery.js&quot;HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:21:38 GMTContent-Type: application/x-javascriptLast-Modified: Thu, 12 Jul 2012 17:42:45 GMTConnection: keep-aliveExpires: Mon, 27 Aug 2012 06:21:38 GMTCache-Control: max-age=43200Content-Encoding: gzip js文件成功压缩12345678910curl -I -H &quot;Accept-Encoding: gzip, deflate&quot; &quot;http://www.slyar.com/blog/wp-content/uploads/2012/08/2012-08-23_203542.png&quot;HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:22:45 GMTContent-Type: image/pngLast-Modified: Thu, 23 Aug 2012 13:50:53 GMTConnection: keep-aliveExpires: Tue, 25 Sep 2012 18:22:45 GMTCache-Control: max-age=2592000Content-Encoding: gzip 图片成功压缩1234567891011curl -I -H &quot;Accept-Encoding: gzip, deflate&quot; &quot;http://www.slyar.com/blog/wp-content/plugins/wp-multicollinks/wp-multicollinks.css&quot;HTTP/1.1 200 OKServer: nginx/1.0.15Date: Sun, 26 Aug 2012 18:23:27 GMTContent-Type: text/cssContent-Length: 180Last-Modified: Sat, 02 May 2009 08:46:15 GMTConnection: keep-aliveExpires: Mon, 27 Aug 2012 06:23:27 GMTCache-Control: max-age=43200Accept-Ranges: bytes 最后来个不到1K的文件，由于我的阈值是1K，所以没压缩 本文引自http://www.veryhuo.com/a/view/51706.html]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>图片压缩</tag>
        <tag>Nginx</tag>
        <tag>Gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器端图片压缩之Nginx+lua_nginx module+GraphicsMagick]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B9%8BNginx-lua-nginx-module-GraphicsMagick%2F</url>
    <content type="text"><![CDATA[在开发电子商务网站时，同一个图片需要不同尺寸的缩略图片，一般有两种策略生成缩略图，一种在上传图片时，生成需要的缩略图，另一种是请求指定尺寸的图片时生存缩略图片，第一种方式有一定限制，就是需要提前知道所有尺寸的图片，如果前端ui设计改变了图片大小，需要重新生成。而第二种方式更加灵活，这里采用第二种方 ，只是淘宝使用ImageMagick）。 这里主要借助lua_nginx module调用GraphicsMagick命令生存生存缩略图片，缩略图片的尺寸包含在请求图片名称中，例如：xxxxx.jpg.80x80.jpg返回的就是xxx.jpg的80x80尺寸的图片大小。nginx配置如下： 上传图片名称使用32位随机字符替换掉，图片存放目录为图片名称前六个字母，每两个一组，构造三层目录结构存放，这样可以均匀存放图片在不同目录。避免目录存放文件数量限制。为了避免随意生成不同尺寸的缩略图，这里做了限制，在image_sizes中定义了需要的缩略图尺寸。 初次版本 12345678910111213141516171819202122232425262728293031323334353637383940414243location /testImg/ &#123; rewrite_by_lua ' local image_root = "/home/tomcat/eisp-files"; function file_notexists(name) local f=io.open(name,"r") if f~=nil then io.close(f) return false else return true end end local uri = ngx.re.sub(ngx.var.uri, "/testImg/([0-9a-zA-Z]+)/([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]+).([0-9a-zA-Z]+)", "/images/$1/$2/$3/$4/$2$3$4$5.$6", "o"); local index = string.find(uri, "([0-9]+)x([0-9]+)"); local originalUri = string.sub(uri, 0, index-2); local area = string.sub(uri, index); index = string.find(area, "([.])"); area = string.sub(area, 0, index-1); if file_notexists(image_root .. uri) then local image_sizes = &#123;"80x80", "800x600", "40x40"&#125;; function table.contains(table, element) for _, value in pairs(table) do if value == element then return true end end return false end if table.contains(image_sizes, area) then local command = "gm convert " .. image_root .. originalUri .. " -thumbnail " .. area .. " -background gray -gravity center -extent " .. area .. " " .. image_root .. uri; os.execute(command); ngx.req.set_uri(uri, true); else ngx.exit(404); end; else ngx.req.set_uri(uri, true); end; '; &#125; location /images/ &#123; alias /home/tomcat/eisp-files/images/; expires 7d; &#125; 最后一次修改版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849location /images/ &#123; set $image_root /home/nds/nds-files; if ($uri ~* "/images/([0-9a-zA-Z]+)/([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]&#123;2&#125;)([0-9a-zA-Z]+).(.*)") &#123; set $filePath "$image_root/$1/$2/$3/$4/$2$3$4$5.$6"; set $reqPath "/$1/$2/$3/$4/$2$3$4$5.$6"; &#125; set $file "$image_root$reqPath"; if (-f $file) &#123; rewrite "/images/(.+)" /innerImages$reqPath last; &#125; if (!-f $file) &#123; rewrite_by_lua ' local index = string.find(ngx.var.filePath, "([0-9]+)x([0-9]+)"); local originalUri = string.sub(ngx.var.filePath, 0, index-2); local area = string.sub(ngx.var.filePath, index); index = string.find(area, "([.])"); area = string.sub(area, 0, index-1); local image_sizes = &#123;"155x155", "400x400","104x104", "50x50", "40x40", "56x56", "172x172","800x600"&#125;; function table.contains(table, element) for _, value in pairs(table) do if value == element then return true end end return false end if table.contains(image_sizes, area) then local command = "gm convert " .. originalUri .. " -thumbnail " .. area .. " -background white -gravity center -extent " .. area .. " " .. ngx.var.file; os.execute(command); ngx.req.set_uri("/innerImages" .. ngx.var.reqPath, true); else ngx.exit(404); end; '; &#125; &#125; location /innerImages/ &#123; alias /home/nds/nds-files/; expires max; tcp_nodelay off; tcp_nopush on; &#125; 本文引自http://www.iteye.com/topic/1125126]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>图片压缩</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开机启动服务或者Activity]]></title>
    <url>%2F2019%2F02%2F18%2FAndroid%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E6%88%96%E8%80%85Activity%2F</url>
    <content type="text"><![CDATA[有些时候，应用需要在开机时就自动运行，例如某个自动从网上更新内容的后台 service。怎样实现开机自动运行的应用？在撰写本文时，联想到高焕堂先生以“Don’’t call me, I’’ll call you back!”总结Android框架，真是说到点子上了。理解这句话的含义，许多有关Android平台上实现某种功能的问题，都能迎刃而解。 使用场景：手机开机后，自动运行程序，在屏幕上显示”Hello. I started!”字样。 背景知识：当Android启动时，会发出一个系统广播，内容为 ACTION_BOOT_COMPLETED，它的字符串常量表示为android.intent.action.BOOT_COMPLETED。只要在程序中“捕捉”到这个消息，再启动之即可。记住，Android框架说：Don’’t call me, I’’ll call you back。我们要做的是做好接收这个消息的准备，而实现的手段就是实现一个BroadcastReceiver。 代码解析： 1、界面Activity：SayHello.java123456789101112131415package com.ghstudio.BootStartDemo;import android.app.Activity;import android.os.Bundle;import android.widget.TextView;public class SayHello extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Hello. I started!"); setContentView(tv); &#125;&#125; 这段代码很简单，当Activity启动时，创建一个TextView，用它显示”Hello. I started!”字样。 2、接收广播消息：BootBroadcastReceiver.java1234567891011121314151617package com.ghstudio.BootStartDemo;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;public class BootBroadcastReceiver extends BroadcastReceiver &#123;static final String ACTION = "android.intent.action.BOOT_COMPLETED"; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(ACTION))&#123; Intent sayHelloIntent=new Intent(context,SayHello.class); sayHelloIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(sayHelloIntent); &#125; &#125;&#125; 该类派生自BroadcastReceiver，覆载方法onReceive中，检测接收到的Intent是否符合BOOT_COMPLETED，如果符合，则启动SayHello那个Activity。 3、配置文件：AndroidManifest.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"package="com.ghstudio.BootStartDemo"android:versionCode="1"android:versionName="1.0"&gt;&lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt; &lt;activity android:name=".SayHello" android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;receiver android:name=".BootBroadcastReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt;&lt;uses-sdk android:minSdkVersion="3" /&gt;&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"&gt;&lt;/uses-permission&gt;&lt;/manifest&gt; 注意其中粗体字那一部分，该节点向系统注册了一个receiver，子节点intent-filter表示接收 android.intent.action.BOOT_COMPLETED消息。不要忘记配置 android.permission.RECEIVE_BOOT_COMPLETED权限。 完成后，编译出apk包，安装到模拟器或手机中。关机，重新开机。]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>服务</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 长摁连续触发事件，类似于Js里面的Interval]]></title>
    <url>%2F2019%2F02%2F18%2FAndroid-%E9%95%BF%E6%91%81%E8%BF%9E%E7%BB%AD%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8EJs%E9%87%8C%E9%9D%A2%E7%9A%84Interval%2F</url>
    <content type="text"><![CDATA[大致原理是,如果手指按在view上，则使用ScheduledExecutorService对象执行scheduleWithFixedDelay()方法，每隔一个间隔不停地向Handler发送Message，此处Message里的信息是View id，然后由Handler在handlemessage的时候处理需要触发的事件。 实现 首先,让对应的View设置一个OnTouchListener，在手指按下时触发不停的发送消息,手指抬起时停止发送 1234567891011subtractButton.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; updateAddOrSubtract(v.getId()); //手指按下时触发不停的发送消息 &#125;else if(event.getAction() == MotionEvent.ACTION_UP)&#123; stopAddOrSubtract(); //手指抬起时停止发送 &#125; return true; &#125; &#125;); 发送消息与终止方法：先定义一个ScheduledExecutorService对象，然后调用scheduleWithFixedDelay()方法 12345678910111213141516171819202122private ScheduledExecutorService scheduledExecutor;private void updateAddOrSubtract(int viewId) &#123; stop();//如果同时摁两个按钮或两个以上，会出现定时器不能停止的问题，因此在这里加上这个，把之前的定时器先关掉 final int vid = viewId; scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); scheduledExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.what = vid; handler.sendMessage(msg); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); //每间隔100ms发送Message &#125; private void stopAddOrSubtract() &#123; if (scheduledExecutor != null) &#123; scheduledExecutor.shutdownNow(); scheduledExecutor = null; &#125; &#125; 用来处理Touch事件的Handler定义如下： 1234567891011121314private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; int viewId = msg.what; switch (viewId)&#123; case R.id.custom_number_picker_subtract_button: setValue(value - rangeability); //减小操作 break; case R.id.custom_number_picker_add_button: setValue(value + rangeability); //增大操作 break; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>连续触发</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器内存、处理器、磁盘使用情况]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[本文转自命令查看Linux服务器内存、CPU、显卡使用情况 转不意味着Copy，而是对别人知识的汲取和吸收的同时加上自己的理解 内存使用情况 free -m命令 12345[root@itlb ~]# free -m total used free shared buffers cachedMem: 32078 31202 876 0 5 21952-/+ buffers/cache: 9244 22834Swap: 16111 86 16025 参数解析 命令中的-m指的是按照MB进行数据统计 Mem行 total:内存总数 used:内存已使用数 free:内存空闲数 shared:目前该参数已经废弃不适用，为0 buffers:缓存内存数（Buffer） cached:缓存内舒数（Page） -/+ buffers/cache: （-buffers/cache）: 真正使用的内存数，指的是第一部分的 used - buffers - cached （+buffers/cache）: 可用的内存数，指的是第一部分的 free + buffers + cached Swap:交换区的内存使用情况 注：虽然看着free的剩余比较小，但是这里有一定的混淆，真正的free是free+buffers+cached 处理器使用情况 top命令 12345678910111213141516171819[root@itlb ~]# toptop - 10:21:44 up 833 days, 18:27, 1 user, load average: 1.45, 1.36, 1.19Tasks: 509 total, 2 running, 507 sleeping, 0 stopped, 0 zombieCpu(s): 0.0%us, 1.2%sy, 3.1%ni, 95.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 32848860k total, 31990756k used, 858104k free, 26208k buffersSwap: 16498680k total, 88276k used, 16410404k free, 22492248k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND24827 root 30 10 391m 97m 6940 S 106.1 0.3 0:02.40 sosreport25310 root 20 0 15300 1588 944 R 0.7 0.0 0:00.06 top 100 root 20 0 0 0 0 S 0.3 0.0 142:18.26 events/1 118 root 20 0 0 0 0 S 0.3 0.0 25:50.62 events/19 2193 root 20 0 0 0 0 S 0.3 0.0 125:46.21 kondemand/0 2199 root 20 0 0 0 0 S 0.3 0.0 213:10.72 kondemand/6 9996 root 20 0 13.6g 786m 10m S 0.3 2.5 570:23.13 java15398 oracle 20 0 6355m 23m 20m S 0.3 0.1 173:01.00 oracle25444 root 20 0 7630m 930m 31m S 0.3 2.9 128:53.80 java25775 root 30 10 77124 6324 4512 R 0.3 0.0 0:00.01 rpm28567 root 20 0 17.2g 1.8g 14m S 0.3 5.8 24:48.19 java 参数解析 Tasks total:总共目前运行的任务数量 running:目前正在运行的任务数量 zombie:僵尸进程数量-Cpu(s) us:CPU已经使用的良 id:CPU空闲使用率 注：下半部分数据中出现%CPU列中出现超过100%的情况，说明是多核服务器，而且该进程使用多核 磁盘使用情况 fdisk -l命令 1234567891011121314151617181920212223242526272829303132333435363738[root@itlb ~]# fdisk -lWARNING: GPT (GUID Partition Table) detected on '/dev/sda'! The util fdisk doesn't support GPT. Use GNU Parted.Disk /dev/sda: 299.0 GB, 298999349248 bytes255 heads, 63 sectors/track, 36351 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000 Device Boot Start End Blocks Id System/dev/sda1 1 36352 291991551+ ee GPTPartition 1 does not start on physical sector boundary.Disk /dev/mapper/vg_itlb-lv_root: 53.7 GB, 53687091200 bytes255 heads, 63 sectors/track, 6527 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000Disk /dev/mapper/vg_itlb-lv_swap: 16.9 GB, 16894656512 bytes255 heads, 63 sectors/track, 2053 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000Disk /dev/mapper/vg_itlb-lv_home: 227.7 GB, 227679404032 bytes255 heads, 63 sectors/track, 27680 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0x00000000 参数解析 第一部分：Disk /dev/sda: 299.0 GB, 298999349248 bytes说明硬盘的总空间为299Gb 第二部分：Disk /dev/mapper/vg_itlb-lv_root: 53.7 GB, 53687091200 bytes对应分区的大小 ··· du -sh 命令 123[root@itlb ~]# cd /home/[root@itlb home]# du -sh121G . 该命令是指当前文件夹下已经使用了多少空间 df -h 命令 1234567[root@itlb home]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/vg_itlb-lv_root 50G 24G 24G 51% /tmpfs 16G 1.1M 16G 1% /dev/shm/dev/sda2 485M 39M 421M 9% /boot/dev/sda1 200M 260K 200M 1% /boot/efi/dev/mapper/vg_itlb-lv_home 209G 121G 78G 61% /home 是指各个挂载点的硬盘空间及使用情况 du -cks * | sort -rn | head -n 10命令 该命令是查看 当前目录 下占用空间最多的文件或者文件夹，取前10个 1234567891011[root@itlb home]# du -cks * | sort -rn | head -n 10126247676 总用量88805524 oracle15347828 yzh4867880 itl4199764 xyd3921468 tomcatservers3389964 admin2229484 xyddev1419676 tomcat-mc-platform881904 mysqlvbs du -h --max-depth=2 / 这个经常用查看所有的文件占用大小]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>应用情况</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux公钥进行远程登录]]></title>
    <url>%2F2019%2F02%2F18%2FLinux%E5%85%AC%E9%92%A5%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[之前听领导说使用公钥远程服务器的方式进行远程，感觉挺神秘，今天实践了一下，确实挺方便，先讲几点从中的感悟 拿到一个服务器的时候，如果想看下是否有被别人使用了公钥登录方式进行登录的方法看下文件/etc/ssh/sshd_config中的PubkeyAuthentication是否为yes状态，如果是，有可能是被别人能够通过公钥登录，然后再看下AuthorizedKeysFile看后面是否有公钥文件，如果有，那就是公钥的文件目录了 12345# 查看/etc/ssh/sshd_config[root@itlb ssh]# cat /etc/ssh/sshd_config# 文件比较长，需要详细的看下里面的内容，主要关注的是以下几个点PubkeyAuthentication yesAuthorizedKeysFile /root/.ssh/id_rsa.pub 设置服务器只能通过公钥进行登录，不能通过账号和密码登录的方法设置/etc/ssh/sshd_config中的PasswordAuthentication为no 1PasswordAuthentication no # 不允许密码验证登录 设置通过公钥登录服务器步骤1. 首先检查下服务器的SSH远程登录的服务状态1234567891011[root@node1 ~]$service sshd status # 查看sshd服务运行状态,如果没有输出`正在运行`，说明存在问题，需要安装# 安装、启动、永久生效[root@node1 ~]$ yum install -y openssh-server # 安装openssh服务端[root@node1 ~]$ yum install -y openssh-clients #安装openssh客户端，可以不安装[root@node1 ~]$ service sshd start # 临时开启sshd服务[root@node1 ~]$ chkconfig sshd on # 永久开启sshd服务，服务器重启也生效# 再次检查sshd的状态[root@node1 ~]$service sshd status # 查看sshd服务运行状态，如果输出下面内容，说明运行正常openssh-daemon (pid 1384) 正在运行... # 显示正在运行 2. 生成密钥对123456789101112131415161718192021222324252627[root@node1 ~]$ ssh-keygen # 生成ssh密钥对Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): # 回车(如果默认要保存到当前路径下，就直接回车，如果需要修改，输入对应的路径)Enter passphrase (empty for no passphrase): #密码（如果远程的使用公钥的时候设置还需要密码的时候，在这里输入密码）Enter same passphrase again: # 重复上面的密码Your identification has been saved in /root/.ssh/id_rsa. # 提示你的密钥保存在这个路径下了Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:fd:72:10:50:a6:7d:83:c7:93:d2:26:3d:12:0e:38:2f root@node1The keys randomart image is:+--[ RSA 2048]----+| .o.+ || o B * . || o. O % || E .. O + || .S o || o || . o || o || |+-----------------+[root@node1 ~]$ cd root/.ssh/[root@node1 .ssh]$ ll # 查看密钥/公钥对信息，权限都为600总用量 8-rw-------. 1 root root 1675 5月 21 14:26 id_rsa # 私钥-rw-------. 1 root root 392 5月 21 14:26 id_rsa.pub # 公钥[root@node1 .ssh]$ 3. 修改sshd配置文件这个地方文件内容比较长，一定要耐心找12345[root@node1 ~]$ vim /etc/ssh/sshd_configPasswordAuthentication no # 不允许密码验证登录PubkeyAuthentication yes # 允许公钥验证登录AuthorizedKeysFile .ssh/id_rsa.pub # 指定公钥文件路径 4. 将公私钥导出到本地这个步骤就不多说了，用各种ftp软件导出到本地即可 5. 重启sshd服务（重要）12[root@node1 .ssh]$ service sshd reload重新载入 sshd： [确定] 6. 使用Xshell远程]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>公私钥</tag>
        <tag>远程登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7防火墙端口号相关]]></title>
    <url>%2F2019%2F02%2F18%2FCentOS7%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[12345678# firewall-cmd --list-all-zones #查看所有的zone信息# firewall-cmd --get-default-zone #查看默认zone是哪一个# firewall-cmd --zone=internal --change-zone=p3p1 #临时修改接口p3p1所属的zone为internal# firewall-cmd --add-service=http #暂时开放http# firewall-cmd --permanent --add-service=http #永久开放http# firewall-cmd --zone=public --add-port=80/tcp --permanent #在public中永久开放80端口# firewall-cmd --permanent --zone=public --remove-service=ssh #从public zone中移除服务# firewall-cmd --reload #重新加载配置]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>CentOS7</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx开机启动（添加系统服务）]]></title>
    <url>%2F2019%2F02%2F18%2Fnginx%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Windows添加开机启动，很简单，但是Linux呢，这两天学习了一下，通过添加/etc/rc.local文件启动，但是据说这个方法很快就要被废掉了，因此又研究了一下添加系统服务，做成开机启动，这种启动方式是可以在开机之后不登录，就能启动服务的，好用！！ 编辑service文件（文件存储在/lib/systemd/system/xxxx.service） 1vim /lib/systemd/system/nginx.service 将一下内容拷贝进nginx.service文件中 12345678910111213[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target 说明： Description:描述服务 After:描述服务类别 [Service]服务运行参数的设置 Type=forking是后台运行的形式 ExecStart为服务的具体运行命令 ExecReload为重启命令 ExecStop为停止命令 PrivateTmp=True表示给服务分配独立的临时空间 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3保存退出。 设置开机启动systemctl enable nginx.service 其他启动指令启动nginx服务：systemctl start nginx.service设置开机自启动：systemctl enable nginx.service停止开机自启动：systemctl disable nginx.service查看服务当前状态：systemctl status nginx.service重新启动服务：systemctl restart nginx.service查看所有已启动的服务：systemctl list-units --type=service]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>开机启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7卸载默认openjdk并安装新的JDK]]></title>
    <url>%2F2019%2F02%2F18%2FCentOS7%E5%8D%B8%E8%BD%BD%E9%BB%98%E8%AE%A4openjdk%E5%B9%B6%E5%AE%89%E8%A3%85%E6%96%B0%E7%9A%84JDK%2F</url>
    <content type="text"><![CDATA[通常CentOS会安装OpenJDK，因为这是JDK开源的分支，也就是后期不会收费的（目前Oracle受够Java之后，应该是准备进行收费的），但是项目中要使用的是官方的JDK，因此需要进行替换，所以需要进行如下的操作 首先第一步是查询是否安装了openjdk12java -versionrpm -qa | grep java或者rpm -qa | grep jdk 执行卸载命令 123yum -y remove java 红色框中的内容或者rpm -e --nodeps 红色框中的内容 安装jdkwget 下载地址从jdk官网下载jdk，对应的版本是http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz?AuthParam=1484402679_fcd52afad2d006c2f4d31c50b4e7b6b8 下载完成后进行解压操作，并移动到/usr/local12tar -zxvf 下载下来的tar.gz 的安装包mv jdk1.8.0_111/ /usr/local/ 配置环境变量编辑/etc/profile文件，在最后添加如下内容,然后保存123456vim /etc/profileexport JAVA_HOME=/usr/local/jdk1.8.0_111export JRE_HOME=/usr/local/jdk1.8.0_111/jreexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JRE_HOME/lib 执行编译，使配置文件生效1234. /etc/profile或者切换到etc文件夹下面执行./profile]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>JDK</tag>
        <tag>安装JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat开机启动（添加系统服务）]]></title>
    <url>%2F2019%2F02%2F18%2FTomcat%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[tomcat 需要增加一个pid文件在tomca/bin 目录下面，增加 setenv.sh 配置，catalina.sh启动的时候会调用，同时配置java内存参数 1234#add tomcat pidCATALINA_PID="$CATALINA_BASE/tomcat.pid"#add java optsJAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m" 增加tomcat.service 123456789101112[Unit]Description=tomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/tomcat/apache-tomcat-8.5.8/tomcat.pidExecStart=/usr/local/tomcat/apache-tomcat-8.5.8/bin/startup.shExecStop=/bin/kill -s QUIT $MAINPIDExecReload=/bin/kill -s HUP $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.targe 使用tomcat.service 配置开机启动systemctl enable tomcat 启动tomcatsystemctl start tomcat 停止tomcatsystemctl stop tomcat 重启tomcatsystemctl restart tomcat注:因为配置pid，在启动的时候会再tomcat根目录生成tomcat.pid文件，停止之后删除，同时tomcat在启动时候，执行start不会启动两个tomcat，保证始终只有一个tomcat服务在运行。多个tomcat可以配置在多个目录下，互不影响]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>开机启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xshell远程内网的服务器慢，指令输入和操作时快时慢的问题]]></title>
    <url>%2F2019%2F02%2F18%2FXshell%E8%BF%9C%E7%A8%8B%E5%86%85%E7%BD%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%85%A2%EF%BC%8C%E6%8C%87%E4%BB%A4%E8%BE%93%E5%85%A5%E5%92%8C%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BF%AB%E6%97%B6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[登录Linux系统，打开终端，输入以下命令vi /etc/ssh/sshd_config 打开的文件中，拖动鼠标到最后一行，可能会出现下面两种情况 UsePAM yes UseDNS yes UsePAM yes在这里将UseDNS yes修改为UseDNS no，没有的则加上这一行，便可]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Xshell</tag>
        <tag>远程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7修改静态IP地址]]></title>
    <url>%2F2019%2F02%2F18%2FCentOS7%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[服务器一般是需要修改成静态的IP地址的，否则在非DHCP下，有可能会出现IP地址变动，远程不到服务器的情况，具体修改的方法如下 第一步是先看下自己服务器对应的正在使用的网卡地址，左面对应的是网络配置文件中配置的名字，后面会讲到[daniel@localhost ~]$ ifconfig 找到对应的网络配置文件# vim /etc/sysconfig/network-scripts/ifcfg-+上面那个第一红方框中的文件名 主要修改的内容如下 123456BOOTPROTO="static" #dhcp改为static ONBOOT="yes" #开机启用本配置 IPADDR=192.168.7.106 #静态IP GATEWAY=192.168.7.1 #默认网关 NETMASK=255.255.255.0 #子网掩码 DNS1=192.168.7.1 #DNS 配置 修改后的效果如下 重启网络服务#service network restart 查看改动后的效果，Centois 7 不再使用 ifconfig 而是用 ip 命令查看网络信息]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>CentOS7</tag>
        <tag>静态IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat中docBase的配置及在Tomcat和Idea中的配置方法]]></title>
    <url>%2F2019%2F02%2F18%2Ftomcat%E4%B8%ADdocBase%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%9D%9E%E9%A1%B9%E7%9B%AE%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%9B%BE%E7%89%87%E7%9A%84%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E5%9C%A8Tomcat%E5%92%8CIdea%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[tomcat中docBase配置的三种项目部署方式docBase是web应用的本地路径，path是访问tomcat服务的路径 直接将项目放在webapps下面，这是最简单而且很初级的部署方式 在tomcat安装目录下conf文件夹下的server.xml文件中，在&lt;host&gt;....&lt;/host&gt;之间，插入如下语句 1&lt;Context path="/hello" docBase="F:\eclipse3.2\workspace\hello\WebRoot" debug="0" privileged="true"&gt;&lt;/Context&gt; 在tomcat安装目录中的conf\Catalina\localhost目录下新建一个xml文件，名字随意，只要不重复，代码如下 1&lt;Context path="/hello" docBase="F:\eclipse3.2\workspace\hello\WebRoot" debug="0" privileged="true"&gt;&lt;/Context&gt; IDEA中配置的方法 点击下图中的Edit Configurations，弹出Run/Debug Configurations对话框 选择你的Tomcat中间件，点击中间件上的Deployment，并点击绿色的加号 选择External Source，打开选择路径界面，选择一个路径进行部署 点击Apply按钮，然后点击Ok就可以了 本文引自Tomcat中的docbase和path]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不安全的HTTP方法]]></title>
    <url>%2F2019%2F02%2F16%2F%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天尝试了下Tomcat之前的关于不安全HTTP方法漏洞的实践方法，确实可以通过PUT、DELETE完成文件的上传和删除操作（但是这个必须得保证tomcat中readonly属性必须设置为false，才能执行），因此在这进行了记录，并补充了补救的措施，具体的实践步骤和解决方案如下 基础知识 HTTP请求方法HTTP1.0定义了三种请求方法： GET、POST、HEADHTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 、CONNECT 序号 方法 描述 1 GET 请求指定页面信息，返回实体主体 2 HEAD 类似于GET，只是返回的信息中没有具体的内容，用户获取头部报文 3 POST 向指定资源提交数据处理请求（表单提交或者上传文件）。数据包含在请求体中。POST请求会导致新的资源的建立或者原有资源的修改 4 PUT 从客户端向服务端传送的数据取代指定的文档内容 5 DELETE 请求服务器删除指定的资源 6 CONNECT 预留给能够将连接改为管道方式的代理服务器 7 OPTIONS 允许客户端查看服务器的性能 8 TRACE 回显服务器收到的请求，主要用于测试和诊断 确认自己的漏洞入口是否开启使用curl执行命令curl -v -X OPTIONS your-website-url -I，如果输出结果中显示Allow中包含PUT、DELETE等，说明就存在漏洞 漏洞的应用 DELETE：能够删除服务器上面的文件信息，造成恶意攻击 PUT：通过PUT方法可以上传文件替换对应的服务器文件或者挂马文件，实现服务的攻击 OPTIONS：将会暴露服务器中间件的相关信息 漏洞测试实践 准备材料： 下载Tomcat7.0.xx，安装curl7.64.0 修改Tomcat配置文件信息 打开TOMCAT_HOME/conf/web.xml文件，在org.apache.catalina.servlets.DefaultServlet下添加readonly属性，添加完的效果如下所示1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 漏洞实践 通过PUT和DELETE上传和删除文件 修复方案 关闭除GET和POST之外的其他请求协议在项目为web.xml中，或者TOMCAT_HOME\conf\web.xml中添加如下代码，这里需要解释下：项目的XML文件，只能修复本项目的漏洞，tomcat的配置文件web.xml能够修复该Tomcat所有项目对应的漏洞 123456789101112&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;fortune&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;HEAD&lt;/http-method&gt; &lt;http-method&gt;OPTIONS&lt;/http-method&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt;&lt;/auth-constraint&gt;&lt;/security-constraint&gt; web.xml中修改或添加readonly属性的值为true 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt;&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;]]></content>
      <categories>
        <category>安全测评</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows curl安装及常规命令使用]]></title>
    <url>%2F2019%2F02%2F16%2Fwindows-curl%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[curl是什么curl是一个利用URL语法在命令行下工作的文件传输工具，它支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。curl还支持SSL认证、HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling 安装步骤下载Windows版本的curl 下载Win版curl的地址如下https://curl.haxx.se/windows/ 根据你自己的个人系统位数，下载对应的版本，我是X64的因此下载了下图中的红圈标注出来的版本 下载完成后解压，放到你想放置的位置，本次安装放在了D:\Program Files\curl（这里进行了解压文件的重命名，也可以不用重命名） 添加环境变量 我的电脑-&gt;右键“属性”-&gt;高级系统设置-&gt;环境变量在系统变量中点击新建按钮，如下图所示 弹出新建系统变量界面，在变量名中输入CURL_HOME，在变量值中输入D:\Program Files\curl\bin这个地方需要注意，替换成你自己的curl安装目录，并在最后添加\bin，具体如下图所示 修改系统变量中的Path，添加%CURL_HOME%，具体操作见下图 添加完成后，点击确定测试是否安装成功 打开CMD窗口，然后输入curl --help，看是否有反应，如果有如下输出，说明正常，如果没有，说明安装失败，根据具体的提示百度确认问题出在哪里123456789101112131415161718192021222324C:\Users\zp&gt;curl --helpUsage: curl [options...] &lt;url&gt; --abstract-unix-socket &lt;path&gt; Connect via abstract Unix domain socket --anyauth Pick any authentication method -a, --append Append to target file when uploading --basic Use HTTP Basic Authentication --cacert &lt;file&gt; CA certificate to verify peer against --capath &lt;dir&gt; CA directory to verify peer against -E, --cert &lt;certificate[:password]&gt; Client certificate file and password --cert-status Verify the status of the server certificate --cert-type &lt;type&gt; Certificate file type (DER/PEM/ENG) --ciphers &lt;list of ciphers&gt; SSL ciphers to use --compressed Request compressed response --compressed-ssh Enable SSH compression -K, --config &lt;file&gt; Read config from a file --connect-timeout &lt;seconds&gt; Maximum time allowed for connection --connect-to &lt;HOST1:PORT1:HOST2:PORT2&gt; Connect to host -C, --continue-at &lt;offset&gt; Resumed transfer offset -b, --cookie &lt;data&gt; Send cookies from string/file -c, --cookie-jar &lt;filename&gt; Write cookies to &lt;filename&gt; after operation --create-dirs Create necessary local directory hierarchy --crlf Convert LF to CRLF in upload --crlfile &lt;file&gt; Get a CRL list in PEM format from the given file...... 常用命令详细的使用方法见地址https://curl.haxx.se/docs/manpage.html语法：#curl [option] [url]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114-a/--append 上传文件时，附加到目标文件 -A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 - anyauth 可以使用“任何”身份验证方法 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 - basic 使用HTTP基本验证 -B/--use-ascii 使用ASCII /文本传输 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -d/--data &lt;data&gt; HTTP POST方式传送数据 --data-ascii &lt;data&gt; 以ascii的方式post数据 --data-binary &lt;data&gt; 以二进制的方式post数据 --negotiate 使用HTTP身份验证 --digest 使用数字身份验证 --disable-eprt 禁止使用EPRT或LPRT --disable-epsv 禁止使用EPSV -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 --egd-file &lt;file&gt; 为随机数据(SSL)设置EGD socket路径 --tcp-nodelay 使用TCP_NODELAY选项 -e/--referer 来源网址 -E/--cert &lt;cert[:passwd]&gt; 客户端证书文件和密码 (SSL) --cert-type &lt;type&gt; 证书文件类型 (DER/PEM/ENG) (SSL) --key &lt;key&gt; 私钥文件名 (SSL) --key-type &lt;type&gt; 私钥文件类型 (DER/PEM/ENG) (SSL) --pass &lt;pass&gt; 私钥密码 (SSL) --engine &lt;eng&gt; 加密引擎使用 (SSL). "--engine list" for list --cacert &lt;file&gt; CA证书 (SSL) --capath &lt;directory&gt; CA目录 (made using c_rehash) to verify peer against (SSL) --ciphers &lt;list&gt; SSL密码 --compressed 要求返回是压缩的形势 (using deflate or gzip) --connect-timeout &lt;seconds&gt; 设置最大请求时间 --create-dirs 建立本地目录的目录层次结构 --crlf 上传是把LF转变成CRLF -f/--fail 连接失败时不显示http错误 --ftp-create-dirs 如果远程目录不存在，创建远程目录 --ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用 --ftp-pasv 使用 PASV/EPSV 代替端口 --ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址 --ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输 --ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输 -F/--form &lt;name=content&gt; 模拟http表单提交数据 -form-string &lt;name=string&gt; 模拟http表单提交数据 -g/--globoff 禁用网址序列和范围使用&#123;&#125;和[] -G/--get 以get的方式来发送数据 -h/--help 帮助 -H/--header &lt;line&gt;自定义头信息传递给服务器 --ignore-content-length 忽略的HTTP头信息的长度 -i/--include 输出时包括protocol头信息 -I/--head 只显示文档信息 从文件中读取-j/--junk-session-cookies忽略会话Cookie - 界面&lt;interface&gt;指定网络接口/地址使用 - krb4 &lt;级别&gt;启用与指定的安全级别krb4 -j/--junk-session-cookies 读取文件进忽略session cookie --interface &lt;interface&gt; 使用指定网络接口/地址 --krb4 &lt;level&gt; 使用指定安全级别的krb4 -k/--insecure 允许不使用证书到SSL站点 -K/--config 指定的配置文件读取 -l/--list-only 列出ftp目录下的文件名称 --limit-rate &lt;rate&gt; 设置传输速度 --local-port&lt;NUM&gt; 强制使用本地端口号 -m/--max-time &lt;seconds&gt; 设置最大传输时间 --max-redirs &lt;num&gt; 设置最大读取的目录数 --max-filesize &lt;bytes&gt; 设置最大下载的文件总量 -M/--manual 显示全手动 -n/--netrc 从netrc文件中读取用户名和密码 --netrc-optional 使用 .netrc 或者 URL来覆盖-n --ntlm 使用 HTTP NTLM 身份验证 -N/--no-buffer 禁用缓冲输出 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -p/--proxytunnel 使用HTTP代理 --proxy-anyauth 选择任一代理身份验证方法 --proxy-basic 在代理上使用基本身份验证 --proxy-digest 在代理上使用数字身份验证 --proxy-ntlm 在代理上使用ntlm身份验证 -P/--ftp-port &lt;address&gt; 使用端口地址，而不是使用PASV -Q/--quote &lt;cmd&gt;文件传输前，发送命令到服务器 -r/--range &lt;range&gt;检索来自HTTP/1.1或FTP服务器字节范围 --range-file 读取（SSL）的随机文件 -R/--remote-time 在本地生成文件时，保留远程文件时间 --retry &lt;num&gt; 传输出现问题时，重试的次数 --retry-delay &lt;seconds&gt; 传输出现问题时，设置重试间隔时间 --retry-max-time &lt;seconds&gt; 传输出现问题时，设置最大重试时间 -s/--silent静音模式。不输出任何东西 -S/--show-error 显示错误 --socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口 --socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口 --stderr &lt;file&gt; -t/--telnet-option &lt;OPT=val&gt; Telnet选项设置 --trace &lt;file&gt; 对指定文件进行debug --trace-ascii &lt;file&gt; Like --跟踪但没有hex输出 --trace-time 跟踪/详细输出时，添加时间戳 -T/--upload-file &lt;file&gt; 上传文件 --url &lt;URL&gt; Spet URL to work with -u/--user &lt;user[:password]&gt;设置服务器的用户和密码 -U/--proxy-user &lt;user[:password]&gt;设置代理用户名和密码 -v/--verbose -V/--version 显示版本信息 -w/--write-out [format]什么输出完成后 -x/--proxy &lt;host[:port]&gt;在给定的端口上使用HTTP代理 -X/--request &lt;command&gt;指定什么命令 -y/--speed-time 放弃限速所要的时间。默认为30 -Y/--speed-limit 停止传输速度的限制，速度时间'秒 -z/--time-cond 传送时间设置 -0/--http1.0 使用HTTP 1.0 -1/--tlsv1 使用TLSv1（SSL） -2/--sslv2 使用SSLv2的（SSL） -3/--sslv3 使用的SSLv3（SSL） --3p-quote like -Q for the source URL for 3rd party transfer --3p-url 使用url，进行第三方传送 --3p-user 使用用户名和密码，进行第三方传送 -4/--ipv4 使用IP4 -6/--ipv6 使用IP6 -#/--progress-bar 用进度条显示当前的传送状态 使用案例 获取页面的数据curl www.baidu.com 1234C:\Users\zp&gt;curl www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270...... 获取页面数据的同时，查看HTTP头信息curl -i www.baidu.com 1234567891011121314151617C:\Users\zp&gt;curl -i www.baidu.comHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2381Content-Type: text/htmlDate: Sat, 16 Feb 2019 02:10:54 GMTEtag: "588604c8-94d"Last-Modified: Mon, 23 Jan 2017 13:27:36 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action...... 仅获取HTTP头信息curl -I www.baidu.com 123456789101112C:\Users\zp&gt;curl -I www.baidu.comHTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 277Content-Type: text/htmlDate: Sat, 16 Feb 2019 02:12:46 GMTEtag: "575e1f60-115"Last-Modified: Mon, 13 Jun 2016 02:50:08 GMTPragma: no-cacheServer: bfe/1.0.8.18 获取更详细的信息，包解析ip的过程等等curl -v www.baidu.com 12345678910111213141516171819202122232425262728293031323334C:\Users\zp&gt;curl -v www.baidu.com* Expire in 0 ms for 6 (transfer 0x23fb58a20a0)* Expire in 1 ms for 1 (transfer 0x23fb58a20a0)* Expire in 1 ms for 1 (transfer 0x23fb58a20a0)* Expire in 2 ms for 1 (transfer 0x23fb58a20a0)* Expire in 6 ms for 1 (transfer 0x23fb58a20a0)* Expire in 7 ms for 1 (transfer 0x23fb58a20a0)* Expire in 10 ms for 1 (transfer 0x23fb58a20a0)* Trying 111.13.100.91...* TCP_NODELAY set* Expire in 149983 ms for 3 (transfer 0x23fb58a20a0)* Expire in 200 ms for 4 (transfer 0x23fb58a20a0)* Connected to www.baidu.com (111.13.100.91) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.64.0&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Accept-Ranges: bytes&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform&lt; Connection: Keep-Alive&lt; Content-Length: 2381&lt; Content-Type: text/html&lt; Date: Sat, 16 Feb 2019 02:14:02 GMT&lt; Etag: "588604c8-94d"&lt; Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT&lt; Pragma: no-cache&lt; Server: bfe/1.0.8.18&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.co...... 保存访问的网页(文件会下载到你当前命令执行的所在目录) 使用重定向功能保存curl www.baidu.com &gt;&gt; index.html 1234C:\Users\zp&gt;curl http://www.baidu.com &gt;&gt;index.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2381 100 2381 0 0 27367 0 --:--:-- --:--:-- --:--:-- 27367 使用curl内置option:-o(小写) 保存网页curl -o temp.html www.baidu.com 1234C:\Users\zp&gt;curl -o temp.html www.baidu.com % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2381 100 2381 0 0 27686 0 --:--:-- --:--:-- --:--:-- 27686 使用curl内置option:-O(大写) 保存网页上的文件curl -O http://www.linux.com/hello.sh 1234C:\Users\zp&gt;curl -O http://www.linux.com/hello.sh % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:01 --:--:-- 0 测试网页返回值测试网站是否正常的常用方法curl -o /dev/null -s -w %{http_code} www.linux.com 12C:\Users\zp&gt; curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com301 通过执行代理服务器及端口访问curl -x 192.168.100.100:1080 http://www.linux.com 1# curl -x 192.168.100.100:1080 http://www.linux.com Cookie很多网站上使用cookie记录session信息，curl可以增加相关参数处理cookie信息 保存网站上的cookie，内置option: -c(小写)，文件会存储在你命令执行的位置curl -c cookie.txt www.baidu.com 1234C:\Users\zp&gt;curl -c cookie.txt www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.bai...... 保存http的response里面的header信息，内置option:-Dcurl -D cookie.txt www.baidu.com 1234C:\Users\zp&gt;curl -D cookie.txt www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxleng...... 使用cookie网站访问有时候会检测你的cookie信息是否合法，因此需要使用上面保存的cookie信息，内置option:-bcurl -b cookie.txt www.baidu.com 1234C:\Users\zp&gt;curl -b cookie.txt www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type=submit id=su value=百度一下 class="bg s_btn"&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地....... 模拟浏览器有些网站需要特定的浏览器进行访问，而且还有些需要特定的版本。curl内置option:-A可以让我们指定浏览器去访问网址 1curl -A "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)" http://www.linux.com 伪造referer（盗链）很多服务器会出现检测http访问的rederer从而控制访问。比如：先访问主页，然后再访问主页上的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页地址，断定是盗链curl内置option:-e 可以让我们设定referer 1# curl -e "www.linux.com" http://mail.linux.com 下载文件 利用curl下载文件使用内置option: -o (小写)curl -o baidulogo.png https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png 1234C:\Users\zp&gt;curl -o baidulogo.png https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png?where=super % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 6958 100 6958 0 0 18654 0 --:--:-- --:--:-- --:--:-- 18654 使用内置option: -O (大写)，这个会保存服务器上文件的名字作为本地文件名 1curl -O https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png?where=super 循环下载有时候下载图片可能是前面的部分一样，但是后一部分不一样的情况 1# curl -O http://www.linux.com/dodo[1-5].JPG 下载重名文件如果两次下载的文件重名，就出现文件覆盖的情况，为了不覆盖文件，可执行下面的命令 1# curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG 这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖 分块下载有时候文件比较大，需要分段去下载，使用内置的option:-r 1234curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPGcurl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPGcurl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPGcat dodo1_part* &gt; dodo1.JPG/*这个是linux指令，因此需要在Linux环境下*/ 通过FTP下载文件 12# curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG# curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG 显示下载进度条 1curl -O -# http://www.linux.com/dodo1.JPG 断点续传在Window中，我们可以使用迅雷进行断点续传，curl内置option:-C 同样可以达到相同的效果 1curl -C -O http://www.linux.com/dodo1.JPG 上传文件内置option:-T 实现文件上传，下面是上传一个demo.txt文件到ftp服务器 1curl -T demo.txt -u 用户名:用户密码 ftp://www.linux.com/img/]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Windows</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F02%2F11%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253系统版本：登陆root帐户，输入 cat /etc/redhat-release，。查看CPU信息：grep "model name" /proc/cpuinfo系统位数：uname -a查看已经安装的程序：rpm -qa查看主机名：hostname 解压：tar -zxvf web.tar.gz查看端口号占用情况：netstat -ntlp[root@yan-001 ~] # uname -a # 查看内核/操作系统/CPU信息的linux系统信息命令[root@yan-001 ~] # head -n 1 /etc/issue # 查看操作系统版本，是数字1不是字母L[root@yan-001 ~] # cat /proc/cpuinfo # 查看CPU信息的linux系统信息命令[root@yan-001 ~] # hostname # 查看计算机名的linux系统信息命令[root@yan-001 ~] # lspci -tv # 列出所有PCI设备[root@yan-001 ~] # lsusb -tv # 列出所有USB设备的linux系统信息命令[root@yan-001 ~] # lsmod # 列出加载的内核模块[root@yan-001 ~] # env # 查看环境变量资源[root@yan-001 ~] # free -m # 查看内存使用量和交换区使用量[root@yan-001 ~] # df -h # 查看各分区使用情况[root@yan-001 ~] # du -sh # 查看指定目录的大小[root@yan-001 ~] # grep MemTotal /proc/meminfo # 查看内存总量[root@yan-001 ~] # grep MemFree /proc/meminfo # 查看空闲内存量[root@yan-001 ~] # uptime # 查看系统运行时间、用户数、负载[root@yan-001 ~] # cat /proc/loadavg # 查看系统负载磁盘和分区[root@yan-001 ~] # mount | column -t # 查看挂接的分区状态[root@yan-001 ~] # fdisk -l # 查看所有分区[root@yan-001 ~] # swapon -s # 查看所有交换分区[root@yan-001 ~] # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)[root@yan-001 ~] # dmesg | grep IDE # 查看启动时IDE设备检测状况网络[root@yan-001 ~] # ifconfig # 查看所有网络接口的属性[root@yan-001 ~] # iptables -L # 查看防火墙设置[root@yan-001 ~] # route -n # 查看路由表[root@yan-001 ~] # netstat -lntp # 查看所有监听端口[root@yan-001 ~] # netstat -antp # 查看所有已经建立的连接[root@yan-001 ~] # netstat -s # 查看网络统计信息进程[root@yan-001 ~] # ps -ef # 查看所有进程[root@yan-001 ~] # top # 实时显示进程状态用户[root@yan-001 ~] # w # 查看活动用户[root@yan-001 ~] # id # 查看指定用户信息[root@yan-001 ~] # last # 查看用户登录日志[root@yan-001 ~] # cut -d: -f1 /etc/passwd # 查看系统所有用户[root@yan-001 ~] # cut -d: -f1 /etc/group # 查看系统所有组[root@yan-001 ~] # crontab -l # 查看当前用户的计划任务服务[root@yan-001 ~] # chkconfig –list # 列出所有系统服务[root@yan-001 ~] # chkconfig –list | grep on # 列出所有启动的系统服务程序[root@yan-001 ~] # rpm -qa # 查看所有安装的软件包[root@yan-001 ~] # cat /proc/cpuinfo # 查看CPU相关参数的linux系统命令[root@yan-001 ~] # cat /proc/partitions # 查看linux硬盘和分区信息的系统信息命令[root@yan-001 ~] # cat /proc/meminfo # 查看linux系统内存信息的linux系统命令[root@yan-001 ~] # cat /proc/version # 查看版本，类似uname -r[root@yan-001 ~] # cat /proc/ioports # 查看设备io端口[root@yan-001 ~] # cat /proc/interrupts # 查看中断[root@yan-001 ~] # cat /proc/pci # 查看pci设备的信息[root@yan-001 ~] # cat /proc/swaps # 查看所有swap分区的信息 注释掉系统不需要的用户和用户组注意：不建议直接删除，当你需要某个用户时，自己重新添加会很麻烦。 注释掉不用的用户 1234567891011cp /etc/passwd /etc/passwdbak #修改之前先备份 vi /etc/passwd #编辑用户，在前面加上#注释掉 此行#adm:x:3:4:adm:/var/adm:/sbin/nologin#lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin#sync:x:5:0:sync:/sbin:/bin/sync#shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown#halt:x:7:0:halt:/sbin:/sbin/halt#uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin#operator:x:11:0:operator:/root:/sbin/nologin#games:x:12:100:games:/usr/games:/sbin/nologin#gopher:x:13:30:gopher:/var/gopher:/sbin/nologin#ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin #注释掉ftp匿名账号 注释掉不用的用户用户组 12345678cp /etc/group /etc/groupbak #修改之前先备份 vi /etc/group #编辑用户组，在前面加上#注释掉此行#adm:x:4:root,adm,daemon#lp:x:7:daemon,lp#uucp:x:14:uucp#games:x:20:#dip:x:40: 关闭系统不需要的服务12345678service acpid stop chkconfig acpid off #停止服务，取消开机启动 #电源进阶设定，常用在 Laptop 上service autofs stop chkconfig autofs off #停用自动挂载档桉系统与周边装置service bluetooth stop chkconfig bluetooth off #停用Bluetooth蓝芽service cpuspeed stop chkconfig cpuspeed off #停用控制CPU速度主要用来省电service cups stop chkconfig cups off #停用 Common UNIX Printing System 使系统支援印表机service ip6tables stop chkconfig ip6tables off #禁止IPv6#如果要恢复某一个服务，可以执行下面操作#service acpid start chkconfig acpid on 禁止非root用户执行/etc/rc.d/init.d/下的系统命令12chmod -R 700 /etc/rc.d/init.d/*chmod -R 777 /etc/rc.d/init.d/* #恢复默认设置 给下面的文件加上不可更改属性，从而防止非授权用户获得权限12345678910111213chattr +i /etc/passwdchattr +i /etc/shadowchattr +i /etc/groupchattr +i /etc/gshadowchattr +i /etc/services #给系统服务端口列表文件加锁,防止未经许可的删除或添加服务lsattr /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/services #显示文件的属性 注意：执行以上权限修改之后，就无法添加删除用户了。如果再要添加删除用户，需要先取消上面的设置，等用户添加删除完成之后，再执行上面的操作chattr -i /etc/passwd #取消权限锁定设置 chattr -i /etc/shadow chattr -i /etc/group chattr -i /etc/gshadow chattr -i /etc/services #取消系统服务端口列表文件加锁现在可以进行添加删除用户了，操作完之后再锁定目录文件 限制不同文件的权限12345678910111213chattr +a .bash_history #避免删除.bash_history或者重定向到/dev/nullchattr +i .bash_historychmod 700 /usr/bin 恢复 chmod 555 /usr/binchmod 700 /bin/ping 恢复 chmod 4755 /bin/pingchmod 700 /usr/bin/vim 恢复 chmod 755 /usr/bin/vimchmod 700 /bin/netstat 恢复 chmod 755 /bin/netstatchmod 700 /usr/bin/tail 恢复 chmod 755 /usr/bin/tailchmod 700 /usr/bin/less 恢复 chmod 755 /usr/bin/lesschmod 700 /usr/bin/head 恢复 chmod 755 /usr/bin/headchmod 700 /bin/cat 恢复 chmod 755 /bin/catchmod 700 /bin/uname 恢复 chmod 755 /bin/unamechmod 500 /bin/ps 恢复 chmod 755 /bin/ps 禁止使用Ctrl+Alt+Del快捷键重启服务器123cp /etc/inittab /etc/inittabbakvi /etc/inittab #注释掉下面这一行#ca::ctrlaltdel:/sbin/shutdown -t3 -r now 不随意升级内核使用yum update更新系统时不升级内核，只更新软件包由于系统与硬件的兼容性问题，有可能升级内核后导致服务器不能正常启动，这是非常可怕的，没有特别的需要，建议不要随意升级内核。12345cp /etc/yum.conf /etc/yum.confbak1、修改yum的配置文件 vi /etc/yum.conf 在[main]的最后添加 exclude=kernel*2、直接在yum的命令后面加上如下的参数：yum --exclude=kernel* update查看系统版本 cat /etc/issue查看内核版本 uname -a 关闭Centos自动更新1234567chkconfig --list yum-updatesd #显示当前系统状态yum-updatesd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭service yum-updatesd stop #关闭 开启参数为start停止 yum-updatesd： [确定]service yum-updatesd status #查看是否关闭yum-updatesd 已停chkconfig --level 35 yum-updatesd off #禁止开启启动（系统模式为3、5）chkconfig yum-updatesd off #禁止开启启动（所有启动模式全部禁止）chkconfig --list yum-updatesd #显示当前系统状态yum-updatesd 0:关闭 1:关闭 2:启用 3:关闭 4:启用 5:关闭 6:关闭 关闭多余的虚拟控制台我们知道从控制台切换到 X 窗口，一般采用 Alt-F7 ，为什么呢？因为系统默认定义了 6 个虚拟控制台，所以 X 就成了第7个。实际上，很多人一般不会需要这么多虚拟控制台的，修改/etc/inittab ，注释掉那些你不需要的。123456789cp /etc/inittab /etc/inittabbakvi /etc/inittab# Run gettys in standard runlevels1:2345:respawn:/sbin/mingetty tty1#2:2345:respawn:/sbin/mingetty tty2#3:2345:respawn:/sbin/mingetty tty3#4:2345:respawn:/sbin/mingetty tty4#5:2345:respawn:/sbin/mingetty tty5#6:2345:respawn:/sbin/mingetty tty6 修改history命令记录123cp /etc/profile /etc/profilebakvi /etc/profile找到 HISTSIZE=1000 改为 HISTSIZE=50 隐藏服务器系统信息在缺省情况下，当你登陆到linux系统，它会告诉你该linux发行版的名称、版本、内核版本、服务器的名称。为了不让这些默认的信息泄露出来，我们要进行下面的操作，让它只显示一个”login:”提示符。删除/etc/issue和/etc/issue.net这两个文件，或者把这2个文件改名，效果是一样的。12mv /etc/issue /etc/issuebakmv /etc/issue.net /etc/issue.netbak 优化Linux内核参数1234567cp /etc/sysctl.conf /etc/sysctl.confbakvi /etc/sysctl.conf#在文件末尾添加以下内容net.ipv4.ip_forward = 1#修改为1net.core.somaxconn = 262144net.core.netdev_max_backlog = 262144net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.netfilter.ip_conntrack_max = 131072net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 180net.ipv4.route.gc_timeout = 20net.ipv4.ip_conntrack_max = 819200net.ipv4.ip_local_port_range = 10024 65535net.ipv4.tcp_retries2 = 5net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_len = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_keepalive_time = 120net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000/sbin/sysctl -p #使配置立即生效 十四、CentOS 系统优化1234cp /etc/profile /etc/profilebak2vi /etc/profile #在文件末尾添加以下内容ulimit -c unlimitedulimit -s unlimitedulimit -SHn 65535ulimit -S -c 0export LC_ALL=Csource /etc/profile #使配置立即生效ulimit -a #显示当前的各种用户进程限制 服务器禁止ping12cp /etc/rc.d/rc.local /etc/rc.d/rc.localbakvi /etc/rc.d/rc.local#在文件末尾增加下面这一行echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all参数0表示允许 1表示禁止]]></content>
      <categories>
        <category>服务器</category>
        <category>Linux常用命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux后台执行命令 &和nohup]]></title>
    <url>%2F2019%2F02%2F11%2FLinux%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-%E5%92%8Cnohup%2F</url>
    <content type="text"><![CDATA[当我们在终端或控制台工作时，可能不希望由于运行一个作业而占住了屏幕，因为可能还有更重要的事情要做，比如阅读电子邮件。对于密集访问磁盘的进程，我们更希望它能够在每天的非负荷高峰时间段运行(例如凌晨)。为了使这些进程能够在后台运行，也就是说不在终端屏幕上运行，有几种选择方法可供使用。 使用&amp;当在前台运行某个作业时，终端被该作业占用；可以在命令后面加上&amp;实现后台运行，例如：1sh test.sh &amp; 适合在后台运行find、费时的排序及一些shell脚本。在后台运行作业时要当心：需要用户交互的命令不要放在后台执行（例如需要你去确认是否安装，是否overwrite之类的），否则机器会在哪里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业产生大量的输出，最好使用下面的方法把他重定向输出到某个文件中,具体的实例见下图，当成功提交进程后，会显示一个进程号，可以使用它来监控进程或者杀死进程（ps -ef|grep 查看进程；kill -9 杀死进程）：1command &gt; out.file 2&gt;&amp;1 &amp; 使用nohup使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一旦把当前控制台关掉（退出账户时），作业就会停止运行。nohup命令可以在你退出账号之后继续运行相应的进程。nohup就是不挂起的意思（no hang up），该命令的一般形式如下：1nohup command &amp; 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外制定了输出文件1nohup command &gt; myout.file 2&gt;&amp;1 &amp; 使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台执行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行 相关指令 Ctrl+z可以将一个正在执行的命令放到后台，并且处于暂停状态 jobs查看当前有多少在后台运行的命令，查看的结果是没有进程ID的，所以上面nohup打印进程ID的时候，一定要记下来，好用来结束 2&gt;&amp;12&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行 试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出]]></content>
      <categories>
        <category>服务器</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>后台执行</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10激活方法]]></title>
    <url>%2F2019%2F02%2F11%2FWin10%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法1：创建一个bat文件，里面输入以下命令，然后管理员权限执行以下 123slmgr /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJslmgr /skms kms.firadio.netslmgr /ato 方法二：管理员方式运行下面的bat 下载Win10_KMS_Activation.bat 方法三123456789101.打开“注册表编辑器”；（Windows + R然后输入 Regedit）修改SkipRearm 的值为1：（在HKEY_LOCAL_MACHINE–》SOFTWARE–》Microsoft–》Windows NT–》CurrentVersion–》SoftwareProtectionPlatform里面，将SkipRearm的值修改为1）重启电脑2.以管理员身份启动cmd，输入SLMGR -REARM，根据提示，再次重启电脑！3.slmgr /ipk DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ弹出窗口提示：“成功的安装了产品密钥”。4.slmgr /skms xykz.f3322.org密钥管理服务计算机名称成功设置为xykz.f3322.org5.slmgr /ato按回车键后将弹出窗口提示：“成功的激活了产品”。至此，Win10正式企业版系统激活成功。]]></content>
      <categories>
        <category>办公知识</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap-Treeview实现级联勾选]]></title>
    <url>%2F2019%2F02%2F11%2Fbootstrap-Treeview%E5%AE%9E%E7%8E%B0%E7%BA%A7%E8%81%94%E5%8B%BE%E9%80%89%2F</url>
    <content type="text"><![CDATA[实例化Tree123456$('#searchTree').treeview(&#123; showCheckbox:true, data:treeData, onNodeChecked:nodeChecked , onNodeUnchecked:nodeUnchecked &#125;); 核心方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var nodeCheckedSilent = false; function nodeChecked (event, node)&#123; if(nodeCheckedSilent)&#123; return; &#125; nodeCheckedSilent = true; checkAllParent(node); checkAllSon(node); nodeCheckedSilent = false; &#125; var nodeUncheckedSilent = false; function nodeUnchecked (event, node)&#123; if(nodeUncheckedSilent) return; nodeUncheckedSilent = true; uncheckAllParent(node); uncheckAllSon(node); nodeUncheckedSilent = false; &#125; //选中全部父节点 function checkAllParent(node)&#123; $('#searchTree').treeview('checkNode',node.nodeId,&#123;silent:true&#125;); var parentNode = $('#searchTree').treeview('getParent',node.nodeId); if(!("nodeId" in parentNode))&#123; return; &#125;else&#123; checkAllParent(parentNode); &#125; &#125; //取消全部父节点 function uncheckAllParent(node)&#123; $('#searchTree').treeview('uncheckNode',node.nodeId,&#123;silent:true&#125;); var siblings = $('#searchTree').treeview('getSiblings', node.nodeId); var parentNode = $('#searchTree').treeview('getParent',node.nodeId); if(!("nodeId" in parentNode)) &#123; return; &#125; var isAllUnchecked = true; //是否全部没选中 for(var i in siblings)&#123; if(siblings[i].state.checked)&#123; isAllUnchecked=false; break; &#125; &#125; if(isAllUnchecked)&#123; uncheckAllParent(parentNode); &#125; &#125; //级联选中所有子节点 function checkAllSon(node)&#123; $('#searchTree').treeview('checkNode',node.nodeId,&#123;silent:true&#125;); if(node.nodes!=null&amp;&amp;node.nodes.length&gt;0)&#123; for(var i in node.nodes)&#123; checkAllSon(node.nodes[i]); &#125; &#125; &#125; //级联取消所有子节点 function uncheckAllSon(node)&#123; $('#searchTree').treeview('uncheckNode',node.nodeId,&#123;silent:true&#125;); if(node.nodes!=null&amp;&amp;node.nodes.length&gt;0)&#123; for(var i in node.nodes)&#123; uncheckAllSon(node.nodes[i]); &#125; &#125; &#125;]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>treeview</tag>
        <tag>bootstrap</tag>
        <tag>前端开发框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui下拉及复选动态设置disabled、checked及onchange监听]]></title>
    <url>%2F2019%2F02%2F11%2Flayui%E4%B8%8B%E6%8B%89%E5%8F%8A%E5%A4%8D%E9%80%89%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEdisabled%E3%80%81checked%E5%8F%8Aonchange%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[layui是非模块化引入的12345&lt;link rel="stylesheet" href="plugins/layuiv-2.3.0/css/layui.css"&gt;**********************页面代码*********************&lt;script type="text/javascript" src="plugins/layuiv-2.3.0/layui.all.js"&gt;&lt;/script&gt; html代码1234567891011121314151617181920212223242526272829303132333435&lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;审批意见&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select name="APPVTYPE" lay-filter="appvtype" lay-verify="required" lay-search=""&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty appvTypeList&#125;"&gt; &lt;c:forEach items="$&#123;appvTypeList&#125;" var="appvType" varStatus="vs"&gt; &lt;option value="$&#123;appvType.APPR_CODE&#125;"&gt;$&#123;appvType.APPR_NAME&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;拒件理由&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select name="REFUSALREG" lay-verify="required" lay-search="" disabled=""&gt; &lt;option value=""&gt;&lt;/option&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty refusalRegList&#125;"&gt; &lt;c:forEach items="$&#123;refusalRegList&#125;" var="refusalReg" varStatus="vs"&gt; &lt;option value="$&#123;refusalReg.CODE_VALUE&#125;"&gt;$&#123;refusalReg.CODE_NAME&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="layui-inline"&gt; &lt;div class="layui-input-block"&gt; &lt;input type="checkbox" name="like1[write]" lay-skin="primary" title="加入黑名单" disabled="" id="BLACKLIST"&gt; &lt;/div&gt;&lt;/div&gt; js代码（一定要注意下面的重新渲染）1234567891011121314var form = layui.form;//初始化formform.on('select(appvtype)', function(data)&#123;//监听下拉框onchange if(data.value=="02")&#123; $("select[name^='REFUSALREG']").removeAttr("disabled");//设置下拉框为非只读 $("#BLACKLIST").removeAttr("disabled");//设置复选框为非只读 form.render();//重新渲染所有元素（必须得进行重新渲染，要不没法正常显示） &#125;else&#123; $("select[name^='REFUSALREG']").attr("disabled","disabled");//设置下拉框为只读 $("#BLACKLIST").attr("disabled","disabled");//设置复选框为只读 $("select[name^='REFUSALREG']").val("");//清空下拉框选中的值 $("#BLACKLIST").prop("checked",false);//清空复选框选中的值 form.render();//重新渲染所有元素（必须得重新渲染，要不没法正常显示） &#125;&#125;);]]></content>
      <categories>
        <category>前端开发框架</category>
        <category>layui</category>
      </categories>
      <tags>
        <tag>前端开发框架</tag>
        <tag>layui</tag>
        <tag>下拉框、复选框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery模糊选择器及遍历]]></title>
    <url>%2F2019%2F02%2F01%2FJquery%E6%A8%A1%E7%B3%8A%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[JQuery常规选择器1. 首先是常规使用选择所有元素12345678910$("*")$("body *")$(document).ready(function()&#123; $("body *").css("background-color","#B2E0FF");&#125;);$(function()&#123; $("body *").css("background-color","red");&#125;) 根据id选择元素12345$("#id")$(document).ready(function()&#123; $("#choose").css("background-color","#B2E0FF");&#125;) 根据样式class选择元素该方法常用作选择多个元素123456789$(".class")$(document).ready(function()&#123; $(".className").css("background-color","red");&#125;)$(function()&#123; $(".className").css("background-color","red");&#125;) 获取第一个、最后一个元素12$("p:first")$("p:last") 所有偶数或者所有奇数标签这里的偶数和奇数是索引，索引是从0开始的，因此第一个偶数就是0123$("tr:even") //偶数$("tr:odd") //奇数$("tr:even").css("background-color","#B2E0FF"); 选择index&gt;n 或者小于n的所有对象123$("ul li:gt(3)")$("ul li:lt(3)")$("tr:lt(2)") 选择所有不为空的input123$("selector:not(selector)")$("input:not(:empty)")$("input:not(:empty)") 所有标题元素1$(":header") //所有标题元素 &lt;h1&gt; - &lt;h6&gt; 所有动画元素1$(":animated") 包含指定字符串的所有元素1234$(":contains('W3School')")$("p:contains(is)")$("p:contains(is)").css("background-color","#B2E0FF");$("div:contains(is)").css("background-color","red") 所有无子节点的所有元素1$(":empty") 所有隐藏的标签12$(":hidden")$("p:hidden") 所有可见表格1$("table:visible") 所有带匹配选择的元素1$("th,td,.intro") 所有带某个属性的元素123//公式$("[attribute]")$("[href]")$("li[name]").css("background-color","#B2E0FF");//li标签中带name属性的 所有带某个属性值等于或者不等于XXX的元素123456$("[href='#']")$("input[name='123123']")$("input[name^='123123']")$("[name!='123123']")$("[href!='#']") 包含以XXX开头 XXX结尾的元素12$("input[name^='aaa']")//以aaa开头的所有input元素$("input[name$='bbb']")//所有以bbb结尾的input元素 input的各种类型元素筛选器12345678910$(":input") // 所有 &lt;input&gt; 元素$(":text") //$(":password")//$(":radio")//$(":checkbox")//$(":submit")//$(":reset")//$(":button")//$(":image")//$(":file")// 所有激活或者禁用的元素12$(":enabled")$(":disabled") 下拉框选择中被选中的1$(":selected") 123456789 $(".btn1").click(function()&#123; $(":selected").hide(); &#125;);&lt;select multiple="multiple"&gt; &lt;option&gt;Volvo&lt;/option&gt; &lt;option selected="selected"&gt;Saab&lt;/option&gt; &lt;option&gt;Mercedes&lt;/option&gt; &lt;option&gt;Audi&lt;/option&gt; 单选框、复选框中被选中的1$(":checked").hide(); 2. 模糊选择器前后缀为XXX的选择器1234$("[name^='aaa']")//前缀$("input[name^='aaa']")//前缀$("[name$='aaa']")//后缀$("input[name$='aaa']")//后缀 name中包含XXX的选择器1$("input[name*='aaaa']") 1$("input:text[name='xx']") 3. 遍历12$("input[name^='aaa']").each(function(i)&#123;&#125;)]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>选择器</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery控制组合按钮及div下拉效果及鼠标悬浮显示div效果]]></title>
    <url>%2F2019%2F02%2F01%2FjQuery%E6%8E%A7%E5%88%B6%E7%BB%84%E5%90%88%E6%8C%89%E9%92%AE%E5%8F%8Adiv%E4%B8%8B%E6%8B%89%E6%95%88%E6%9E%9C%E5%8F%8A%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%98%BE%E7%A4%BAdiv%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[效果图 HTML代码1234567891011121314&lt;button id="searchTypeBtn" class="btn btn-default" type="button" style="padding: 2px;margin-left:2px;background-color: #000 !important"&gt; &lt;i class="glyphicon glyphicon-sort" style="margin-left:3px"&gt;&lt;/i&gt; &lt;div class="searchType" style="z-index:99;position: absolute;width: 97px;left: -70px;top: 25px;display: none;color:#000;background-color: #fff;border: 1px solid #eee"&gt; &lt;table class="layui-table" style="margin:0px"&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;not empty moduleTypeList&#125;"&gt; &lt;c:forEach items="$&#123;moduleTypeList&#125;" var="moduleType" varStatus="vs"&gt; &lt;tr onclick="updateModuleList('$&#123;moduleType.CODE_VALUE&#125;')"&gt;&lt;td style="text-align: center;"&gt;$&#123;moduleType.CODE_NAME&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/table&gt; &lt;/div&gt;&lt;/button&gt; JS代码12345678910$(function()&#123; $("#searchTypeBtn").hover( function()&#123; $(".searchType").slideDown(400); &#125;, function()&#123; $(".searchType").slideUp(400); &#125; );&#125;);]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery获取input标签的值(text,radio,checkbox)]]></title>
    <url>%2F2019%2F02%2F01%2FjQuery%E8%8E%B7%E5%8F%96input%E6%A0%87%E7%AD%BE%E7%9A%84%E5%80%BC-text-radio-checkbox%2F</url>
    <content type="text"><![CDATA[本文章转自《jQuery获取input标签的值(text,radio,checkbox)》 这篇文章有个比较好的地方，就是遍历设置复选框的选中状态和获取复选框选中的值并拼装成对应的数据 获取页面上的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;/head&gt; &lt;script src="jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div&gt; &lt;input type="text" placeholder="账号" id="zh"/&gt; &lt;p/&gt; &lt;input type="radio" name="sex" value="0" /&gt;男 &lt;input type="radio" name="sex" value="1" checked="checked"/&gt;女 &lt;p/&gt; &lt;input type="checkbox" name="hobby" value="swim" /&gt;swim &lt;input type="checkbox" name="hobby" value="game" /&gt;game &lt;input type="checkbox" name="hobby" value="video" /&gt;video &lt;p/&gt; &lt;input type="button" id="submit" value="提交" /&gt; &amp;nbsp;&amp;nbsp; &lt;input type="button" id="look" value="查看注册用户信息" /&gt; &lt;div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;$("#submit").click(function()&#123; var zh = $("#zh").val(); var sex = $("[name='sex']:checked").val(); var hobbies = ""; //将hobby复选框的值 总和成 ,, 的形式 $("[name='hobby']:checked").each(function(index, element) &#123; hobbies += $(this).val()+","; &#125;); hobbies = hobbies.slice(0,-1); //用json传值 var user = new User(zh,sex,hobbies); var jsonUser = JSON.stringify(user); console.log(jsonUser); localStorage.setItem("user",jsonUser);&#125;);$("#look").click(function()&#123; window.location="用户信息.html";&#125;);&lt;/script&gt; 设置值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;用户信息&lt;/title&gt; &lt;style&gt; div&#123; margin:100px; font-size:24px; &#125; div input&#123; font-size:24px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;script src="jquery-2.1.1.min.js"&gt;&lt;/script&gt;&lt;script src="user.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div&gt; &lt;input type="text" placeholder="账号" id="zh"/&gt; &lt;p/&gt; &lt;input type="radio" name="sex" value="0" checked="checked"/&gt;男 &lt;input type="radio" name="sex" value="1" /&gt;女 &lt;p/&gt; &lt;input type="checkbox" name="hobby" value="swim" /&gt;swim &lt;input type="checkbox" name="hobby" value="game" /&gt;game &lt;input type="checkbox" name="hobby" value="video" /&gt;video &lt;p/&gt; &lt;input type="button" id="submit" value="修改" /&gt; &lt;div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;$(function()&#123; var jsonUser = localStorage.getItem("user"); var user = JSON.parse(jsonUser); var userClass = new User(); //当json中的key 与 定义类 User中的key (属性名)相同时 赋值 for(var userKey in user)&#123; for(var userClasskey in userClass)&#123; if(userKey == userClasskey)&#123; userClass[userClasskey]=user[userKey]; &#125; &#125; &#125; $("#zh").val(userClass.getName()); $("[name='sex'][value="+userClass.getSex()+"]").attr("checked","checked"); var hobbies = userClass.getHobby().split(","); for(var i=0;i&lt;hobbies.length;i++)&#123; $("[name='hobby'][value="+hobbies[i]+"]").attr("checked","checked"); &#125;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery获取标签的类型及input标签的类型]]></title>
    <url>%2F2019%2F02%2F01%2FJquery%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8Ainput%E6%A0%87%E7%AD%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[常规情况下一班是没有这种需求的，但最近在做页面数据反显，而且数据是反显在p标签里面和span标签里面，因此有了这方面的需求 首先列举一下标签的种类 标签 描述 &lt;a&gt; 定义锚 &lt;article&gt; 定义文章 &lt;b&gt; 定义粗字体 &lt;body&gt; 定义文档的主体 &lt;br&gt; 定义简单的折行 &lt;button&gt; 定义按钮 (push button) &lt;canvas&gt; 定义图形 &lt;code&gt; 定义计算机代码文本 &lt;del&gt; 定义被删除文本 &lt;em&gt; 定义强调文本 &lt;fotter&gt; 定义 section 或 page 的页脚 &lt;form&gt; 定义供用户输入的 HTML 表单 &lt;frame&gt; 定义框架集的窗口或框架 &lt;h1&gt;to&lt;h6&gt; 定义 HTML 标题 &lt;hr&gt; 定义水平线 &lt;i&gt; 定义斜体字 &lt;img&gt; 定义图像 &lt;input&gt; 定义输入控件 &lt;label&gt; 定义 input 元素的标注 &lt;p&gt; 定义段落 &lt;span&gt; 定义文档中的节 &lt;table&gt; 定义表格 &lt;tbody&gt; 定义表格中的主体内容 &lt;td&gt; 定义表格中的单元 &lt;textarea&gt; 定义多行的文本输入控件 &lt;thead&gt; 定义表格中的表头内容 &lt;tr&gt; 定义表格中的行 &lt;ul&gt; 定义无序列表 获取方法12//目前测试了几个p标签是p，span打印span$("#id")[0].tagName.toLowerCase() 问题那么问题来了，就是关于input中包含很多类型，比如说text、button、radio、checkbox等等，怎么获取这些类型进行区分呢？ 12//目前测试能够返回checkbox、radio等等$("#id")[0].type]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JQuery</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP知识点]]></title>
    <url>%2F2019%2F02%2F01%2FJSP%E4%B8%AD%E9%9A%90%E8%97%8FIFrame%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[隐藏iframe提交功能1234//隐藏Iframe提交功能document.forms[0].target = "hiddenFrame";document.forms[0].action = url;document.forms[0].submit(); jsp调用servlet进行页面跳转12request.getRequestDispatcher("/Newpage.jsp").forward(request,response);主要的部分就是红字部分，由于跳转到的页面就在根目录下面，因此只需要跟到（“/Newpage.jsp”）就可以了！]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>JSP</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识点]]></title>
    <url>%2F2019%2F02%2F01%2FCSS%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[CSS模糊筛选器12&lt;!--p是标签的类型，class是标签的属性，important是需要模糊查询的内容--&gt;p[class~="important"] &#123;color: red;&#125; 123div[id^="filePicker"]&#123; width: 200px;&#125; 123456img[title~="Figure"] &#123;border: 1px solid gray;&#125;``` ## JQuery 给样式添加important的样式```css$(".tab_close").css("cssText","display:none !important"); 类型 描述 [abc^=”def”] 选择 abc 属性值以 “def” 开头的所有元素 [abc$=”def”] 选择 abc 属性值以 “def” 结尾的所有元素 [abc*=”def”] 选择 abc 属性值中包含子串 “def” 的所有元素 CSS3实现一直旋转的图片使用方法：①新建一个DIV，class=”demo_div”,div里面放一个图片，就能让图片一直进行旋转了，很好玩123456789101112@-webkit-keyframes rotation&#123; from &#123;-webkit-transform: rotate(0deg);&#125; to &#123;-webkit-transform: rotate(360deg);&#125;&#125;.demo_div&#123; -webkit-transform: rotate(360deg); animation: rotation 3s linear infinite; -moz-animation: rotation 3s linear infinite; -webkit-animation: rotation 3s linear infinite; -o-animation: rotation 3s linear infinite;&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号 模板消息发送]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[前言微信公众号开发，其实很简单，这里是在微信公众号测试账号（公众号沙箱）上的开发流程，具体到生产环境的公众号开发，另行配置，比如说公众号主体信息认证、消息模板配置（审核很严，需要提前进行申请，防止影响业务） 名词介绍 appID：第三方用户唯一凭证 appsecret：第三方用户唯一凭证密钥，即appsecret access_token：公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token，通过接口传递appId和appsecret，而且目前的有效时间是7200s，所以需要定期进行数据再求，更改access_token opendId：用户与公众号对应关系的唯一ID，一个用户对多个公众号有多个不同的openId，一个公众号对不同的用户有不同的openId templete_id：模板ID，发送消息的时候是通过调用接口，传递模板ID和对应模板中的参数进行数据发送的 准备材料 打开微信公众号测试账号地址，登录之后，会显示对应的appID和appsecret，这个获取access_token的时候会用到，需要记录下来 扫描测试账号界面的二维码，关注自己的测试公众号，然后能获取一个opendId，具体界面如下 创建发送消息的模板，获取到一个templete_id（测试公众号的模板是可以随便创建，不需要申请流程，但是每个测试账号下面只能有最多10个测试模板），创建模板的时候，一定要注意规则要传递的变量是以，其中param是你的要传递的参数个人创建的模板为：1&#123;&#123;first.DATA&#125;&#125; 采购单编号：&#123;&#123;keyword1.DATA&#125;&#125; 采购类型：&#123;&#123;keyword2.DATA&#125;&#125; 订货日期：&#123;&#123;keyword3.DATA&#125;&#125; 要求送货日期：&#123;&#123;keyword4.DATA&#125;&#125; &#123;&#123;remark.DATA&#125;&#125; 代码工具类HttpUtils.java和ReadProperties.java HttpUtils类是用作发送网络请求 ReadProperties类是用作读取Properties中的appid和appsecret（因为这两个值一般不会发生变化，所以存在properties文件中） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.io.BufferedReader;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ConnectException;import java.net.CookieHandler;import java.net.CookieManager;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.ProtocolException;import java.net.URL;import java.net.URLConnection;import java.util.Iterator;import java.util.Map;import com.alibaba.fastjson.JSONObject;public class HttpUtils &#123; /** * Do POST request * @param url * @param JsonObject * @return * @throws Exception */ public String doPostForJson(String url, JSONObject jsonObj) throws Exception &#123; System.out.println("POST parameter : " + jsonObj.toString()); URL localURL = new URL(url); URLConnection connection = localURL.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setDoOutput(true); httpURLConnection.setRequestMethod("POST"); httpURLConnection.setRequestProperty("Accept-Charset", "UTF-8"); httpURLConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); httpURLConnection.setRequestProperty("Content-Length", String.valueOf(jsonObj.toString().length())); OutputStream outputStream = null; OutputStreamWriter outputStreamWriter = null; InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; try &#123; outputStream = httpURLConnection.getOutputStream(); outputStreamWriter = new OutputStreamWriter(outputStream,"UTF-8"); outputStreamWriter.write(jsonObj.toString()); outputStreamWriter.flush(); if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception("HTTP Request is not success, Response code is " + httpURLConnection.getResponseCode()); &#125; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (outputStreamWriter != null) &#123; outputStreamWriter.close(); &#125; if (outputStream != null) &#123; outputStream.close(); &#125; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125; /** * 发送GET请求 * @param url * @return * @throws Exception */ public String doGet(String url) throws Exception &#123; URL localURL = new URL(url); URLConnection connection = localURL.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setRequestProperty("Accept-Charset", "utf-8"); httpURLConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception("HTTP Request is not success, Response code is " + httpURLConnection.getResponseCode()); &#125; try &#123; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream,"UTF-8"); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233import java.util.MissingResourceException;import java.util.ResourceBundle;public class ReadProperties &#123; private static final ResourceBundle bundle; static &#123; // 读取propertiest资源文件 bundle = ResourceBundle.getBundle("systemconfig"); &#125; /** * 根据name获得propertiest资源文件里字符串的名 * @param name * @return */ public static String getString(String name) &#123; String value = null; try &#123; value = bundle.getString(name); value = new String(value.getBytes("ISO8859-1"), "UTF-8"); &#125; catch (MissingResourceException e) &#123; System.err.println(e); &#125; catch (Exception ee) &#123; System.err.println(ee); &#125; if ("".equals(value)) &#123; return null; &#125; else &#123; return value; &#125; &#125;&#125; 微信返回消息实体类WeixinAccessTokenEntity.java1234567891011121314151617181920212223/** * 请求微信Token返回的实体类 */public class WeixinAccessTokenEntity &#123; private String accessToken; private long expirationTime; public WeixinAccessTokenEntity(String accessToken, long expirationTime) &#123; this.accessToken = accessToken; this.expirationTime = expirationTime; &#125; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpirationTime() &#123; return expirationTime; &#125; public void setExpirationTime(long expirationTime) &#123; this.expirationTime = expirationTime; &#125;&#125; 发送消息的公共方法类WeChatCommon.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.third.util;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletContext;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.WebApplicationContext;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.third.bean.common.WeixinAccessTokenEntity;/** * 微信公众号相关公共类 * @author zp */public class WeChatCommon &#123; public static JSONObject sendTempleteMsg(String openId,String templateId,Map&lt;String,Object&gt; msgContentMap) &#123; //返回的JSONObject JSONObject jsonObject = new JSONObject(); jsonObject.put("code",-1); //获取access_token String accessToken = ""; try &#123; //首先通过项目全局上下文判断access_token是否失效 WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext application = webApplicationContext.getServletContext(); Object wechatAccessTokenObj = application.getAttribute("tokenMap"); WeixinAccessTokenEntity wechatAccessTokenEntity = wechatAccessTokenObj == null ? null: (WeixinAccessTokenEntity)wechatAccessTokenObj; //如果超期，或者access_token没有的时候，重新生成，并设置到全局上下文中 if(wechatAccessTokenEntity == null || wechatAccessTokenEntity.getExpirationTime()&lt;System.currentTimeMillis()) &#123; accessToken = getAccseeToken(); &#125;else &#123; accessToken = wechatAccessTokenEntity.getAccessToken(); &#125; //如果还是获取失败，则走Exception if(accessToken == null || "".equals(accessToken)) &#123; throw new Exception("获取accessToken失败!"); &#125; //组装发送的JSON串信息 JSONObject sendInfoJsonObject = packSendTemplate(openId,templateId,msgContentMap); //发送网络请求 String urlStr = "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token="+accessToken;//发送消息Url HttpUtils httpUtils = new HttpUtils(); String returnMsgInfoStr = httpUtils.doPostForJson(urlStr, sendInfoJsonObject); System.out.println(returnMsgInfoStr); JSONObject returnMsgInfoJSONObject = JSON.parseObject(returnMsgInfoStr); if(returnMsgInfoJSONObject!=null &amp;&amp; returnMsgInfoJSONObject.getInteger("errcode") == 0) &#123; jsonObject.put("code",0); &#125;else &#123; jsonObject.put("msg",returnMsgInfoJSONObject.get("errmsg")); &#125; &#125; catch (Exception e) &#123; jsonObject.put("msg",e.getMessage()); e.printStackTrace(); &#125; return jsonObject; &#125; /** * 获取access_token * @return */ public static String getAccseeToken() &#123; //首先获取appId和appSecret（这个是读取配置文件*.properties文件），当然你也可以写死成上面获取到的appId和appsecret String appId=ReadProperties.getString("appId"); String appSecret=ReadProperties.getString("appsecret"); WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext application = webApplicationContext.getServletContext(); String url="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid="+appId+"&amp;secret="+appSecret; HttpUtils httpRequestor = new HttpUtils(); String returnData=""; try &#123; returnData = httpRequestor.doGet(url); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; JSONObject json=JSON.parseObject(returnData); if(json.containsKey("access_token"))&#123; if(json.get("access_token")!=null&amp;&amp;!json.get("access_token").equals(""))&#123; //如果获取成功了，设置到程序的全局变量中，当然如果是集群或者其他的话，可以直接放入Redis，并设置失效时间 application.setAttribute("tokenMap", new WeixinAccessTokenEntity(json.get("access_token").toString(), System.currentTimeMillis()+Long.parseLong(json.get("expires_in").toString())*1000)); return json.get("access_token").toString(); &#125; &#125; return null; &#125; /** * 组装微信消息模板JsonObject * @return */ private static JSONObject packSendTemplate(String openId,String templateId,Map&lt;String,Object&gt; msgContentMap) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("touser",openId); jsonObject.put("template_id",templateId); JSONObject dataJSONObject = new JSONObject(); for (Map.Entry&lt;String,Object&gt; entry : msgContentMap.entrySet()) &#123; JSONObject tempContentJSONObject = new JSONObject(); tempContentJSONObject.put("value", entry.getValue()); tempContentJSONObject.put("color", "#173177"); dataJSONObject.put(entry.getKey(),tempContentJSONObject); &#125; jsonObject.put("data",dataJSONObject); return jsonObject; &#125;//没写测试代码，直接写了个main方法进行的测试 public static void main(String args[]) &#123; Map&lt;String,Object&gt; msgContentMap = new HashMap&lt;String,Object&gt;(); msgContentMap.put("first", "欢迎欢迎!"); msgContentMap.put("keyword1", "你好啊123123123"); msgContentMap.put("keyword2", "欢迎欢迎!"); msgContentMap.put("keyword3", "欢迎欢迎!"); msgContentMap.put("keyword4", "欢迎欢迎!"); msgContentMap.put("remark", "欢迎欢迎!"); sendTempleteMsg("openId","templateId",msgContentMap);//这个地方需要修改成用户对应的openId和你自己创建的模板ID &#125;&#125; 总结 WeChatCommon 一定要记住修改openId和templateId为自己的 accsee_token的有效时间目前为两小时 模板中的参数一定要和模板中的参数名字保持一致 生产环境模板一定要尽快申请，防止到时申请（审核时间比较长）不下来影响业务 目前是用项目全局上下文存储的access_token，如果有redis，可以存储在redis中，并设置时间有效]]></content>
      <categories>
        <category>后端插件</category>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信公众号</tag>
        <tag>模板消息发送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ExecutorService限制线程数量]]></title>
    <url>%2F2019%2F01%2F30%2FJava-ExecutorService%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[本文引自使用JAVA的ExecutorService来限制线程数量 前言目前对于线程的了解还是比较少，今天碰到一个使用微信公众号发送微信消息的功能，会出现批量发送的问题，如果排队执行，肯定会需要很长的时间，因此需要起线程执行，但是线程又不可能无限制的一直起，肯定会造成内存溢出类似的问题，因此想到了限制线程数量的方法。查阅了一些文章，提到了ExecutorService能够实现，因此进行了如下记录 概念ExecutorService是什么ExecutorService是Java并行运行的计算库java.util.concurrent包里面的接口，封装原来的难以使用的Java线程，使其简单优化 测试代码线程代码根据给定的生命周期，记录生命周期前后的时间点并输出信息123456789101112131415161718192021222324252627import java.text.SimpleDateFormat;import java.util.Calendar;public class SampleThread implements Runnable &#123; private int no; private int time; SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss"); SampleThread(int no, int time) &#123; this.no = no; this.time = time; &#125; @Override public void run() &#123; //开始执行，显示当前的时间，用于计算进程执行的生命周期 System.out.println("No." + no + " start ID:" + Thread.currentThread().getId() + " 生命周期:" + time + " 现在时间:" + sdf.format(Calendar.getInstance().getTime())); try &#123; Thread.sleep(time * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //执行完毕之后，打印执行结束时的时间 System.out.println("No." + no + " end ID:" + Thread.currentThread().getId() + " 生命周期:" + time + " 现在时间:" + sdf.format(Calendar.getInstance().getTime())); &#125;&#125; 使用ExecutorService调用线程的代码12345678910111213141516171819202122import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123; public static void main(String[] args) &#123; final int MAX_THREADS = 3; //定义线程数最大值 ExecutorService executorService = Executors.newFixedThreadPool(MAX_THREADS); for (int i = 0; i &lt; 10; i++) &#123; int no = i; //随机一个线程能活多少秒 int lifeTime = (int)(Math.random() * 9 + 1); //将线程提交到executorService中，等待执行 executorService.submit(new SampleThread(no, lifeTime)); &#125; System.out.println("executor.shutdown();"); executorService.shutdown(); &#125;&#125; 执行的结果12345678910111213141516171819202122executor.shutdown();No.0 start ID:13 生命周期:4 现在时间:21:52:46No.2 start ID:15 生命周期:4 现在时间:21:52:46No.1 start ID:14 生命周期:1 现在时间:21:52:46No.1 end ID:14 生命周期:1 现在时间:21:52:47No.3 start ID:14 生命周期:2 现在时间:21:52:47No.3 end ID:14 生命周期:2 现在时间:21:52:49No.4 start ID:14 生命周期:6 现在时间:21:52:49No.0 end ID:13 生命周期:4 现在时间:21:52:50No.5 start ID:13 生命周期:2 现在时间:21:52:50No.2 end ID:15 生命周期:4 现在时间:21:52:50No.6 start ID:15 生命周期:6 现在时间:21:52:50No.5 end ID:13 生命周期:2 现在时间:21:52:52No.7 start ID:13 生命周期:2 现在时间:21:52:52No.7 end ID:13 生命周期:2 现在时间:21:52:54No.8 start ID:13 生命周期:7 现在时间:21:52:54No.4 end ID:14 生命周期:6 现在时间:21:52:55No.9 start ID:14 生命周期:5 现在时间:21:52:55No.6 end ID:15 生命周期:6 现在时间:21:52:56No.9 end ID:14 生命周期:5 现在时间:21:53:00No.8 end ID:13 生命周期:7 现在时间:21:53:01Disconnected from the target VM, address: '127.0.0.1:14207', transport: 'socket' 总结 同一个时间点执行的线程数量不会超过MAX_THREAD所定义的数量 从线程的ID可以看出，只有三个线程在跑 有点没搞明白的是：ExecutorService已经在主线程里面调用了shutdown了，但是在子线程还能在正常调度的问题？？？]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程数量控制</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 创建多模块Maven项目]]></title>
    <url>%2F2019%2F01%2F30%2FIDEA-%E5%88%9B%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97Maven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建父模块 依次点击打开File-&gt;New-&gt;Project，具体操作见下图 打开创建项目对话框后，左侧选择Maven，右侧不勾选Create from archetype，然后点击Next，具体操作见下图 输入项目的信息，GroupId和ArtifactId，然后点击Next，具体操作见下图 直接点Next，直接到Finish，最后生成完成之后，删除src文件夹（因为这个是父级模块，因此不需要src文件夹），如下图所示： 创建核心子模块 右键父级模块，点击New-&gt;Module，打开新增Module界面，具体操作见下图： 左侧选择Maven，因为要创建一个普通项目，右侧同样不选择Create from archetype，然后点击Next，如下图所示： GroupId和version继承自父模块，不需要修改，只需要修改ArtifactId，点击Next 输入Module name，模块的名称可以和ArtifactId保持一致即可，具体操作见下图 创建完成后的结构图如下： 创建子模块 第一步和创建核心子模块一样，只是在打开New Module的时候，选上Create from archetype，并选中maven-archetype-webapp 一路点击下去，中间会有一个选择Maven的地方，选择你自己的Maven以及配置文件，然后点到最后，创建的项目路径如下图所示：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>SSM框架搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>搭建</tag>
        <tag>多模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遍历Map的方法]]></title>
    <url>%2F2019%2F01%2F30%2Fjava%E9%81%8D%E5%8E%86Map%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言遍历Map在Java中有好几种方式，但各自方式都有优缺点，不同的方式应用在不同的应用场景中 遍历方法keySet values在使用的过程中只是用到了Map的key或者value，这种是最简单的方式123456789101112// KeySet 获取keypublic void testKeySet() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key); &#125;&#125;// values 获取valuepublic void testValues() &#123; for (Integer value : map.values()) &#123; System.out.println(value); &#125;&#125; keySet get(key)(不推荐使用)如果同时需要key和value，可以先获取key，然后通过key获取到value，但这种方法不推荐使用12345public void testKeySetAndGetKey() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key + ":" + map.get(key)); &#125;&#125; entrySet通过map的entrySet进行遍历，是可以同时拿到key和value的，性能上更好一点，一般是用这种方式获取12345public void testEntry() &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ":" + entry.getValue()); &#125;&#125; IteratorIterator的优势是可以在遍历过程中删除元素123456789// Iterator entrySet 获取key and value public void testIterator() &#123; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + ":" + entry.getValue()); // it.remove(); 删除元素 &#125; &#125; Lambda Lambda是从java1.8开始支持的，语法更简洁，可以拿到key和value，但性能稍微低点 12345public void testLambda() &#123; map.forEach((key, value) -&gt; &#123; System.out.println(key + ":" + value); &#125;);&#125; 总结 单纯获取key或者value，使用keySet 需要同时获取key和value，使用entrySet 遍历过程中如果需要删除操作，使用Iterator 遍历过程中需要添加元素，可以新建一个临时map，遍历完成后，把临时map塞到最终map当中]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>遍历</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 读取和保存properties文件内容]]></title>
    <url>%2F2019%2F01%2F29%2FJava-%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98properties%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[前言最近做微信公众号，需要读取配置文件中的appId等信息，鄙人将这些固定的信息放进了properties文件里面，因此才用到了这块读操作，顺道也把写操作在网上查了下 Properties类Properties类和properties配置文件Properties类继承自Hashtable，并实现了Map的接口，也就是properties文件在Properties类中是以键值对存在的，而且值都是字符串 Properties类的主要的方法 load(InputStream inStream)以文件流的形式加载文件中的信息到Properties类中，具体的代码如下： 1234567Properties pro = new Properties();//文件流读取文件信息FileInputStream inStrem = new FileInputStream("a.properties");//加载数据到Properties类中pro.load(in);//关闭文件流in.close(); store(OutputStream out, String comments)将Properties类中的内容输出保存到properties文件当中，具体的代码如下： 123FileOutputStream outFile = new FileOutputStream("a.properties",true);pro.store(outFile,"Comments");outFile.close(); 如果comments不为空，保存后文件的第一行回事#comments，表示注释信息；如果为空则没有注释信息 getProperty/setProperty这两个方法分别是用来获取和设置properties文件的属性的 代码实例 a.properties文件的内容如下123name=rootpass=liukey=value 读取a.properties文件和生成b.properties文件1234567891011121314151617181920212223242526272829303132import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.util.Iterator;import java.util.Properties;public class PropertyTest &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); try&#123; //读取属性文件a.properties InputStream in = new BufferedInputStream (new FileInputStream("a.properties")); prop.load(in); ///加载属性列表 Iterator&lt;String&gt; it=prop.stringPropertyNames().iterator(); while(it.hasNext())&#123; String key=it.next(); System.out.println(key+":"+prop.getProperty(key)); &#125; in.close(); ///保存属性到b.properties文件 FileOutputStream oFile = new FileOutputStream("b.properties", true);//true表示追加打开 prop.setProperty("phone", "10086"); prop.store(oFile, "The New properties file"); oFile.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; ResourceBundle该类是基于类读取属性：将属性文件当做类，意味着属性文件必须放在包中，使用属性文件的权限定性类名而非路径1234567891011121314151617181920/** * 基于类读取属性文件：该方法将属性文件当作类来处理，属性文件放在包中，使用属性文件的全限定性而非路径来指代文件 */ @Test public void test02() &#123; ResourceBundle bundle = ResourceBundle.getBundle("com.javase.properties.test01"); System.out.println("获取指定key的值"); System.out.println("driver=" + bundle.getString("jdbc.driver")); System.out.println("url=" + bundle.getString("jdbc.url")); System.out.println("username=" + bundle.getString("jdbc.username")); System.out.println("password=" + bundle.getString("jdbc.password")); System.out.println("-----------------------------"); System.out.println("遍历属性文件"); Enumeration&lt;String&gt; keys = bundle.getKeys(); while (keys.hasMoreElements()) &#123; String key = keys.nextElement(); System.out.println(key + "=" + bundle.getString(key)); &#125; &#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>properties文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA2018搭建SSM框架（一）前期搭建]]></title>
    <url>%2F2019%2F01%2F28%2FIDEA2018%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E6%9C%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建环境说明 JDK1.8 IDEA 2018 Maven 3.5.3 搭建步骤1. 首先创建Maven webapp项目 2. 搭建项目结构 搭建完成的文件目录如下 建设完目录的过程中需要设置文件的类型为Source,Test,Resources,设置完成后的效果图如下： 3. 配置文件内容 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.chatRobot&lt;/groupId&gt; &lt;artifactId&gt;ChatRobot&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;ChatRobot Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ChatRobot&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 设置JDK版本 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 记得设置左下角的自动引入 logback.xml选择logback比log4j好，具体原因自己百度 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="true"&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;/root&gt;&lt;/configuration&gt; jdbc.properties 1234567891011121314151617jdbc.driver=com.mysql.jdbc.Driver#数据库地址jdbc.url=jdbc:mysql://xxxxxxxxx:3306/ChatRobot?useUnicode=true&amp;characterEncoding=utf8#用户名jdbc.username=xxxx#密码jdbc.password=xxxxx#最大连接数c3p0.maxPoolSize=30#最小连接数c3p0.minPoolSize=10#关闭连接后不自动commitc3p0.autoCommitOnClose=false#获取连接超时时间c3p0.checkoutTimeout=10000#当获取连接失败重试次数c3p0.acquireRetryAttempts=2 spring-mybatis.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=&quot;com.chatRobot.service&quot;/&gt; &lt;!-- 配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;c3p0.maxPoolSize&#125;&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;$&#123;c3p0.minPoolSize&#125;&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;$&#123;c3p0.autoCommitOnClose&#125;&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;$&#123;c3p0.checkoutTimeout&#125;&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;$&#123;c3p0.acquireRetryAttempts&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.chatRobot.model&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.chatRobot.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.chatRobot.controller&quot;/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;ChatRobot&lt;/display-name&gt; &lt;description&gt;ChatRobot_Alpha_0.0.1&lt;/description&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求，此处也可以配置成 *.do 形式 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 4. 测试 首先导入一份数据库测试文件 1234567891011121314CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户ID&apos;, `email` varchar(255) NOT NULL COMMENT &apos;用户邮箱&apos;, `password` varchar(255) NOT NULL COMMENT &apos;用户密码&apos;, `username` varchar(255) NOT NULL COMMENT &apos;用户昵称&apos;, `role` varchar(255) NOT NULL COMMENT &apos;用户身份&apos;, `status` int(1) NOT NULL COMMENT &apos;用户状态&apos;, `regTime` datetime NOT NULL COMMENT &apos;注册时间&apos;, `regIp` varchar(255) NOT NULL COMMENT &apos;注册IP&apos;, PRIMARY KEY (`id`), UNIQUE KEY `email` (`email`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO `user` VALUES (&apos;1&apos;, &apos;xxx&apos;, &apos;xxxxx&apos;, &apos;xxxxx&apos;, &apos;root&apos;, &apos;0&apos;, &apos;2017-03-28 09:40:31&apos;, &apos;127.0.0.1&apos;);SET FOREIGN_KEY_CHECKS=1; 创建类 UserController.java 123456789101112131415161718192021222324252627282930313233package com.chatRobot.controller;import javax.servlet.http.HttpServletRequest;import com.chatRobot.model.User;import com.chatRobot.service.IUserService;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controller@RequestMapping("/user")public class UserController &#123; @Resource private IUserService userService; @RequestMapping("/showUser.do") public void selectUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); long userId = Long.parseLong(request.getParameter("id")); User user = this.userService.selectUser(userId); ObjectMapper mapper = new ObjectMapper(); response.getWriter().write(mapper.writeValueAsString(user)); response.getWriter().close(); &#125;&#125; IUserDao.java 123456789package com.chatRobot.dao;import com.chatRobot.model.User;public interface IUserDao &#123; User selectUser(long id);&#125; User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.chatRobot.model;import java.util.Date;public class User &#123; private long id; private String email; private String password; private String username; private String role; private int status; private Date regTime; private String regIp; public long getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getRole() &#123; return role; &#125; public void setRole(String role) &#123; this.role = role; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public Date getRegTime() &#123; return regTime; &#125; public void setRegTime(Date regTime) &#123; this.regTime = regTime; &#125; public String getRegIp() &#123; return regIp; &#125; public void setRegIp(String regIp) &#123; this.regIp = regIp; &#125;&#125; IUserService.java 123456789package com.chatRobot.service;import com.chatRobot.model.User;public interface IUserService &#123; public User selectUser(long userId);&#125; UserServiceImpl.java 1234567891011121314151617181920package com.chatRobot.service.impl;import com.chatRobot.dao.IUserDao;import com.chatRobot.model.User;import com.chatRobot.service.IUserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service("userService")public class UserServiceImpl implements IUserService &#123; @Resource private IUserDao userDao; public User selectUser(long userId) &#123; return this.userDao.selectUser(userId); &#125;&#125; UserDao.xml 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 设置为IUserDao接口方法提供sql语句配置 --&gt;&lt;mapper namespace="com.chatRobot.dao.IUserDao"&gt; &lt;select id="selectUser" resultType="User" parameterType="long"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建测试类IUserDaoTest.java 12345678910111213141516171819202122232425package com.chatRobot.dao;import com.chatRobot.model.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;// 加载spring配置文件@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-mybatis.xml"&#125;)public class IUserDaoTest &#123; @Autowired private IUserDao dao; @Test public void testSelectUser() throws Exception &#123; long id = 1; User user = dao.selectUser(id); System.out.println(user.getUsername()); &#125;&#125; 运行测试类，会在控制台输出上面sql文件中用户的名字 继续新建个页面来测试springmvc和mybatis 创建测试类index.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;script&gt; function selectUser() &#123; var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; document.getElementById(&quot;test&quot;).innerHTML = xmlhttp.responseText; &#125; &#125; xmlhttp.open(&quot;POST&quot;, &quot;user/showUser.do&quot;, true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;id=1&quot;); &#125;&lt;/script&gt;&lt;body&gt;&lt;p id=&quot;test&quot;&gt;Hello World!&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;selectUser()&quot;&gt;onclick test&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 新建完成后配置项目运行环境，点击Run-Edit Configurations…点击加号新建运行环境，选择Tomcat Server-Local 选中新建好的服务器，右边选择Deployment,点击加号-Atifact… 选择第二项 然后在右边Application context配置你的项目名 最后运行项目，在打开的页面中点击按钮测试，成功的话会在页面上显示id为1的用户信息]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>SSM框架搭建</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis 返回Map类型key改为小写]]></title>
    <url>%2F2019%2F01%2F28%2Fmybatis-%E8%BF%94%E5%9B%9EMap%E7%B1%BB%E5%9E%8Bkey%E6%94%B9%E4%B8%BA%E5%B0%8F%E5%86%99%2F</url>
    <content type="text"><![CDATA[当使用mybatis查询数据库的时候，会出现查询出来的Map中字段都是大写的，需要进行处理，处理的方法如下 添加别名 别名上添加双引号，查询出来的就是小写了 demo 1234&lt;select id="getStudentList" resultType="java.util.Map"&gt;select t.name as "sName",t.sex as "sSex" from student&lt;/select&gt;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>MyBatis</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>大小写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架DDL操作数据库表]]></title>
    <url>%2F2019%2F01%2F28%2FSSM%E6%A1%86%E6%9E%B6DDL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[创建表123&lt;update id="createTableWithColumn" parameterType="pd"&gt; CREATE TABLE $&#123;MODULE_CODE&#125; ( $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125; ) TABLESPACE USR_XYD_TBS STORAGE ( INITIAL 64K MINEXTENTS 1 MAXEXTENTS UNLIMITED )&lt;/update&gt; 给表添加备注123&lt;update id=&quot;addCommentOnTable&quot; parameterType=&quot;pd&quot;&gt; COMMENT ON TABLE $&#123;MODULE_CODE&#125; IS &apos;$&#123;MODULE_NAME&#125;&apos;&lt;/update&gt; 插入字段123&lt;update id="addItemByDdl" parameterType="pd"&gt; ALTER TABLE $&#123;MODULE_CODE&#125; ADD $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125;&lt;/update&gt; 修改字段123&lt;update id=&quot;editColumnByDdl&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; MODIFY $&#123;ITEM_CODE&#125; $&#123;ITEM_TYPE_AND_SIZE&#125;&lt;/update&gt; 删除字段给字段添加备注123&lt;update id="addCommentOnColumn" parameterType="pd"&gt; COMMENT ON COLUMN $&#123;TABLE_COLUMN&#125; IS '$&#123;ITEM_NAME&#125;'&lt;/update&gt; 添加主键123&lt;update id=&quot;addUniquesOnTable&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; ADD CONSTRAINT $&#123;KEY_NAME&#125; PRIMARY KEY ($&#123;ALL_UNIQUES&#125;)&lt;/update&gt; 删除表上已有的主键123&lt;update id=&quot;dropUniquesOnTable&quot; parameterType=&quot;pd&quot;&gt; ALTER TABLE $&#123;MODULE_CODE&#125; DROP CONSTRAINT $&#123;EXIST_UNIQUES&#125; CASCADE&lt;/update&gt;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>DDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Java接口上传下载文件]]></title>
    <url>%2F2019%2F01%2F28%2F%E9%80%9A%E8%BF%87Java%E6%8E%A5%E5%8F%A3%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Java后台上传文件代码12345678910111213@RequestMapping(value = "/importUserInfo",method = RequestMethod.POST)@ResponseBodypublic JSONObject importUserInfo(@RequestParam String isUpdateFlag,HttpServletRequest request) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("code","-1"); //转换HttpServletRequest为MultipartHttpServletRequest MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; MultipartFile file = multipartRequest.getFile("Fdata"); String fileName = file.getOriginalFilename(); String fileType = fileName.substring(fileName.indexOf(".")); InputStream is = file.getInputStream();&#125; Java后台的接口代码如下12345678910111213141516171819202122@RequestMapping(value = "/downloadExcel",method = RequestMethod.GET)@ResponseBodypublic void downloadExcel(HttpServletRequest request,HttpServletResponse response) &#123; response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=userExcle.xlsx"); try &#123; String path=PathUtil.getClasspath()+"templete/xlsx/userExcle.xlsx"; InputStream inputStream = new FileInputStream(new File(path)); OutputStream os = response.getOutputStream(); byte[] b = new byte[2048]; int length; while ((length = inputStream.read(b)) &gt; 0) &#123; os.write(b, 0, length); &#125; os.close(); inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 前端的接口代码如下直接使用window打开一个新窗口进行下载就可以了，当然也可以通过指向隐藏div进行文件的下载1window.open('http://localhost:8080/MCSForOracle/userManage/downloadExcel');]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>SSM</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA15搭建Maven环境]]></title>
    <url>%2F2019%2F01%2F28%2FIDEA15%E6%90%AD%E5%BB%BAMaven%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[配置Maven软件配置一次即可，所有Maven项目共享 如上图标注3 选择自己的仓库 如上图标注 2 所示，Import Maven projects automatically 表示 IntelliJ IDEA 会实时监控项目的 pom.xml 文件，进行项目变动设置 如上图标注3 所示，在 Maven 导入依赖包的时候是否自动下载源码和文档。默认是没有勾选的，也不建议勾选，原因是这样可以加快项目从外网导入依赖包的速度，如果我们需要源码和文档的时 候我们到时候再针对某个依赖包进行联网下载即可。IntelliJ IDEA 支持直接从公网下载源码和文档的 上图标注 3 所示，可以设置导入的 VM 参数。一般这个都不需要主动改，除非项目真的导入太慢了我们再增大此参数 Maven 骨架创建 Java Web 项目 File -&gt; New -&gt; Project… 如下图 如下图，GroupId和ArtifactId&lt;项目名&gt;还有Version，这三个属性目的是标识你的项目的唯一性 如下图 如下图 点Finish之后，Maven会根据刚才的配置创建一个基于Maven的Web App 创建结束，其Log如下： 创建结束，其代码结构如下 recources文件夹：一般用来存放一些资源文件webapp文件夹：用来存放web配置文件以及jsp页面等，这已经组成了一个原始的web应用启动 Java Web 项目 打开“Project Structure” 配置“Facets” 配置“Artifacts” 启动“Edit Configurations” Add New ‘Tomcat Server’ 配置 配置Deplyment 配置Server 其结果如下 启动Web Server 现在可以通过Browser访问WebServer的页面了。]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>搭建</tag>
        <tag>Maven</tag>
        <tag>Idea15</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz集成SpringMVC 的方案]]></title>
    <url>%2F2019%2F01%2F26%2FQuartz%E9%9B%86%E6%88%90springMVC-%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[废话不说，直接上干货 引入Jar包第一步，首当其冲是引jar包，当然目前我还没把项目弄成maven的，所以也就只能自己copy个jar包到自己的lib包下面 下载quartz-2.2.1.jar 新建spring-quartz.xml第二步,新建一个spring-quartz.xml文件，文件的位置放在和spingMVC的配置文件同级目录即可，spring-quartz.xml可以配置多个任务，列如quartzJobA、quartzJobB，并配置对应的方法和时间表达式（什么时间执行），具体的任务怎么定时，怎么执行都在此文件中 spring-quartz.xml下载链接 修改web.xml第三步，将spring-quartz.xml添加到配置中，配置文件中只需要启动的时候加载上面提到spring-quartz.xml文件 具体使用第四步，具体在Java中的使用方法下载StatisticsTimer 注：cronExpression值有几种如下：123456789101112131415"0 0 12 * * ?" 每天中午12点触发"0 15 10 ? * *" 每天上午10:15触发"0 15 10 * * ?" 每天上午10:15触发"0 15 10 * * ? *" 每天上午10:15触发"0 15 10 * * ? 2005" 2005年的每天上午10:15触发"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发"0 15 10 15 * ?" 每月15日上午10:15触发"0 15 10 L * ?" 每月最后一日的上午10:15触发"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Quart定时器</category>
      </categories>
      <tags>
        <tag>定时器</tag>
        <tag>Quartz</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 Shiro授权]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-Shiro%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[授权，访问控制，在应用中控制哪些用户能够访问哪些资源（如页面/编辑数据/页面操作）。授权需要了解几个关键对象：主题（Subject）、资源（Resource）、权限（Permission）、角色（Role） 主体访问应用的用户。用户只有授权后才允许访问对应的资源 资源在应用中用户可以访问的任何东西，比如JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等都是资源。用户只有首选后才能访问。 权限安全策略中的原子授权单位。通过权限我们可以表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增删改查）式权限控制）打印文档等等 角色角色代表操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较访问。典型的如：项目经理，技术总监、CTO等等，不同的角色拥有不同的权限。 隐式角色直接通过角色来验证用户有没有操作权限，需要在代码中进行维护，比较麻烦，粒度较粗 显示角色在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设某个角色不能访问某个资源，只需要从角色对应的权限集合中移除即可；无须修改多出代码，即粒度是以资源/实例为单位的；粒度较细 授权方式Shiro支持三种方式的授权编程式：通过if/else授权代码块方式123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole("admin"))&#123; //有权限&#125;else&#123; //无权限&#125; 注解式：通过在执行的Java方法上防止相应的注解完成1234@RequiresRoles("admin")public void hello()&#123; //有权限&#125; 没有权限将抛出相应的异常JSP/GSP标签：在JSP/GSP页面通过相应的标签完成：123&lt;shiro:hasRole name="admin"&gt;&lt;!--有权限--&gt;&lt;/shiro:hasRole&gt; 后续部分将详细介绍如何使用 授权基于角色的访问控制（隐式角色）1、在ini配置文件配置用户拥有的角色（shiro-role.ini）123[users]zhang=123,role1.role2wang=123,role1 规则即：“用户名=密码,角色1,角色2”，如果需要在应用中判断用户是否拥有相应的角色，就需要在相应的Realm中返回角色信息，也就是说Shiro不负责维护用户-角色信息，需要应用提供，Shiro只是提供相应的接口方便验证，后续会介绍如何动态的获取用户角色。2、测试用例1234567891011121314151617181920212223242526/** * @ClassName RoleTest * @Description TODO * @Author zp * @Date 2018/11/615:11 * @Version 1.0 **/public class RoleTest extends BaseTest&#123; @Test public void testHasRole()&#123; login("classpath:shiro-role.ini","zhang","123"); //判断拥有角色：role1 Assert.assertTrue(subject().hasRole("role1")); //判断拥有角色：role1 and role2 Assert.assertTrue(subject().hasAllRoles(Arrays.asList("role1","role2"))); //判断拥有角色：role1 and role2 and !role3 boolean[] result = subject().hasRoles(Arrays.asList("role1","role2","role3")); Assert.assertEquals(true,result[0]); Assert.assertEquals(true,result[1]); Assert.assertEquals(false,result[2]); &#125;&#125; Shiro提供了hasRole/hasRoles用于判断用户是否拥有角色/某些权限；但是没有提供如hasAnyRole用于判断是否有某些权限中的一个。12345678@Test(expected = UnauthorizedException.class)public void testCheckRole() &#123; login("classpath:shiro-role.ini", "zhang", "123"); //断言拥有角色：role1 subject().checkRole("role1"); //断言拥有角色：role1 and role3 失败抛出异常 subject().checkRoles("role1", "role3");&#125; Shiro 提供的checkRole/checkRole和hasRole/hasAllRoles不同的地方是他在判断为假的情况下会抛出UnauthorizedException异常。到此基于角色的访问控制（隐式角色）就完成了，这种方式的缺点就是如果很多地方进行角判断，但是有一天不需要了，那么久需要修改相应代码把所有相关的地方进行删除，这就是粗粒度造成的问题。 基于资源的访问控制（显示角色）1、在ini配置文件配置用户拥有的角色角色-权限关系（shiro-permission.ini）12345678zhang=123,role1,role2wang=123,role1[roles]#对资源user拥有create、update权限role1=user:create,user:update#对资源user拥有create、delete权限role2=user:create,user:delete 规则：“用户名=密码，角色1，角色2” “角色=权限1，权限2”，即首先根据用户名找到角色，然后根据角色再找到权限；即角色时权限的集合；Shiro同样不进行权限的额维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户-角色”之间的关系即可。 2、测试用例1234567891011@Testpublic void testPermitted()&#123; login("classpath:shiro-permission.ini","zhang","123"); //判断拥有权限：user:create Assert.assertTrue(subject().isPermitted("user:create")); //判断拥有权限：user:update and user:delete Assert.assertTrue(subject().isPermittedAll("user:update","user:delete")); //断言没有权限user:view Assert.assertFalse(subject().isPermitted("user:view"));&#125; Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或者所有权限，也就是没有提供如isPermittedAny用于判断拥有某一个权限的接口12345678910111213@Test(expected = UnauthorizedException.class)public void testCHeckPermission()&#123; login("classpath:shiro-permission.ini","zhang","123"); subject().checkPermission("user:create"); subject().checkPermissions("user:delete","user:update"); try &#123; subject().checkPermissions("user:view"); &#125; catch (AuthorizationException e) &#123; e.printStackTrace(); &#125;&#125; 到此基于资源的访问控制（显示角色）就完成了，也就是基于权限的访问控制，这种方法一般规则是“资源标识符：操作”。即是资源级别的粒度；这种方式的好处是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户-角色，角色-权限（资源：操作）”之间的关系 Permission字符串通配符权限规则：“资源标识符：操作：对象实例ID”即对那个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“：”表示资源/操作/实例的分割；“，”表示操作的分割；“*”表示任意资源/操作/实例1、单个资源单个权限1subject().checkPermissions("system:user:update"); 拥护拥有资源“system:user”的update权限2、单个资源多个权限ini配置文件1role41=system:user:update,system:user:delete 通过如下代码进行判断1subject().checkPermissions("system:user:update","system:user:delete"); 用户拥有资源“system:user”的update和delete权限。如上可以简写成：ini配置文件（表示角色4拥有system:user资源的update和delete权限）1role42="system:user:update,delete" 接着可以通过如下代码判断：1subject().checkPermissions("system:user:update,delete"); 通过“system:user:update,delete”验证“system:user:update,system:user:delete”是没有问题的，但是反过来是规则不成立的。 3、单个资源全部权限ini配置1role51="system:user:create,update,delete,view" 然后通过如下代码判断1subject().checkPermissions("system:user:create,delete,update,view"); 用户拥有资源“system:user”的“create”、“update”、“delete”和“view”所有权限。如上可以简写成：ini配置文件（表示角色5拥有system:user的所有权限）1role52=system:user:* 也可以简写成（推荐上边的写法）：1role53=system:user 然后通过如下代码判断：12subject().checkPermissions("system:user:*");subject().checkPermissions("system:user"); 通过“system:user:*”验证“system:user:create,delete,update:view”可以，但是反过来是不成立的。 4、所有资源全部权限ini配置1role61=*:view 代码1subject().checkPermissions("user:view"); 用户拥有所有资源的“view”所有权限。假设判断的权限是“system:user:view”，那么需要“role5=::view”这样写才行。 5、实例级别的权限5.1、单个实例单个权限ini配置1role71=user:view:1 对资源user的1实例拥有view权限。通过下面的代码判断1subject().checkPermissions("user:view:1") 5.2、单个实例多个权限ini配置1role72=&quot;user:update,delete:1&quot; 对资源user的1实例拥有update、delete权限然后通过如下代码判断12subject().checkPermissions("user:delete,update:1");subject().checkPermissions("user:update:1","user:delete:1"); 5.3、单个实例所有权限ini配置1role73=user:*:1 对资源user的1实例拥有所有权限然后通过如下代码判断1subject().checkPermissions("user:update:1","user:delete:1","user:view:1"); 5.4、所有实例单个权限ini配置1role74=user:auth:* 对资源user的1实例拥有所有的权限然后通过如下代码判断：1subject().checkPermissions("user:auth:1","user:auth:2"); 5.5、所有实例所有权限ini配置1role75=user:*:* 对资源user的1实例拥有所有权限判断代码1subject().checkPermissions("user:view:1","user:auth:2"); 6、Shiro对权限字符串却是部分的处理如user:view等价于user:view:*；而organization等价于organization:*或者organization:*:*,这种方式实现了前缀匹配。另外如user:*可以匹配user:delete、user:delete可以匹配user:delete:1`user::1,可以匹配如user:view:1、user可以匹配user:view或user:view:1`等。即可以匹配所有，不加可以进行前缀匹配；但是如`:view不能匹配system:user:view，需要::view`，即后缀匹配必须制定前缀（多个冒号就需要多个来匹配）。7、WildcardPermission如下面两种方式是等价的：12subject().checkPermission("menu:view:1")subject.checkPermission(new WildcardPermission("menu:view:1")) 因此没什么必要的话使用字符串更方便。 8、性能问题通配符匹配方式比字符串相等的陪陪来说是更复杂，因此需要花费更长时间，但是一般系统的权限不会太多，且乐意配合缓存来提供其性能，如果这样性能还打不到要求我们可以实现操作算法实现吸能你更好的权限匹配。另外实力级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如sql查询时加上权限字符串之类的方式在查询时就完成权限匹配。 授权流程 流程如下：1、首先调用Subject.isPermitted*/hasROle*接口，其会委托给SecurityManager,而SecurityManager接着会委托给Authorizer;2、Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”),其首先会通过PermissionResolver把字符串转换成相应的Permission实例；3、在进行授权之前，其会调用相应的Real获取Subject相应的角色/权限用于匹配传入的角色/权限。4、Authorizer会判断Realm的角色/权限是否和传入的匹配，如果多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败 ModularRealmAuthorizer进行多Realm匹配流程：1、首先检查相应的Realm是否实现了Authorizer；2、如果实现了Authorizer，那么接着调用其他相应的isPermitted/hasRole接口进行匹配3、如果有一个Realm匹配那么僵返回true，否则返回false； 如果Realm进行授权的话，应该继承AuthorizingRealm，起流程是：1.1、如果调用hasRole*,则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可；1.2、首先调用如isPermitted(“user:view”),首先通过PermissionResolver，即转换为通配符的WildcardPermission；2、通过AuthoricationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo.getStringPermission得到字符串合并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）3、接着调用Permission.implies(Permission p )诸葛与传入的权限比较，如果有匹配的则返回true，否则返回false。 Authorizer、PermissionResolver及RolePermissionResolverAuthorizer的职责是进行授权（访问控制），是ShiroAPI中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其JavaDoc。SecurityManager集成了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例，而RolePermissionResolver用于根据角色解析相应的权限集合。我们可以通过如下ini配置更改Authorizer实现：12authorizer=org.apache.shiro.authz.ModularRealmAuthorizersecurityManager.authorizer=$authorizer 对于ModularRealmAuthorizer，相应的AuthorizingSecurityManager会在初始化完成后自动将相应的realm设置进去，我们也可以通过调用其setRealm()方法进行设置。对于实现自己的authorizer可以参考ModularRealmAuthorizer实现即可，再次不提供示例了。设置ModularRealmAuthorizer的permissionResolver，其会自动设置到相应的Realm上（其实现了PermissionResolverAware接口），如：12permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverauthorizer.permissionResolver=$permissionResolver 设置ModularRealmAuthorizer的rolePermissionResolver,其会自动设置到相应的Realm上（其实现了RolePermissionResolverAware接口），如：12rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolver 示例1、ini配置(shiro-authorizer.ini)12345678910111213141516[main]#自定义authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer#自定义permissionResolver#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverpermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver#自定义rolePermissionResolverrolePermissionResolver=com.github.zhangkaitao.shiro.chapter3.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer#自定义realm 一定要放在securityManager.authorizer赋值之后（因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver）realm=com.github.zhangkaitao.shiro.chapter3.realm.MyRealmsecurityManager.realms=$realm 设置securityManager的realms一定要放在最后，因为在调用SecurityManager.setRealms的时候会将realms设置给authorizer，并为各个Realm设置permissionResolver和rolePermissionResolver。另外，不能使用IniSecurityManagerFactory创建IniRealm，因为其初始化顺序的问题可能会造成后续初始化Permission造成影响。 2、定义BitAndWildPermissionResolver及BitPermissionBitPermission用于实现位移方式权限，规则是：权限字符串格式：+资源字符串+权限位+实例ID；以+开头，中间通过+分割；权限：0表示所有权限；1表示新增（二级制0001）、2表示修改（二级制0010）、4删除（二进制0100）、8查看（二进制1000）；如+user+10表示对资源user拥有修改/查看权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.alibaba.druid.util.StringUtils;import org.apache.shiro.authz.Permission;/** * @ClassName BitPermission * @Description TODO * @Author zp * @Date 2018/11/2716:46 * @Version 1.0 **/public class BitPermission implements Permission &#123; private String resourceIdentify; private int permissionBit; private String instanceId; public BitPermission(String permissionString) &#123; String[] array = permissionString.split("\\+"); if(array.length &gt; 1) &#123; resourceIdentify = array[1]; &#125; if(StringUtils.isEmpty(resourceIdentify)) &#123; resourceIdentify = "*"; &#125; if(array.length &gt; 2) &#123; permissionBit = Integer.valueOf(array[2]); &#125; if(array.length &gt; 3) &#123; instanceId = array[3]; &#125; if(StringUtils.isEmpty(instanceId)) &#123; instanceId = "*"; &#125; &#125; public boolean implies(Permission p) &#123; if(!(p instanceof BitPermission)) &#123; return false; &#125; BitPermission other = (BitPermission) p; if(!("*".equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123; return false; &#125; if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123; return false; &#125; if(!("*".equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123; return false; &#125; return true; &#125; public String toString() &#123; return "BitPermission&#123;" + "resourceIdentify='" + resourceIdentify + '\'' + ", permissionBit=" + permissionBit + ", instanceId='" + instanceId + '\'' + '&#125;'; &#125;&#125; Permission接口提供了boolean implies(Permission p)方法，用于判断权限匹配的123456789101112131415161718192021import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.permission.PermissionResolver;import org.apache.shiro.authz.permission.WildcardPermission;/** * @ClassName BitAndWildPermissionResolver * @Description TODO * @Author zp * @Date 2018/11/2716:49 * @Version 1.0 **/public class BitAndWildPermissionResolver implements PermissionResolver &#123; public Permission resolvePermission(String s) &#123; if(s.startsWith("+"))&#123; return new BitPermission(s); &#125; return new WildcardPermission(s); &#125;&#125; BitAndWildPermissionResolver实现了PermissionResolver接口，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission 3、定义MyRolePermissionResolverPermissionResolver用于根据角色字符串来解析得到权限集合12345678910111213141516171819202122import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.permission.RolePermissionResolver;import org.apache.shiro.authz.permission.WildcardPermission;import java.util.Arrays;import java.util.Collection;/** * @ClassName MyRolePermissionResolver * @Description TODO * @Author zp * @Date 2018/11/2716:53 * @Version 1.0 **/public class MyRolePermissionResolver implements RolePermissionResolver &#123; public Collection&lt;Permission&gt; resolvePermissionsInRole(String s) &#123; if("role1".equals(s))&#123; return Arrays.asList((Permission)new WildcardPermission("menu:*")); &#125; return null; &#125;&#125; 此处的逻辑很简单，如果用户拥有role1，那么就返回“menu:*”的权限4、自定义Realm1234567891011121314151617181920212223242526272829303132333435363738394041import com.smartcore.permission.BitPermission;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.authz.permission.WildcardPermission;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @ClassName MyRealm * @Description TODO * @Author zp * @Date 2018/11/2716:43 * @Version 1.0 **/public class MyRealm extends AuthorizingRealm &#123; protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRole("role1"); authorizationInfo.addRole("role2"); authorizationInfo.addObjectPermission(new BitPermission("+user1+10")); authorizationInfo.addObjectPermission(new WildcardPermission("user1:*")); authorizationInfo.addStringPermission("+user2+10"); authorizationInfo.addStringPermission("user2:*"); return authorizationInfo; &#125; protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String username = (String)token.getPrincipal(); //得到用户名 String password = new String((char[])token.getCredentials()); //得到密码 if(!"zhang".equals(username)) &#123; throw new UnknownAccountException(); //如果用户名错误 &#125; if(!"123".equals(password)) &#123; throw new IncorrectCredentialsException(); //如果密码错误 &#125; //如果身份认证验证成功，返回一个AuthenticationInfo实现； return new SimpleAuthenticationInfo(username, password, getName()); &#125;&#125; 此时我们继承 AuthorizingRealm而不是实现Realm接口；推荐使用 AuthorizingRealm ，因为： AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)：表示获取身份验证信息 AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)：表示根据用户身份获取身份信息这种方式的好处是当需要身份验证时只需要获取身份验证信息而不需要获取授权信息。另外我们还可以使用JdbcRealm，需要如下操作： 执行 sql/ shiro-init-data.sql 插入相关的权限数据 使用shiro-jdbc-authorizer.ini 的配置文件，需要设置jdbcRealm.permissionsLookupEnabled为true来开启权限查询 此次还要注意就是不能把我们自定义的如“+user+10”配置到ini文件中即使有IniRealm完成，IniRealm在new完成后就会解析这些权限字符串，默认使用WildCardPermissionResolver，即此处是一个设计权限，如果采用生命周期（如使用初始化方法）的方式进行加载就可以解决我们自定义permissionResolver的问题。5、测试用例123456789101112131415161718192021222324252627282930import org.junit.Assert;import org.junit.Test;/** * @ClassName AuthorizerTest * @Description TODO * @Author zp * @Date 2018/11/288:47 * @Version 1.0 **/public class AuthorizerTest extends BaseTest&#123; @Test public void testIsPermitted()&#123; login("classpath:shiro-authorizer.ini", "zhang", "123"); //判断拥有权限：user:create Assert.assertTrue(subject().isPermitted("user1:update")); Assert.assertTrue(subject().isPermitted("user2:update")); //通过二级制方式表示权限 Assert.assertTrue(subject().isPermitted("+user1+2"));//新增权限 Assert.assertTrue(subject().isPermitted("+user1+8"));//查看权限 Assert.assertTrue(subject().isPermitted("+user2+10"));//新增及查看权限 Assert.assertTrue(subject().isPermitted("+user1+4"));//没有删除权限 Assert.assertTrue(subject().isPermitted("menu:view"));//通过MyRolePermissionResolver解析得到权限 &#125;&#125; 通过上面的步骤可以实现自定义验证了。另外因为不支持hasAnyRole/isPermittedAny这种方法的授权，可以参考shiro扩展实现NOT、AND、OR权限验证进行简单的扩展完成这个需求，在这篇文章中通过重写 AuthorizingRealm 里面的验证逻辑实现的。 本章节亮点BaseTest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.apache.shiro.util.ThreadContext;import org.junit.After;/** * @ClassName BaseTest * @Description TODO * @Author zp * @Date 2018/11/615:20 * @Version 1.0 **/public abstract class BaseTest &#123; @After public void tearDown() throws Exception &#123; ThreadContext.unbindSubject();//退出时请解除绑定Subject到线程 否则对下次测试造成影响 &#125; protected void login(String configFile,String username,String password)&#123; Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(configFile); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; &#125; public Subject subject() &#123; return SecurityUtils.getSubject(); &#125;&#125;]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 身份认证]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[身份认证: 在应用中证明自己是谁；一般提供用户自己的ID证明自己是谁，比如用户名和密码在Shiro中，用户需要提供principals(身份)和credentials（证明）给shiro，从而验证用户的身份principals: 身份，主体的标识属性，可以是任何东西：邮箱，用户名等等，但必须唯一。一个主体可以有多个principals，但只有一个Primary principalscredentials: 证明，凭据，即主体对应的安全值，如密码/数字证书等。 环境准备Maven配置1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0-RC2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 登录/退出 用户身份凭据（shior.ini）在shiro-test\src\test\resources下创建文件shiro.ini，用来保存用户信息,通过[users]制定了两个主体 123[users]zhang=123wang=123 测试用例 123456789101112131415161718192021222324252627282930313233343536373839import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Assert;import org.junit.Test;public class LoginLogoutTest &#123; @Test public void testHelloworld()&#123; //1、获取SecurityManager工厂，此处使用ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro.ini"); //2、得到SecurityManager实例 并绑定SecurityUtil org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（用户身份证/凭据） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; //4、登录，即身份验证成功 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份认证失败 e.printStackTrace(); &#125; Assert.assertEquals(true,subject.isAuthenticated());//断言用户已经登录 //6、退出 subject.logout(); &#125;&#125; 代码解析 1、首先通过new IniSecurityManagerFactory并制定一个ini文件来创建一个SecurityManager工厂；2、接着获取SecurityManager并绑定到SecurityUtils, 这是一个全局设置，设置一次即可3、通过SecurityUtil得到Subject,其会自动绑定到当前线程；如果web环境在请求结束，需要解除绑定；然后获取身份认证的Token，如用户名/密码4、调用subject.log方法进行登录，其会自动委托给SecurityManager.login方法进行登录5、如果身份验证失败请捕获AuthenticationException或其子类，常见如：DiabledAccountExceprion(禁用的账号)、LockedAccountException(锁定的账号)、UnKnownAccountException（未知的账号）、、ExcessiveAttemptsException(登录失败次数过多)、IncorrectCredentialsException（错误凭证）、ExpiredCredentialsException(过期凭证)，对于错误消息的展示，最好使用“用户名或密码不正确”，防止提示太过详细，容易出现恶意扫描账号6、最后可以调用subject.logout退出如上代码可总结出身份验证的步骤：1、收集用户身份凭据，如用户名和密码2、调用Subject.login()进行登录，如果失败，得到相应的AuthenticationException异常；否则登录成功3、调用Subject.logout进行退出操作 身份认证的流程 首先调用Subject.login(token)进行登录，其会自动委托给SecurityManager，调用之前必须通过SecurityUtil.setSecurityManger()设置 SecurityManager负责真正的身份验证逻辑；他会委托给Authenticator进行身份验证 Authenticator才是真正的身份验证者， 可以自定义自己的实现 Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator 会把相应的token传入Realm，从Realm中获取身份验证信息，如果没有返回或者抛出异常表明身份验证失败。可以自定义多个Realm，将按照相应的顺序和策略进行访问 RealmRealm： 域,Shiro从Realm中获取安全数据（用户、角色、权限），可以理解为Realm是DataSource，安全数据源，如上面配置的ini文件使用的org.apache.shiro.realm.text.IniRealm org.apache.shiro.realm.Realm接口如下1234String getName();//返回一个唯一的Realm的名字boolean supports(AuthenticationToken token)//判断此Realm是否支持此TokenAuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;//根据Token获取认证信息 单Realm配置 自定义Realm实现 123456789101112131415161718192021222324252627import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;public class MyRealm1 implements Realm &#123; public String getName() &#123; return "myrealm1"; &#125; public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken;//仅支持UsernamePasswordToken类型的Token &#125; public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials());//得到密码 if(!"zhang".equals(userName))&#123; throw new UnknownAccountException();//用户名错误 &#125; if(!"123".equals(password))&#123; throw new IncorrectCredentialsException();//密码错误 &#125; return new SimpleAuthenticationInfo(userName,password,getName()); &#125;&#125; ini配置文件指定自定义的Realm（shiro-realm.ini） 1234# 声明一个realmmyRealm1=com.shirotest.realm.MyRealm1# 指定securityManager的realms实现securityManager.realms=$myRealm1 测试代码 123456789101112131415161718192021222324252627@Testpublic void testCustomRealm()&#123; //1、获取SecurityManager工厂，此处使用ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;); //2、得到SecurityManager实例，绑定SecurityUtil SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名和密码对应的Token Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;); try &#123; //4、登录，即身份验证成功 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份认证失败 e.printStackTrace(); &#125; Assert.assertEquals(true,subject.isAuthenticated());//断言用户已经登录 //6、退出 subject.logout();&#125; 多Realm实现1、myRealm2代码12345678910111213141516171819202122232425262728293031import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;public class MyRealm2 implements Realm &#123; @Override public String getName() &#123; return &quot;myrealm2&quot;; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials()); if(!&quot;wang&quot;.equals(userName))&#123; throw new UnknownAccountException();//账号错误 &#125; if(!&quot;123&quot;.equals(password))&#123; throw new IncorrectCredentialsException();//密码错误 &#125; //如果认证通过，返回一个AuthenticationInfo实现 return new SimpleAuthenticationInfo(userName,password,getName()); &#125;&#125; 2、ini配置文件（shiro-multi-realm.ini）12345# 声明一个realmmyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2# 指定securityManager的realms实现securityManager.realms=$myRealm1,$myRealm2 security按照realm指定的顺序进行身份认证。 此处我们使用显示指定顺序的方式指定了Realm的顺序，如果删除掉securityManager.realms=$myRealm1,$myRealm2，那么securityManager会按照realm声明的顺序进行使用（即无需声明顺序，系统会自动查找Realm），当我们显示指定realm后，其他没有指定的realm会被忽略，如securityManager.realms=$myRealm1,myRealm2会被自动忽略 3、测试代码12345678910111213141516171819@Testpublic void testCustomMultiRealm()&#123; Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:shiro-multi-realm.ini"); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; subject.logout();&#125; Shiro默认提供的Realm 以后一般集成AuthorizingRealm(授权)即可；其集成了AuthenticatingRealm（即身份认证），而且间接集成了CachingRealm(带缓存实现)。其中主要默认实现如下：org.apache.shiro.realm.text.IniRealm: [users]部分指定用户名/密码及对应角色；[roles]部分指定角色即角色授权信息；org.apache.shiro.realm.text.PropertiesRealm: user.username=password,role1,role2指定用户/密码及角色；role.role1=permission1,permission2指定角色对应即权限；org.apache.shiro.realm.jdbc.JdbcRealm:通过sql查询相应的信息，如select password from users where username = ? 获取用户密码;select password,password_salt from users where username = ?获取用户密码及盐；select permission from role_permissions where role_name = ?获取角色对应权限；也可以调用相应的api进行自定义sql； JDBC Realm使用1、数据库及依赖(pom.xml)12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0-RC2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、数据库shiro创建三张表：users（用户名/密码）、user_roles(用户/角色)、roles_permissions(角色权限)，并添加一个用户名/密码为zhang/123;123456789101112131415161718192021222324252627282930drop database if exists shiro;create database shiro;use shiro;create table users ( id bigint auto_increment, username varchar(100), password varchar(100), password_salt varchar(100), constraint pk_users primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_users_username on users(username);create table user_roles( id bigint auto_increment, username varchar(100), role_name varchar(100), constraint pk_user_roles primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_user_roles on user_roles(username, role_name);create table roles_permissions( id bigint auto_increment, role_name varchar(100), permission varchar(100), constraint pk_roles_permissions primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_roles_permissions on roles_permissions(role_name, permission);insert into users(username,password)values('zhang','123'); 3、ini配置（shiro-jdbc.realm.ini）123456789[main]jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://192.168.2.62:3306/shirodataSource.username=rootdataSource.password=mcprdjdbcRealm.dataSource=$dataSourcesecurityManager.realms=$jdbcRealm Authenticator及AuthenticationStrategyAuthenticator的职责是验证用户账号，是Shiro API中身份验证核心的入口点：1public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException 如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败抛出相应的AuthenticationException实现。SecurityManager接口集成了Authenticator，另外还有一个ModularRealAuthenticator实现，其委托了多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：FirstSuccessfulStrategy：只要有一个Realm验证通过即可，只返回第一个Realm身份验证成功的认证信息，其他忽略AtLeastOneSuccessfulStrategy:只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同点载于，返回所有Realm身份验证成功的认证信息AllSuccessfulStrategy:所有Realm验证成功，且返回所有的Realm验证成功信息，如果有一个失败就整个失败。 ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。假设有三个Realm： myRealm1：用户名和密码分别为zhang/123的时候登录成功，并返回登录信息zhang/123 myRealm2：用户名和密码分别为wang/123的时候登录成功，并返回登录信息wang/123 myRealm3：用户名和密码分别为zhang/123的时候登录成功，并返回登录信息zhang@163.com/123myRealm3和myRealm1基本上一样，但是返回时的身份变了 1、ini配置文件（shiro-authenticator-all-success.ini）12345678910111213[main]# 指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator# 指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2myRealm3=com.shirotest.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3 2、MyRealm3的代码12345678910111213141516171819202122232425262728293031323334353637import org.apache.shiro.authc.*;import org.apache.shiro.realm.Realm;/** * @ClassName MyRealm3 * @Description TODO * @Author zp * @Date 2018/11/313:47 * @Version 1.0 **/public class MyRealm3 implements Realm &#123; @Override public String getName() &#123; return "myrealm3"; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String)authenticationToken.getPrincipal(); String password = new String((char[])authenticationToken.getCredentials()); if(!"zhang".equals(userName))&#123; throw new UnknownAccountException(); &#125; if(!"123".equals(password))&#123; throw new IncorrectCredentialsException(); &#125; return new SimpleAuthenticationInfo(userName+"@163.com",password,getName()); &#125;&#125; 3、测试代码3.1、测试全部验证成功并返回多条成功验证结果记录（ AllSuccessfulStrategy ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.junit.Assert;import org.junit.Test;/** * @ClassName AuthenticatorTest * @Description TODO * @Author zp * @Date 2018/11/313:59 * @Version 1.0 **/public class AuthenticatorTest &#123; @Test public void testAllSuccessfulStrategyWithSuccess()&#123; login("shiro-authenticator-all-success.ini"); Subject subject = SecurityUtils.getSubject(); //得到一个身份集合，其包含了Realm验证成功的身份信息 PrincipalCollection principalCollection = subject.getPrincipals(); Assert.assertEquals(2,principalCollection.asList().size()); &#125; /** *@Description 常规测试登录代码 *@param [configFile] *@return void *@author zp *@date 2018/11/3 15:56 **/ private void login(String configFile)&#123; Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory("classpath:"+configFile); org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("zhang","123"); subject.login(token); &#125;&#125; 3.2、测试不能通过所有验证，返回失败代码（AllSuccessfulStrategy）12345678910111213[main]# 指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator#指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.shirotest.realm.MyRealm1myRealm2=com.shirotest.realm.MyRealm2myRealm3=com.shirotest.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm2 1234@Test(expected = UnknownAccountException.class)public void testAllSucessfulStrategyWithFail()&#123; login("shior-authenticator-all-fail.ini");&#125; shiro-authenticator-all-fail.ini 与 shiro-authenticator-all-success.ini不同的配置是使用了securityManager.realms=$myRealm1,$myRealm2；即myRealm2验证失败。 对于AtLeastOneSuccessfulStrategy和FirstSuccessfulStrategy的区别，在与第一个是至少有一个满足就可以验证通过，第二个是只要找到一个就可以通过验证，并且返回第一个验证通过的Realm信息。 自定义AuthenticationStrategy实现：]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 Shiro简介]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Shiro%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介 Shiro不仅可以应用在JavaSE环境，也可以用在JavaEE环境。 Shiro能够完成的任务： 认证 授权 加密 会话管理 Web集成 缓存 Authentication:身份认证/登录，验证用户是否拥有相应的身份 Authorization:授权，权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户是否对某个资源是否具有某个权限 Session Manager:会话管理，用户登录后就是一次会话，在没有退出之前，他的所有信息都会在会话中 Cryptography:加密，保护数据的安全性，如密码加密存储到数据库，而不是铭文存储 Web Support:Web支持，可以非常容易的集成到Web环境 Caching:缓存，比如用户登录后，其用户信息，拥有的角色/授权信息不必每次去查询，这样可以提高效率 Concurrency:shiro支持多线程应用的并发验证，即如果在一个线程中开一另一个线程，能够把权限自动传播过去 Testing:提供测试支持 Run As:允许一个用户假装为另一个用户的身份访问 Remember Me:记住我，下次再来不用登陆了 Shiro是不会去维护权限、用户的数据的；这些需要我们自己去设计/提供；然后通过相应的接口注入到Shiro 从上图可以看出应用程序代码直接交互的对象是Subject，也就是Shiro的对外核心API是Subject： Subject:主体，代表当前用户，不一定是具体的人，与当前应用交互的所有对象都可以使Subject；所有的Subject都是绑定到SecurityManager的，也就是最终干活的都是SecurityManager，Subject只是一个门面 SecurityManager:安全管理器，所有与安全有关的操作都会与SecurityManager交互，而且它管理着所有的Subject。它同时负责着与后面其他的组件的交互。 Realm:域，Shiro从Realm获取安全数据（用户，角色，权限）；SecurityManager验证用户的时候，需要从Realm中读取数据，验证用户数据的合法性，同时还需要从Realm中读取用户的权限和角色验证用户是否能够操作。简单的来说可以从认为Realm为一个DataSource，即安全数据源 最简单的Shiro应用设计思路： 应用通过Subject来进行认证和授权，而Subject委托给SecurityManager进行处理 我们需要给SecurityManager注入Realm，从而让SecurityManager获取到相应的用户及权限进行判断 Subject:主体，可以看到主体是任何可以与应用交互的“用户” SecurityManager:Shiro的心脏，具体的交互都通过Securitymanager进行控制；管理所有的Subject，进行权限、授权、会话及缓存的管理 Authenticator:认证器，负责主体认证，可自定义实现；其需认证策略（Authentication Strategy），即什么情况下算是用户通过了 Authrizer:授权器，用来决定主体是否有权限进行相应的操作 Realm:可以有一个或者多个，安全实体数据源，用于获取安全实体，一般是自己实现Realm SessionManager:Session的管理组件，可以通过专门的Session管理服务器实现分布式会话 SessionDao:当需要把Session存储到数据库的时候使用的工具 CacheManager:缓存控制器，来管理用户、角色、权限的缓存 Cryptograpy:密码模块，Shiro提供了一些常见的加密组件用于密码加密和解密]]></content>
      <categories>
        <category>后端开发框架</category>
        <category>Shiro</category>
        <category>跟我学Shiro-张开涛</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>后端开发框架</tag>
        <tag>张开涛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS正则表达式校验手机号、邮箱、网址、日期、身份证]]></title>
    <url>%2F2019%2F01%2F25%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%A1%E9%AA%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%E3%80%81%E9%82%AE%E7%AE%B1%E3%80%81%E7%BD%91%E5%9D%80%E3%80%81%E6%97%A5%E6%9C%9F%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%2F</url>
    <content type="text"><![CDATA[常规正则表达式1234567891011121314151617181920212223验证手机号：/^1\d&#123;10&#125;$/验证邮箱：/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/验证url：/(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/日期：/^(\d&#123;4&#125;)[-\/](\d&#123;1&#125;|0\d&#123;1&#125;|1[0-2])([-\/](\d&#123;1&#125;|0\d&#123;1&#125;|[1-2][0-9]|3[0-1]))*$/证身份证：/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(x|X|\d)$)/中文：[\u4e00-\u9fa5]电话号码（国内）：[0-9-()（）]&#123;7,18&#125;邮政编码：\d&#123;6&#125;IP地址：(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)正整数：[1-9]\d*负整数：-[1-9]\d*用户名：[A-Za-z0-9_\-\u4e00-\u9fa5]+ 使用方法12345var reg=/(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/;if(!reg.test(data.field.link))&#123; layer.msg(&apos;外链格式错误，请输入以http://或https://开头的完整url！&apos;,&#123;icon: 5&#125;); return false;&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>正则校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Url中传递JSONObject、JSONArray对象]]></title>
    <url>%2F2019%2F01%2F25%2FUrl%E4%B8%AD%E4%BC%A0%E9%80%92JSONObject%E3%80%81JSONArray%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Url中传递JSONObject 首先说明下项目背景，要求用layer.open打开一个页面，但是传递的主键字段是不确定的，因此需要组装一个JSONObject，里面放入动态的主键，从而让后台通过JSON遍历得到主键，然后进行数据的查询 首先想到的是通过JSON.stringify()方法(不可行)但是发现上面的思路是不可行的，以为会出现json中的双引号，造成只能传递一个{到后台，不能传递整个JSON 第二种方法是使用encodeURI()方法(可行)12345678layer.open(&#123; 'title': '编辑数据', // 弹出框标题 'shade': [0.8, '#393D49'], // 遮盖罩 'type': 2, // 打开类型 'area': ['80%', '80%'], // 弹出框大小 'maxmin': true, // 最大化 content: basePath + 'customManage/openListChildPage.do?TYPE_ID='+ encodeURI(jsonObj) &#125;); 多扯两句，关于ajax传递json对象到后台的问题这个问题相对简单，是可以直接使用ajax的data内置参数，直接传递json对象到后台的]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSONObject</tag>
        <tag>JSONArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS setInterval()方法]]></title>
    <url>%2F2019%2F01%2F25%2FJS-setInterval-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[定义和用法setInterval是按照指定周期（毫秒）调用函数或计算表达式，会不停的调用函数，直到调用clearInterval或者窗口关闭。其中setinterval返回的ID可以用作clearInterval方法的参数 语法1setInterval(code,millisec[,"lang"]) 参数 是否必须 描述 code 是 循环调用的代码或者需要执行的代码穿 millisec 是 执行的周期，毫秒为单位 返回值可以用作clearInterval()从而取消code循环执行的ID 实例123456789101112131415161718&lt;html&gt;&lt;body&gt;&lt;input type="text" id="clock" size="35" /&gt;&lt;script language=javascript&gt;var int=self.setInterval("clock()",50)function clock() &#123; var t=new Date() document.getElementById("clock").value=t &#125;&lt;/script&gt;&lt;/form&gt;&lt;button onclick="int=window.clearInterval(int)"&gt;Stop interval&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>setInterval</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS字符串转JSON对象]]></title>
    <url>%2F2019%2F01%2F25%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACJSON%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS字符串转换成JSON对象目前发现了四种方法 1. Jquery方法示例代码:123//将json字符串转换成json对象$.parseJSON(jsonStr);jQuery.parseJSON(jsonStr) 2. 浏览器支持转换的方法（Firefox、Chrome、opera、safari、ie）1JSON.parse(jsonstr)//可以将json字符串转换成json对象 1JSON.stringify(jsonOjb)//可以将JSONObject转换成json字符串 3. Javascript支持的转换方式（不建议）1eval(&apos;(&apos; + jsonstr + &apos;)&apos;); 4. JSON官方的转换方式JSON官网提供的Github上的关于JSON转换的方法 当然还有很多方法，在官网下面有很多各个语言的处理方法，具体的链接可以查看]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js动态创建a标签并添加事件]]></title>
    <url>%2F2019%2F01%2F25%2Fjs%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAa%E6%A0%87%E7%AD%BE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目中有一个新需求，前后台分离，然后前台需要拿到数据后动态的创建a标签，并且给a标签上添加上事件，而且事件的参数是不一样的 下面是一种方法，可以尝试下12345678910111213for(var i=0;i &lt; datalist.length;i++)&#123; (function(i)&#123; var a=document.createElement('a'); var innerText = datalist[i].DOC_NAME a.innerHTML=innerText; a.addEventListener('click',function(e)&#123; e.preventDefault(); //取消默认事件，指a标签 alert(121); &#125;); $("#all-items").append(a); &#125;)(i);&#125;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>动态添加事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webuploader同一页面多实例上传图片及回显]]></title>
    <url>%2F2019%2F01%2F25%2Fwebuploader%E5%90%8C%E4%B8%80%E9%A1%B5%E9%9D%A2%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%8F%8A%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[1. 业务页面JSP(goods_detail_edit.jsp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;overview &amp; stats&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;link href=&quot;static/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;static/css/bootstrap-responsive.min.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/font-awesome.min.css&quot; /&gt;&lt;!-- 下拉框 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/chosen.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace-responsive.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/ace-skins.min.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;!--提示框--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery.tips.js&quot;&gt;&lt;/script&gt;&lt;!-- 上传图片 --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;plugins/webuploader/webuploader.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;plugins/webuploader/style.css&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;td input &#123; width: 97%;&#125;tr th &#123; font-size: 13px; font-weight: bold; vertical-align: middle;&#125;#wrapper &#123; margin: 0;&#125;#uploader .placeholder &#123; background: url(plugins/webuploader/image.png) center 23px no-repeat; padding-top: 88px; min-height: 110px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;goodsDetail/$&#123;msg &#125;.do&quot; name=&quot;goodsForm&quot; id=&quot;goodsForm&quot; method=&quot;post&quot;&gt; &lt;div id=&quot;zhongxin&quot;&gt; &lt;table id=&quot;table_report&quot; class=&quot;table table-striped table-bordered table-hover&quot;&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品编码:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;hidden&quot; id=&quot;checkGoodsCode&quot; value=&quot;$&#123;pd.goods_code&#125;&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;GOODS_CODE&quot; id=&quot;GOODS_CODE&quot; value=&quot;$&#123;pd.goods_code&#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入商品编码&quot; title=&quot;商品编码&quot; onblur=&quot;checkHasCode()&quot; /&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品类型:&lt;/th&gt; &lt;td&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;GOODS_TYPE&quot; id=&quot;GOODS_TYPE&quot; data-placeholder=&quot;请选择商品类型&quot; style=&quot;vertical-align:top;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;cateGoryList&#125;&quot; var=&quot;cateGory&quot;&gt; &lt;option value=&quot;$&#123;cateGory.GOODS_TYPE&#125;&quot; &lt;c:if test=&quot;$&#123;pd.goods_type==cateGory.GOODS_TYPE&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;$&#123;cateGory.DESCRIPTION &#125; &lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品名称:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;GOODS_NAME&quot; id=&quot;GOODS_NAME&quot; value=&quot;$&#123;pd.goods_name &#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入商品名称&quot; title=&quot;商品名称&quot; /&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;商品别名:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;GOODS_ABBR_NAME&quot; id=&quot;GOODS_ABBR_NAME&quot; value=&quot;$&#123;pd.goods_abbr_name &#125;&quot; maxlength=&quot;64&quot; placeholder=&quot;请输入商品别名&quot; title=&quot;商品别名&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;特殊商品:&lt;/th&gt; &lt;td style=&quot;vertical-align:top;&quot;&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;IS_SPECIAL&quot; id=&quot;IS_SPECIAL&quot; data-placeholder=&quot;是否特殊商品&quot; style=&quot;vertical-align:top;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Y&quot; &lt;c:if test=&quot;$&#123;pd.is_special==&apos;Y&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;特殊商品&lt;/option&gt; &lt;option value=&quot;N&quot; &lt;c:if test=&quot;$&#123;pd.is_special==&apos;N&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;非特殊商品&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;是否有效:&lt;/th&gt; &lt;td style=&quot;vertical-align:top;&quot;&gt;&lt;select class=&quot;chzn-select&quot; name=&quot;IS_VALID&quot; id=&quot;IS_VALID&quot; data-placeholder=&quot;是否有效&quot; style=&quot;width: 42%&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Y&quot; &lt;c:if test=&quot;$&#123;pd.is_valid==&apos;Y&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;有效&lt;/option&gt; &lt;option value=&quot;N&quot; &lt;c:if test=&quot;$&#123;pd.is_valid==&apos;N&apos;&#125;&quot;&gt;selected&lt;/c:if&gt;&gt;无效&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th style=&quot;vertical-align: middle&quot;&gt;菜单编码:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;MENU_CODE&quot; id=&quot;MENU_CODE&quot; value=&quot;$&#123;pd.menu_code &#125;&quot; maxlength=&quot;6&quot; placeholder=&quot;请输入菜单编码&quot; title=&quot;菜单编码&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;textarea name=&quot;GOODS_DESC&quot; id=&quot;GOODS_DESC&quot; rows=&quot;5&quot; cols=&quot;50&quot; style=&quot;width:99%;&quot; placeholder=&quot;请选输入商品描述&quot; title=&quot;请选输入商品描述&quot;&gt;$&#123;pd.goods_desc&#125;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;FILE_PATH&quot; id=&quot;FILE_PATH&quot; value=&quot;$&#123;pd.FILE_PATH&#125;&quot; /&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;container&quot; class=&quot;uploadFile&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePicker&quot;&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选5张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;detail_image_url&quot; id=&quot;detail_image_url&quot; value=&quot;$&#123;pd.detail_image_url&#125;&quot; /&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;container&quot; class=&quot;uploadFile&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePickerDetail&quot;&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选5张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align: center;&quot; colspan=&quot;4&quot;&gt; &lt;a class=&quot;btn btn-mini btn-primary&quot; onclick=&quot;save();&quot;&gt;保存&lt;/a&gt; &lt;a class=&quot;btn btn-mini btn-danger&quot; onclick=&quot;top.Dialog.close();&quot;&gt;取消&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=&quot;zhongxin2&quot; class=&quot;center&quot; style=&quot;display:none&quot;&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;img src=&quot;static/images/jiazai.gif&quot; /&gt;&lt;br /&gt; &lt;h4 class=&quot;lighter block green&quot;&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 引入 --&gt; &lt;script type=&quot;text/javascript&quot;&gt;window.jQuery || document.write(&quot;&lt;script src=&apos;static/js/jquery-1.9.1.min.js&apos;&gt;\x3C/script&gt;&quot;);&lt;/script&gt; &lt;script src=&quot;static/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/ace-elements.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/ace.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;static/js/chosen.jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 下拉框 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;plugins/webuploader/webuploader.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/js/goods/goods_detail_edit.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //单选框 $(&quot;.chzn-select&quot;).chosen(); $(&quot;.chzn-select-deselect&quot;).chosen(&#123;allow_single_deselect:true&#125;); &#125;); $(top.hangge()); $(document).ready(function()&#123; if($(&quot;#user_id&quot;).val()!=&quot;&quot;)&#123; $(&quot;#loginname&quot;).attr(&quot;readonly&quot;,&quot;readonly&quot;); $(&quot;#loginname&quot;).css(&quot;color&quot;,&quot;gray&quot;); &#125; &#125;); //保存 function save()&#123; //验证商品编码是否为空 if($(&quot;#GOODS_CODE&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_CODE&quot;).tips(&#123; side:3, msg:&apos;请输入商品编码&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_CODE&quot;).focus(); return false; &#125; if($(&quot;#GOODS_NAME&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_NAME&quot;).tips(&#123; side:3, msg:&apos;请输入商品名称&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_NAME&quot;).focus(); return false; &#125; if($(&quot;#GOODS_ABBR_NAME&quot;).val()==&quot;&quot;)&#123; $(&quot;#GOODS_ABBR_NAME&quot;).tips(&#123; side:3, msg:&apos;请输入商品别名&apos;, bg:&apos;#AE81FF&apos;, time:2 &#125;); $(&quot;#GOODS_ABBR_NAME&quot;).focus(); return false; &#125; //保存之前处理图片数据 var lbfiles = uploader[0].getFiles(&quot;complete&quot;);//轮播图 var lbFilesUrl=&quot;&quot;; $(lbfiles).each(function(index,item)&#123; lbFilesUrl = lbFilesUrl+&quot;;&quot;+item.url; &#125;); $(&quot;#FILE_PATH&quot;)[0].value = lbFilesUrl; //保存之前处理图片数据 var detailfiles = uploader[1].getFiles(&quot;complete&quot;);//商品详情图 var detailFilesUrl=&quot;&quot;; $(detailfiles).each(function(index,item)&#123; detailFilesUrl = detailFilesUrl+&quot;;&quot;+item.url; &#125;); $(&quot;#detail_image_url&quot;)[0].value = detailFilesUrl; $(&quot;#goodsForm&quot;).submit(); $(&quot;#zhongxin&quot;).hide(); $(&quot;#zhongxin2&quot;).show(); &#125; //校验编码是否存在 function checkHasCode()&#123; var goodsCode = $(&quot;#GOODS_CODE&quot;)[0].value; var checkGoodsCode = $(&quot;#checkGoodsCode&quot;)[0].value; if(goodsCode == checkGoodsCode)return; $.ajax(&#123; type: &quot;GET&quot;, url: &apos;&lt;%=basePath%&gt;goodsDetail/hasCode.do?tm=&apos;+new Date().getTime() + &apos;&amp;GOODS_CODE=&apos; + goodsCode, data : &apos;&apos;, dataType : &apos;json&apos;, cache : false, success : function(data) &#123; if (data.result == &quot;error&quot;) &#123; alert(&quot;编码重复，请重新输入&quot;); $(&quot;#GOODS_CODE&quot;)[0].value = checkGoodsCode; &#125;; &#125; &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.1 对应上传的js(goods_detail_edit.js)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621(function($)&#123; // 当domReady的时候开始初始化 $(function() &#123; uploader = new Array();//创建 uploader数组 // 判断浏览器是否支持图片的base64 var isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125;; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(); if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;); break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;); break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; $(&apos;.uploadFile&apos;).each(function(index)&#123; var $wrap = $(&apos;#uploader&apos;)[index], // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ).appendTo( $(this).find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $(this).find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $(this).find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $(this).find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;; var locat = (window.location+&apos;&apos;).split(&apos;/&apos;); if(&apos;pictures&apos;== locat[3])&#123;locat = locat[0]+&apos;//&apos;+locat[2];&#125;else&#123;locat = locat[0]+&apos;//&apos;+locat[2]+&apos;/&apos;+locat[3];&#125;; uploader[index] = WebUploader.create(&#123; pick: &#123; id: index==0?&apos;#filePicker&apos;:&apos;#filePickerDetail&apos;, label: &apos;点击选择图片&apos; &#125;, dnd: &apos;#dndArea&apos;, swf: &apos;./Uploader.swf&apos;, chunked: false, chunkSize: 512 * 1024, //server: &apos;http://127.0.0.1:8080/pictures/save.do&apos;, server: &apos;goodsDetail/uploadImg.do?&apos;, //runtimeOrder: &apos;flash&apos;, accept: &#123; title: &apos;Images&apos;, extensions: &apos;gif,jpg,jpeg,bmp,png&apos;, mimeTypes: &apos;image/*&apos; &#125;, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 disableGlobalDnd: true, fileNumLimit: index==0?5:1, fileSizeLimit: 200 * 1024 * 1024, // 200 M fileSingleSizeLimit: 50 * 1024 * 1024 // 50 M &#125;); // 拖拽时不接受 js, txt 文件。 uploader[index].on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); // uploader.on(&apos;filesQueued&apos;, function() &#123; // uploader.sort(function( a, b ) &#123; // if ( a.name &lt; b.name ) // return -1; // if ( a.name &gt; b.name ) // return 1; // return 0; // &#125;); // &#125;); // 添加“添加文件”的按钮， if(index==0)&#123; uploader[index].addButton(&#123; id: &apos;#filePicker2&apos;, label: &apos;继续添加&apos; &#125;); &#125; var getFileBlob = function(url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.addEventListener(&apos;load&apos;, function() &#123; cb(xhr.response); &#125;); xhr.send(); &#125;; var blobToFile = function(blob, name) &#123; blob.lastModifiedDate = new Date(); blob.name = name; return blob; &#125;; var getFileObject = function(filePathOrUrl, cb) &#123; getFileBlob(filePathOrUrl, function(blob) &#123; cb(blobToFile(blob, &apos;test.jpg&apos;)); &#125;); &#125;; //回显图片 uploader[index].on(&apos;ready&apos;, function() &#123; window.uploader = uploader; var filePathArg = index==0?$(&quot;#FILE_PATH&quot;)[0].value.split(&apos;;&apos;):$(&quot;#detail_image_url&quot;)[0].value.split(&apos;;&apos;); var files=new Array(); var i=0; if(filePathArg.length&gt;0)&#123; $.each(filePathArg, function(tempindex,item) &#123; //如果图片是空值，就直接返回 if(item==&apos;&apos;||item==&quot;undefined&quot;||item==undefined)&#123; return true; &#125; getFileObject(item, function(fileObject) &#123; var wuFile = new WebUploader.Lib.File(WebUploader.guid(&apos;rt_&apos;), fileObject); var tempfile = new WebUploader.File(wuFile); tempfile.url=item; tempfile.setStatus(&apos;complete&apos;); uploader[index].addFiles(tempfile); &#125;); &#125;); &#125;; &#125;); uploader[index].on( &apos;uploadSuccess&apos;, function( file,response ) &#123; file.url=response.path; if(index==0)&#123; $(&quot;#FILE_PATH&quot;)[0].value = $(&quot;#FILE_PATH&quot;)[0].value+&quot;;&quot;+response.path; &#125;else&#123; $(&quot;#detail_image_url&quot;)[0].value = $(&quot;#detail_image_url&quot;)[0].value+&quot;;&quot;+response.path; &#125; &#125;); // 当有文件添加进来时执行，负责view的创建 function addFile( file ) &#123; var $li = $( &apos;&lt;li id=&quot;&apos; + file.id + &apos;&quot;&gt;&apos; + &apos;&lt;p class=&quot;title&quot;&gt;&apos; + file.name + &apos;&lt;/p&gt;&apos; + &apos;&lt;p class=&quot;imgWrap&quot;&gt;&lt;/p&gt;&apos;+ &apos;&lt;p class=&quot;progress&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;/li&gt;&apos; ), $btns = $(&apos;&lt;div class=&quot;file-panel&quot;&gt;&apos; + &apos;&lt;span class=&quot;cancel&quot;&gt;删除&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateRight&quot;&gt;向右旋转&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateLeft&quot;&gt;向左旋转&lt;/span&gt;&lt;/div&gt;&apos;).appendTo( $li ), $prgress = $li.find(&apos;p.progress span&apos;), $wrap = $li.find( &apos;p.imgWrap&apos; ), $info = $(&apos;&lt;p class=&quot;error&quot;&gt;&lt;/p&gt;&apos;), showError = function( code ) &#123; switch( code ) &#123; case &apos;exceed_size&apos;: text = &apos;文件大小超出&apos;; break; case &apos;interrupt&apos;: text = &apos;上传暂停&apos;; break; default: text = &apos;上传失败，请重试&apos;; break; &#125; $info.text( text ).appendTo( $li ); &#125;; if ( file.getStatus() === &apos;invalid&apos; ) &#123; showError( file.statusText ); &#125; else &#123; // @todo lazyload $wrap.text( &apos;预览中&apos; ); uploader[index].makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( &apos;不能预览&apos; ); return; &#125; if( isSupportBase64 ) &#123; img = $(&apos;&lt;img src=&quot;&apos;+src+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $.ajax(&apos;../../server/preview.php&apos;, &#123; method: &apos;POST&apos;, data: src, dataType:&apos;json&apos; &#125;).done(function( response ) &#123; if (response.result) &#123; img = $(&apos;&lt;img src=&quot;&apos;+response.result+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $wrap.text(&quot;预览出错&quot;); &#125; &#125;); &#125; &#125;, thumbnailWidth, thumbnailHeight ); percentages[ file.id ] = [ file.size, 0 ]; file.rotation = 0; &#125; file.on(&apos;statuschange&apos;, function( cur, prev ) &#123; if ( prev === &apos;progress&apos; ) &#123; $prgress.hide().width(0); &#125; else if ( prev === &apos;queued&apos; ) &#123; $li.off( &apos;mouseenter mouseleave&apos; ); $btns.remove(); &#125; // 成功 if ( cur === &apos;error&apos; || cur === &apos;invalid&apos; ) &#123; console.log( file.statusText ); showError( file.statusText ); percentages[ file.id ][ 1 ] = 1; &#125; else if ( cur === &apos;interrupt&apos; ) &#123; showError( &apos;interrupt&apos; ); &#125; else if ( cur === &apos;queued&apos; ) &#123; percentages[ file.id ][ 1 ] = 0; &#125; else if ( cur === &apos;progress&apos; ) &#123; $info.remove(); $prgress.css(&apos;display&apos;, &apos;block&apos;); &#125; else if ( cur === &apos;complete&apos; ) &#123; $li.append( &apos;&lt;span class=&quot;success&quot;&gt;&lt;/span&gt;&apos; ); &#125; $li.removeClass( &apos;state-&apos; + prev ).addClass( &apos;state-&apos; + cur ); &#125;); $li.on( &apos;mouseenter&apos;, function() &#123; $btns.stop().animate(&#123;height: 30&#125;); &#125;); $li.on( &apos;mouseleave&apos;, function() &#123; $btns.stop().animate(&#123;height: 0&#125;); &#125;); $btns.on( &apos;click&apos;, &apos;span&apos;, function() &#123; var tempIndex = $(this).index(), deg; switch ( tempIndex ) &#123; case 0: uploader[index].removeFile( file ); return; case 1: file.rotation += 90; break; case 2: file.rotation -= 90; break; &#125; if ( supportTransition ) &#123; deg = &apos;rotate(&apos; + file.rotation + &apos;deg)&apos;; $wrap.css(&#123; &apos;-webkit-transform&apos;: deg, &apos;-mos-transform&apos;: deg, &apos;-o-transform&apos;: deg, &apos;transform&apos;: deg &#125;); &#125; else &#123; $wrap.css( &apos;filter&apos;, &apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=&apos;+ (~~((file.rotation/90)%4 + 4)%4) +&apos;)&apos;); // use jquery animate to rotation // $(&#123; // rotation: rotation // &#125;).animate(&#123; // rotation: file.rotation // &#125;, &#123; // easing: &apos;linear&apos;, // step: function( now ) &#123; // now = now * Math.PI / 180; // var cos = Math.cos( now ), // sin = Math.sin( now ); // $wrap.css( &apos;filter&apos;, &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&quot; + cos + &quot;,M12=&quot; + (-sin) + &quot;,M21=&quot; + sin + &quot;,M22=&quot; + cos + &quot;,SizingMethod=&apos;auto expand&apos;)&quot;); // &#125; // &#125;); &#125; &#125;); $li.appendTo( $queue ); &#125; // 负责view的销毁 function removeFile( file ) &#123; var $li = $(&apos;#&apos;+file.id); delete percentages[ file.id ]; updateTotalProgress(); $li.off().find(&apos;.file-panel&apos;).off().end().remove(); &#125; function updateTotalProgress() &#123; var loaded = 0, total = 0, spans = $progress.children(), percent; $.each( percentages, function( k, v ) &#123; total += v[ 0 ]; loaded += v[ 0 ] * v[ 1 ]; &#125; ); percent = total ? loaded / total : 0; spans.eq( 0 ).text( Math.round( percent * 100 ) + &apos;%&apos; ); spans.eq( 1 ).css( &apos;width&apos;, Math.round( percent * 100 ) + &apos;%&apos; ); updateStatus(); &#125; function updateStatus() &#123; var text = &apos;&apos;, stats; if ( state === &apos;ready&apos; ) &#123; text = &apos;选中&apos; + fileCount + &apos;张图片，共&apos; + WebUploader.formatSize( fileSize ) + &apos;。&apos;; &#125; else if ( state === &apos;confirm&apos; ) &#123; stats = uploader[index].getStats(); if ( stats.uploadFailNum ) &#123; text = &apos;已成功上传&apos; + stats.successNum+ &apos;张照片至XX相册，&apos;+ stats.uploadFailNum + &apos;张照片上传失败，&lt;a class=&quot;retry&quot; href=&quot;#&quot;&gt;重新上传&lt;/a&gt;失败图片或&lt;a class=&quot;ignore&quot; href=&quot;#&quot;&gt;忽略&lt;/a&gt;&apos;; &#125; &#125; else &#123; stats = uploader[index].getStats(); text = &apos;共&apos; + fileCount + &apos;张（&apos; + WebUploader.formatSize( fileSize ) + &apos;），已上传&apos; + stats.successNum + &apos;张&apos;; if ( stats.uploadFailNum ) &#123; text += &apos;，失败&apos; + stats.uploadFailNum + &apos;张&apos;; &#125; &#125; $info.html( text ); &#125; function setState( val ) &#123; var file, stats; if ( val === state ) &#123; return; &#125; $upload.removeClass( &apos;state-&apos; + state ); $upload.addClass( &apos;state-&apos; + val ); state = val; switch ( state ) &#123; case &apos;pedding&apos;: $placeHolder.removeClass( &apos;element-invisible&apos; ); $queue.hide(); $statusBar.addClass( &apos;element-invisible&apos; ); uploader[index].refresh(); break; case &apos;ready&apos;: $placeHolder.addClass( &apos;element-invisible&apos; ); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos;); $queue.show(); $statusBar.removeClass(&apos;element-invisible&apos;); uploader[index].refresh(); break; case &apos;uploading&apos;: $( &apos;#filePicker2&apos; ).addClass( &apos;element-invisible&apos; ); $progress.show(); $upload.text( &apos;暂停上传&apos; ); break; case &apos;paused&apos;: $progress.show(); $upload.text( &apos;继续上传&apos; ); break; case &apos;confirm&apos;: $progress.hide(); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos; ); $upload.text( &apos;开始上传&apos; ); stats = uploader[index].getStats(); if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( &apos;finish&apos; ); return; &#125; break; case &apos;finish&apos;: stats = uploader[index].getStats(); if ( stats.successNum ) &#123; //alert( &apos;上传成功&apos; ); &#125; else &#123; // 没有成功的图片，重设 state = &apos;done&apos;; location.reload(); &#125; break; &#125; updateStatus(); &#125; uploader[index].onUploadProgress = function( file, percentage ) &#123; var $li = $(&apos;#&apos;+file.id), $percent = $li.find(&apos;.progress span&apos;); $percent.css( &apos;width&apos;, percentage * 100 + &apos;%&apos; ); percentages[ file.id ][ 1 ] = percentage; updateTotalProgress(); &#125;; uploader[index].onFileQueued = function( file ) &#123; fileCount++; fileSize += file.size; if ( fileCount === 1 ) &#123; $placeHolder.addClass( &apos;element-invisible&apos; ); $statusBar.show(); &#125; addFile( file ); setState( &apos;ready&apos; ); updateTotalProgress(); &#125;; uploader[index].onFileDequeued = function( file ) &#123; fileCount--; fileSize -= file.size; debugger; if ( !fileCount ) &#123; setState( &apos;pedding&apos; ); &#125; removeFile(file); updateTotalProgress(); &#125;; uploader[index].on( &apos;all&apos;, function( type ) &#123; var stats; switch( type ) &#123; case &apos;uploadFinished&apos;: setState( &apos;confirm&apos; ); break; case &apos;startUpload&apos;: setState( &apos;uploading&apos; ); break; case &apos;stopUpload&apos;: setState( &apos;paused&apos; ); break; &#125; &#125;); uploader[index].onError = function( code ) &#123; if(code == &apos;F_DUPLICATE&apos;)&#123; alert( &apos;图片重复&apos; ); &#125;else&#123; alert( &apos;Eroor: &apos; + code ); &#125; &#125;; $upload.on(&apos;click&apos;, function() &#123; if ( $(this).hasClass( &apos;disabled&apos; ) ) &#123; return false; &#125; if ( state === &apos;ready&apos; ) &#123; uploader[index].upload(); &#125; else if ( state === &apos;paused&apos; ) &#123; uploader[index].upload(); &#125; else if ( state === &apos;uploading&apos; ) &#123; uploader[index].stop(); &#125; &#125;); $info.on( &apos;click&apos;, &apos;.retry&apos;, function() &#123; uploader[index].retry(); &#125; ); $info.on( &apos;click&apos;, &apos;.ignore&apos;, function() &#123; alert( &apos;todo&apos; ); &#125; ); $upload.addClass( &apos;state-&apos; + state ); updateTotalProgress(); &#125;); &#125;);&#125;)( jQuery ); 2.后台代码上传图片12345678910111213141516171819202122232425262728 /** * 上传图片 */ @RequestMapping(value=&quot;/uploadImg&quot;) @ResponseBody public Object save(@RequestParam(required=false) MultipartFile file,String goodsCode) throws Exception&#123; logBefore(logger, &quot;GoodsDetail上传图片&quot;); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();// String ffile = DateUtil.getDays(), fileName = &quot;&quot;; PageData pd = new PageData(); String imageUrls = &quot;&quot;; if(Jurisdiction.buttonJurisdiction(menuUrl, &quot;add&quot;))&#123; if (null != file &amp;&amp; !file.isEmpty()) &#123; //上传图片到FastDFS MultipartFile[] files = new MultipartFile[1]; files[0] = file; imageUrls = fastDFSService.upload(files);// String filePath = PathUtil.getClasspath() + Const.FILEPATHIMG + ffile; //文件上传路径// fileName = FileUpload.fileUp(file, filePath, this.get32UUID()); //执行上传 &#125;else&#123; System.out.println(&quot;上传失败&quot;); &#125; &#125; map.put(&quot;result&quot;, &quot;ok&quot;);// map.put(&quot;path&quot;, ffile + &quot;/&quot; + fileName); map.put(&quot;path&quot;, imageUrls); return AppUtil.returnObject(pd, map); &#125; 保存图片路径1234567891011121314151617181920212223242526272829303132333435363738394041/** * 保存商品基础信息 */ @RequestMapping(value=&quot;/save&quot;) public ModelAndView save() throws Exception&#123; ModelAndView mv = this.getModelAndView(); PageData pd = new PageData(); pd = this.getPageData(); DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //首先判断是否有主键goods_code String goodsCode = pd.getString(&quot;GOODS_CODE&quot;); if(goodsCode!=null &amp;&amp; !&quot;&quot;.equals(goodsCode))&#123;//如果不为空，走update语句 String filePath = pd.getString(&quot;FILE_PATH&quot;)==null?&quot;&quot;:pd.getString(&quot;FILE_PATH&quot;).toString();//图片路径 String[] filePathArg = filePath.split(&quot;;&quot;); String imageUrl1 = filePathArg!=null&amp;&amp;filePathArg.length&gt;1?filePathArg[1]:&quot;&quot;; String imageUrl2 = filePathArg!=null&amp;&amp;filePathArg.length&gt;2?filePathArg[2]:&quot;&quot;; String imageUrl3 = filePathArg!=null&amp;&amp;filePathArg.length&gt;3?filePathArg[3]:&quot;&quot;; String imageUrl4 = filePathArg!=null&amp;&amp;filePathArg.length&gt;4?filePathArg[4]:&quot;&quot;; String imageUrl5 = filePathArg!=null&amp;&amp;filePathArg.length&gt;5?filePathArg[5]:&quot;&quot;; String updatedTime = df.format(new Date()); pd.put(&quot;imageUrl1&quot;, imageUrl1); pd.put(&quot;imageUrl2&quot;, imageUrl2); pd.put(&quot;imageUrl3&quot;, imageUrl3); pd.put(&quot;imageUrl4&quot;, imageUrl4); pd.put(&quot;imageUrl5&quot;, imageUrl5); pd.put(&quot;updatedTime&quot;, updatedTime); String detailImageUrl = pd.getString(&quot;detail_image_url&quot;)==null?&quot;&quot;:pd.getString(&quot;detail_image_url&quot;).toString();//商品详情 String[] detailImageUrlArg = detailImageUrl.split(&quot;;&quot;); String detailImage = detailImageUrlArg!=null&amp;&amp;detailImageUrlArg.length&gt;1?detailImageUrlArg[1]:&quot;&quot;; pd.put(&quot;detail_image_url&quot;, detailImage); &#125;else&#123;//如果为空，那就是新增数据 &#125; if(Jurisdiction.buttonJurisdiction(menuUrl, &quot;edit&quot;))&#123;goodsDetailService.save(pd);&#125; mv.addObject(&quot;msg&quot;,&quot;success&quot;); mv.setViewName(&quot;save_result&quot;); return mv; &#125;]]></content>
      <categories>
        <category>前端插件</category>
        <category>Webuploader</category>
      </categories>
      <tags>
        <tag>Webuploader</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webuploader多图上传及回显]]></title>
    <url>%2F2019%2F01%2F25%2FWebuploader%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[goods_detail_uploader.js 这个是图片上传的js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612(function($)&#123; // 当domReady的时候开始初始化 $(function() &#123; var $wrap = $(&apos;#uploader&apos;), // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ).appendTo( $wrap.find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $wrap.find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $wrap.find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $wrap.find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;, // 判断浏览器是否支持图片的base64 isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125;; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(), // WebUploader实例 uploader; if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;); break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;); break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; var locat = (window.location+&apos;&apos;).split(&apos;/&apos;); if(&apos;pictures&apos;== locat[3])&#123;locat = locat[0]+&apos;//&apos;+locat[2];&#125;else&#123;locat = locat[0]+&apos;//&apos;+locat[2]+&apos;/&apos;+locat[3];&#125;; uploader = WebUploader.create(&#123; pick: &#123; id: &apos;#filePicker&apos;, label: &apos;点击选择图片&apos; &#125;, formData: &#123; uid: 123 &#125;, dnd: &apos;#dndArea&apos;, paste: &apos;#uploader&apos;, swf: &apos;./Uploader.swf&apos;, chunked: false, chunkSize: 512 * 1024, //server: &apos;http://127.0.0.1:8080/pictures/save.do&apos;, server: &apos;goodsDetail/uploadImg.do?&apos;, //runtimeOrder: &apos;flash&apos;, accept: &#123; title: &apos;Images&apos;, extensions: &apos;gif,jpg,jpeg,bmp,png&apos;, mimeTypes: &apos;image/*&apos; &#125;, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 disableGlobalDnd: true, fileNumLimit: 5, fileSizeLimit: 200 * 1024 * 1024, // 200 M fileSingleSizeLimit: 50 * 1024 * 1024 // 50 M &#125;); // 拖拽时不接受 js, txt 文件。 uploader.on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); // uploader.on(&apos;filesQueued&apos;, function() &#123; // uploader.sort(function( a, b ) &#123; // if ( a.name &lt; b.name ) // return -1; // if ( a.name &gt; b.name ) // return 1; // return 0; // &#125;); // &#125;); // 添加“添加文件”的按钮， uploader.addButton(&#123; id: &apos;#filePicker2&apos;, label: &apos;继续添加&apos; &#125;); var getFileBlob = function(url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.addEventListener(&apos;load&apos;, function() &#123; cb(xhr.response); &#125;); xhr.send(); &#125;; var blobToFile = function(blob, name) &#123; blob.lastModifiedDate = new Date(); blob.name = name; return blob; &#125;; var getFileObject = function(filePathOrUrl, cb) &#123; getFileBlob(filePathOrUrl, function(blob) &#123; cb(blobToFile(blob, &apos;test.jpg&apos;)); &#125;); &#125;; //回显图片 uploader.on(&apos;ready&apos;, function() &#123; debugger; window.uploader = uploader; var filePathArg = $(&quot;#FILE_PATH&quot;)[0].value.split(&apos;;&apos;); var files=new Array(); var i=0; if(filePathArg.length&gt;0)&#123; $.each(filePathArg, function(index,item) &#123; //如果图片是空值，就直接返回 if(item==&apos;&apos;||item==&quot;undefined&quot;||item==undefined)&#123; return true; &#125; getFileObject(item, function(fileObject) &#123; var wuFile = new WebUploader.Lib.File(WebUploader.guid(&apos;rt_&apos;), fileObject); var tempfile = new WebUploader.File(wuFile); tempfile.url=item; tempfile.setStatus(&apos;complete&apos;); uploader.addFiles(tempfile); &#125;); &#125;); &#125;; &#125;); uploader.on( &apos;uploadSuccess&apos;, function( file,response ) &#123; file.url=response.path; $(&quot;#FILE_PATH&quot;)[0].value = $(&quot;#FILE_PATH&quot;)[0].value+&quot;;&quot;+response.path; &#125;); // 当有文件添加进来时执行，负责view的创建 function addFile( file ) &#123; var $li = $( &apos;&lt;li id=&quot;&apos; + file.id + &apos;&quot;&gt;&apos; + &apos;&lt;p class=&quot;title&quot;&gt;&apos; + file.name + &apos;&lt;/p&gt;&apos; + &apos;&lt;p class=&quot;imgWrap&quot;&gt;&lt;/p&gt;&apos;+ &apos;&lt;p class=&quot;progress&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;/li&gt;&apos; ), $btns = $(&apos;&lt;div class=&quot;file-panel&quot;&gt;&apos; + &apos;&lt;span class=&quot;cancel&quot;&gt;删除&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateRight&quot;&gt;向右旋转&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;rotateLeft&quot;&gt;向左旋转&lt;/span&gt;&lt;/div&gt;&apos;).appendTo( $li ), $prgress = $li.find(&apos;p.progress span&apos;), $wrap = $li.find( &apos;p.imgWrap&apos; ), $info = $(&apos;&lt;p class=&quot;error&quot;&gt;&lt;/p&gt;&apos;), showError = function( code ) &#123; switch( code ) &#123; case &apos;exceed_size&apos;: text = &apos;文件大小超出&apos;; break; case &apos;interrupt&apos;: text = &apos;上传暂停&apos;; break; default: text = &apos;上传失败，请重试&apos;; break; &#125; $info.text( text ).appendTo( $li ); &#125;; if ( file.getStatus() === &apos;invalid&apos; ) &#123; showError( file.statusText ); &#125; else &#123; // @todo lazyload $wrap.text( &apos;预览中&apos; ); uploader.makeThumb( file, function( error, src ) &#123; var img; if ( error ) &#123; $wrap.text( &apos;不能预览&apos; ); return; &#125; if( isSupportBase64 ) &#123; img = $(&apos;&lt;img src=&quot;&apos;+src+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $.ajax(&apos;../../server/preview.php&apos;, &#123; method: &apos;POST&apos;, data: src, dataType:&apos;json&apos; &#125;).done(function( response ) &#123; if (response.result) &#123; img = $(&apos;&lt;img src=&quot;&apos;+response.result+&apos;&quot;&gt;&apos;); $wrap.empty().append( img ); &#125; else &#123; $wrap.text(&quot;预览出错&quot;); &#125; &#125;); &#125; &#125;, thumbnailWidth, thumbnailHeight ); percentages[ file.id ] = [ file.size, 0 ]; file.rotation = 0; &#125; file.on(&apos;statuschange&apos;, function( cur, prev ) &#123; if ( prev === &apos;progress&apos; ) &#123; $prgress.hide().width(0); &#125; else if ( prev === &apos;queued&apos; ) &#123; $li.off( &apos;mouseenter mouseleave&apos; ); $btns.remove(); &#125; // 成功 if ( cur === &apos;error&apos; || cur === &apos;invalid&apos; ) &#123; console.log( file.statusText ); showError( file.statusText ); percentages[ file.id ][ 1 ] = 1; &#125; else if ( cur === &apos;interrupt&apos; ) &#123; showError( &apos;interrupt&apos; ); &#125; else if ( cur === &apos;queued&apos; ) &#123; percentages[ file.id ][ 1 ] = 0; &#125; else if ( cur === &apos;progress&apos; ) &#123; $info.remove(); $prgress.css(&apos;display&apos;, &apos;block&apos;); &#125; else if ( cur === &apos;complete&apos; ) &#123; $li.append( &apos;&lt;span class=&quot;success&quot;&gt;&lt;/span&gt;&apos; ); &#125; $li.removeClass( &apos;state-&apos; + prev ).addClass( &apos;state-&apos; + cur ); &#125;); $li.on( &apos;mouseenter&apos;, function() &#123; $btns.stop().animate(&#123;height: 30&#125;); &#125;); $li.on( &apos;mouseleave&apos;, function() &#123; $btns.stop().animate(&#123;height: 0&#125;); &#125;); $btns.on( &apos;click&apos;, &apos;span&apos;, function() &#123; var index = $(this).index(), deg; switch ( index ) &#123; case 0: uploader.removeFile( file ); return; case 1: file.rotation += 90; break; case 2: file.rotation -= 90; break; &#125; if ( supportTransition ) &#123; deg = &apos;rotate(&apos; + file.rotation + &apos;deg)&apos;; $wrap.css(&#123; &apos;-webkit-transform&apos;: deg, &apos;-mos-transform&apos;: deg, &apos;-o-transform&apos;: deg, &apos;transform&apos;: deg &#125;); &#125; else &#123; $wrap.css( &apos;filter&apos;, &apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=&apos;+ (~~((file.rotation/90)%4 + 4)%4) +&apos;)&apos;); // use jquery animate to rotation // $(&#123; // rotation: rotation // &#125;).animate(&#123; // rotation: file.rotation // &#125;, &#123; // easing: &apos;linear&apos;, // step: function( now ) &#123; // now = now * Math.PI / 180; // var cos = Math.cos( now ), // sin = Math.sin( now ); // $wrap.css( &apos;filter&apos;, &quot;progid:DXImageTransform.Microsoft.Matrix(M11=&quot; + cos + &quot;,M12=&quot; + (-sin) + &quot;,M21=&quot; + sin + &quot;,M22=&quot; + cos + &quot;,SizingMethod=&apos;auto expand&apos;)&quot;); // &#125; // &#125;); &#125; &#125;); $li.appendTo( $queue ); &#125; // 负责view的销毁 function removeFile( file ) &#123; var $li = $(&apos;#&apos;+file.id); delete percentages[ file.id ]; updateTotalProgress(); $li.off().find(&apos;.file-panel&apos;).off().end().remove(); &#125; function updateTotalProgress() &#123; var loaded = 0, total = 0, spans = $progress.children(), percent; $.each( percentages, function( k, v ) &#123; total += v[ 0 ]; loaded += v[ 0 ] * v[ 1 ]; &#125; ); percent = total ? loaded / total : 0; spans.eq( 0 ).text( Math.round( percent * 100 ) + &apos;%&apos; ); spans.eq( 1 ).css( &apos;width&apos;, Math.round( percent * 100 ) + &apos;%&apos; ); updateStatus(); &#125; function updateStatus() &#123; var text = &apos;&apos;, stats; if ( state === &apos;ready&apos; ) &#123; text = &apos;选中&apos; + fileCount + &apos;张图片，共&apos; + WebUploader.formatSize( fileSize ) + &apos;。&apos;; &#125; else if ( state === &apos;confirm&apos; ) &#123; stats = uploader.getStats(); if ( stats.uploadFailNum ) &#123; text = &apos;已成功上传&apos; + stats.successNum+ &apos;张照片至XX相册，&apos;+ stats.uploadFailNum + &apos;张照片上传失败，&lt;a class=&quot;retry&quot; href=&quot;#&quot;&gt;重新上传&lt;/a&gt;失败图片或&lt;a class=&quot;ignore&quot; href=&quot;#&quot;&gt;忽略&lt;/a&gt;&apos;; &#125; &#125; else &#123; stats = uploader.getStats(); text = &apos;共&apos; + fileCount + &apos;张（&apos; + WebUploader.formatSize( fileSize ) + &apos;），已上传&apos; + stats.successNum + &apos;张&apos;; if ( stats.uploadFailNum ) &#123; text += &apos;，失败&apos; + stats.uploadFailNum + &apos;张&apos;; &#125; &#125; $info.html( text ); &#125; function setState( val ) &#123; var file, stats; if ( val === state ) &#123; return; &#125; $upload.removeClass( &apos;state-&apos; + state ); $upload.addClass( &apos;state-&apos; + val ); state = val; switch ( state ) &#123; case &apos;pedding&apos;: $placeHolder.removeClass( &apos;element-invisible&apos; ); $queue.hide(); $statusBar.addClass( &apos;element-invisible&apos; ); uploader.refresh(); break; case &apos;ready&apos;: $placeHolder.addClass( &apos;element-invisible&apos; ); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos;); $queue.show(); $statusBar.removeClass(&apos;element-invisible&apos;); uploader.refresh(); break; case &apos;uploading&apos;: $( &apos;#filePicker2&apos; ).addClass( &apos;element-invisible&apos; ); $progress.show(); $upload.text( &apos;暂停上传&apos; ); break; case &apos;paused&apos;: $progress.show(); $upload.text( &apos;继续上传&apos; ); break; case &apos;confirm&apos;: $progress.hide(); $( &apos;#filePicker2&apos; ).removeClass( &apos;element-invisible&apos; ); $upload.text( &apos;开始上传&apos; ); stats = uploader.getStats(); if ( stats.successNum &amp;&amp; !stats.uploadFailNum ) &#123; setState( &apos;finish&apos; ); return; &#125; break; case &apos;finish&apos;: stats = uploader.getStats(); if ( stats.successNum ) &#123; //alert( &apos;上传成功&apos; ); &#125; else &#123; // 没有成功的图片，重设 state = &apos;done&apos;; location.reload(); &#125; break; &#125; updateStatus(); &#125; uploader.onUploadProgress = function( file, percentage ) &#123; var $li = $(&apos;#&apos;+file.id), $percent = $li.find(&apos;.progress span&apos;); $percent.css( &apos;width&apos;, percentage * 100 + &apos;%&apos; ); percentages[ file.id ][ 1 ] = percentage; updateTotalProgress(); &#125;; uploader.onFileQueued = function( file ) &#123; fileCount++; fileSize += file.size; if ( fileCount === 1 ) &#123; $placeHolder.addClass( &apos;element-invisible&apos; ); $statusBar.show(); &#125; addFile( file ); setState( &apos;ready&apos; ); updateTotalProgress(); &#125;; uploader.onFileDequeued = function( file ) &#123; fileCount--; fileSize -= file.size; if ( !fileCount ) &#123; setState( &apos;pedding&apos; ); &#125; removeFile(file); updateTotalProgress(); &#125;; uploader.on( &apos;all&apos;, function( type ) &#123; var stats; switch( type ) &#123; case &apos;uploadFinished&apos;: setState( &apos;confirm&apos; ); break; case &apos;startUpload&apos;: setState( &apos;uploading&apos; ); break; case &apos;stopUpload&apos;: setState( &apos;paused&apos; ); break; &#125; &#125;); uploader.onError = function( code ) &#123; if(code == &apos;F_DUPLICATE&apos;)&#123; alert( &apos;图片重复&apos; ); &#125;else&#123; alert( &apos;Eroor: &apos; + code ); &#125; &#125;; $upload.on(&apos;click&apos;, function() &#123; if ( $(this).hasClass( &apos;disabled&apos; ) ) &#123; return false; &#125; if ( state === &apos;ready&apos; ) &#123; uploader.upload(); &#125; else if ( state === &apos;paused&apos; ) &#123; uploader.upload(); &#125; else if ( state === &apos;uploading&apos; ) &#123; uploader.stop(); &#125; &#125;); $info.on( &apos;click&apos;, &apos;.retry&apos;, function() &#123; uploader.retry(); &#125; ); $info.on( &apos;click&apos;, &apos;.ignore&apos;, function() &#123; alert( &apos;todo&apos; ); &#125; ); $upload.addClass( &apos;state-&apos; + state ); updateTotalProgress(); &#125;);&#125;)( jQuery ); 图片上传页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name="description" content="overview &amp; stats" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;&lt;link href="static/css/bootstrap.min.css" rel="stylesheet" /&gt;&lt;link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" /&gt;&lt;link rel="stylesheet" href="static/css/font-awesome.min.css" /&gt;&lt;!-- 下拉框 --&gt;&lt;link rel="stylesheet" href="static/css/chosen.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace.min.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace-responsive.min.css" /&gt;&lt;link rel="stylesheet" href="static/css/ace-skins.min.css" /&gt;&lt;script type="text/javascript" src="static/js/jquery-1.7.2.js"&gt;&lt;/script&gt;&lt;!-- 上传图片 --&gt;&lt;link rel="stylesheet" type="text/css" href="plugins/webuploader/webuploader.css" /&gt;&lt;link rel="stylesheet" type="text/css" href="plugins/webuploader/style.css" /&gt;&lt;style type="text/css"&gt;#wrapper &#123; margin: 0;&#125;#uploader .placeholder &#123; background: url(plugins/webuploader/image.png) center 23px no-repeat; padding-top: 88px; min-height: 110px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="goodsDetail/$&#123;msg &#125;.do" name="goodsForm" id="goodsForm" method="post"&gt; &lt;div id="zhongxin"&gt; &lt;table id="table_report" class="table table-striped table-bordered table-hover"&gt; &lt;tr&gt; &lt;th style="vertical-align: middle"&gt;轮播图:&lt;/th&gt; &lt;td colspan="3"&gt;&lt;input type="hidden" name="FILE_PATH" id="FILE_PATH" value="$&#123;pd.FILE_PATH&#125;" /&gt; &lt;div id="wrapper"&gt; &lt;div id="container"&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id="uploader"&gt; &lt;div class="queueList"&gt; &lt;div id="dndArea" class="placeholder"&gt; &lt;div id="filePicker"&gt;&lt;/div&gt; &lt;p&gt;或将照片拖到这里，单次最多可选1张&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="statusBar" style="display:none;"&gt; &lt;div class="progress"&gt; &lt;span class="text"&gt;0%&lt;/span&gt; &lt;span class="percentage"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="info"&gt;&lt;/div&gt; &lt;div class="btns"&gt; &lt;div id="filePicker2"&gt;&lt;/div&gt; &lt;div class="uploadBtn"&gt;开始上传&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="text-align: center;" colspan="4"&gt; &lt;a class="btn btn-mini btn-primary" onclick="save();"&gt;保存&lt;/a&gt; &lt;a class="btn btn-mini btn-danger" onclick="top.Dialog.close();"&gt;取消&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id="zhongxin2" class="center" style="display:none"&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;img src="static/images/jiazai.gif" /&gt;&lt;br /&gt; &lt;h4 class="lighter block green"&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 引入 --&gt; &lt;script type="text/javascript"&gt;window.jQuery || document.write("&lt;script src='static/js/jquery-1.9.1.min.js'&gt;\x3C/script&gt;");&lt;/script&gt; &lt;script src="static/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script src="static/js/ace-elements.min.js"&gt;&lt;/script&gt; &lt;script src="static/js/ace.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="static/js/chosen.jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 下拉框 --&gt; &lt;script type="text/javascript" src="plugins/webuploader/webuploader.js"&gt;&lt;/script&gt; &lt;script src="static/js/goods/goods_detail_edit.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var tempqueue; $(function() &#123; //单选框 $(".chzn-select").chosen(); $(".chzn-select-deselect").chosen(&#123;allow_single_deselect:true&#125;); &#125;); //保存 function save()&#123; //获取所有在图片列表中的URL传给后台 var files = uploader.getFiles(); var filePath = ""; files.forEach(function(e)&#123; if(e.getStatus()=="complete")&#123; filePath = filePath+";"+e.url; &#125; &#125;); $("#FILE_PATH")[0].value = filePath; $("#goodsForm").submit(); $("#zhongxin").hide(); $("#zhongxin2").show(); &#125; //校验编码是否存在 function checkHasCode()&#123; var goodsCode = $("#GOODS_CODE")[0].value; var checkGoodsCode = $("#checkGoodsCode")[0].value; if(goodsCode == checkGoodsCode)return; $.ajax(&#123; type: "GET", url: '&lt;%=basePath%&gt;goodsDetail/hasCode.do?tm='+new Date().getTime() + '&amp;GOODS_CODE=' + goodsCode, data : '', dataType : 'json', cache : false, success : function(data) &#123; if (data.result == "error") &#123; alert("编码重复，请重新输入"); $("#GOODS_CODE")[0].value = checkGoodsCode; &#125;; &#125; &#125;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; java后台上传图片代码12345678910111213141516171819202122232425262728 /** * 上传图片 */ @RequestMapping(value="/uploadImg") @ResponseBody public Object save(@RequestParam(required=false) MultipartFile file,String goodsCode) throws Exception&#123; logBefore(logger, "GoodsDetail上传图片"); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();// String ffile = DateUtil.getDays(), fileName = ""; PageData pd = new PageData(); String imageUrls = ""; if(Jurisdiction.buttonJurisdiction(menuUrl, "add"))&#123; if (null != file &amp;&amp; !file.isEmpty()) &#123; //上传图片到FastDFS MultipartFile[] files = new MultipartFile[1]; files[0] = file; imageUrls = fastDFSService.upload(files);// String filePath = PathUtil.getClasspath() + Const.FILEPATHIMG + ffile; //文件上传路径// fileName = FileUpload.fileUp(file, filePath, this.get32UUID()); //执行上传 &#125;else&#123; System.out.println("上传失败"); &#125; &#125; map.put("result", "ok");// map.put("path", ffile + "/" + fileName); map.put("path", imageUrls); return AppUtil.returnObject(pd, map); &#125;]]></content>
      <categories>
        <category>前端插件</category>
        <category>Webuploader</category>
      </categories>
      <tags>
        <tag>Webuploader</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中显示MarkDown，并且进行代码高亮]]></title>
    <url>%2F2019%2F01%2F25%2FHTML%E4%B8%AD%E6%98%BE%E7%A4%BAMarkDown%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[简述 临时个人兴趣，做一个类似API的东西，要显示具体对应的代码，因此用到了页面中显示代码插件（showdown）和高亮代码插件（highligt），两个插件的官网分别是：showdown、highlight 使用方法showdown 首先在官网下载showdown 下载完成后，引入项目，解压找到showdown.min.js文件 js代码1234567891011$('li a').click(function()&#123; $.get(this.href,function(data)&#123; var converter = new showdown.Converter();//1.首先定义converter data = "``` \n"+data+" \n ```";//转换成markdown格式的代码 var html = converter.makeHtml(data);//2. 使用convert转换成html代码 document.getElementById("code").innerHTML = html;//3. 将转换好的markdown放入对应的div $('pre code').each(function(i, block) &#123; hljs.highlightBlock(block); &#125;); &#125;)&#125;) highlight 首先官网下载highlight 下载完成后，引入项目 需要注意点： highlight提供好几种样式，可以在style文件夹下面自行查找 js代码123456789101112//展示和高亮代码 $(&apos;li a&apos;).click(function()&#123; $.get(this.href,function(data)&#123; var converter = new showdown.Converter(); data = &quot;``` \n&quot;+data+&quot; \n ```&quot;; var html = converter.makeHtml(data); document.getElementById(&quot;code&quot;).innerHTML = html; $(&apos;pre code&apos;).each(function(i, block) &#123;//这一行一定要有，否则高亮代码不生效 hljs.highlightBlock(block);//使代码高亮 &#125;); &#125;) &#125;) 这个页面有一个很巧妙的地方，是通过get请求获取到未经js和css渲染的纯html页面代码，方法的代码如下：123$.get(url,function(data)&#123; console.log(data);//这里面的data就是未经渲染的html代码内容&#125;)]]></content>
      <categories>
        <category>前端插件</category>
        <category>showdown&amp;highlight</category>
      </categories>
      <tags>
        <tag>前端插件</tag>
        <tag>showdown</tag>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageView图片预览的使用方法及代码]]></title>
    <url>%2F2019%2F01%2F25%2FImageView%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在做一个项目上图片预览的功能，常规情况下都是简单的一个类型下的图片，但目前的需求是左侧展示一个用户下的图片类型，右边显示这个用户下这个类型的图片的列表，点击列表上的图片还能看大图进行预览操作 下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;预览影像资料&lt;/title&gt; &lt;link rel="stylesheet" href="../../../main/scripts/bootstrap-3.3.7/css/bootstrap.css"/&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/main.css"&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/mine.css"&gt; &lt;link rel="stylesheet" href="../../../main/scripts/imagesview/css/viewer.css"&gt; &lt;!-- Scripts --&gt; &lt;script src="../../../main/scripts/imagesview/js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script src="../../../main/scripts/imagesview/js/viewer.js"&gt;&lt;/script&gt; &lt;style&gt; .menu &#123; position: absolute; left: 0; top: 0; bottom: 0; width: 200px; padding-top: 100px; font-family: Consolas, arial, "宋体"; background-color: #ccc; &#125; .menu a &#123; display: block; height: 40px; margin: 0 0 1px 2px; padding-left: 10px; line-height: 40px; font-size: 14px; color: #333; text-decoration: none; &#125; .menu a.cur &#123; background-color: #eee; &#125; .menu a:hover &#123; background-color: #eee; &#125; /* .menu .cur &#123; color: #000; background-color: #fff !important;&#125; */ #jq22 &#123; width: 700px; margin: 0 auto; font-size: 0; &#125; #jq22 li &#123; display: inline-block; width: 32%; height: 150px; margin-left: 1%; padding-top: 1%; &#125; #jq22 li img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="wrap"&gt; &lt;!-- 左边内容 --&gt; &lt;div class="menu"&gt; &lt;a id="all-items" class="cur menu-item" href="javascript:;" onclick="initImages('')"&gt;&amp;nbsp&amp;nbsp全部影像&lt;/a&gt; &lt;a class="menu-item" href="#"&gt;&lt;/a&gt; &lt;/div&gt; &lt;!-- 右边内容 --&gt; &lt;div class="right" id="right"&gt; &lt;!--&lt;h1 style="text-align: center"&gt; &lt;p id="hname"&gt;全部影像&lt;/p&gt; &lt;/h1&gt;--&gt; &lt;ul class="docs-pictures clearfix" id="jq22"&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var viewer; var applyId = mini.getParams().applyId;//申请ID $(function () &#123; //初始化左侧的资料类型 initImageType(); initImages('');//初始化的时候加载所有的图片 //初始化viewer viewer = new Viewer(document.getElementById('jq22'), &#123; show: function () &#123; viewer.update(); &#125; &#125;); &#125;) //加载左侧的资料类型 function initImageType()&#123; $.ajax(&#123; url:eg.getRequestUrl()+'/imgManage/getImageType', type:'GET', data:&#123;applyId:applyId&#125;, async:true, dataType:'json', success:function(data)&#123; if(data.code == 0)&#123;//如果查询成功，加载遍历左侧的数据 for(var dataIndex=0;dataIndex &lt; data.datalist.length;dataIndex++)&#123; (function(dataIndex)&#123; var a=document.createElement('a'); var innerText = data.datalist[dataIndex].DOC_NAME a.innerHTML=innerText; a.addEventListener('click',function(e)&#123; e.preventDefault(); //取消默认事件，指a标签 initImages(data.datalist[dataIndex].DOC_CODE); &#125;); $("#all-items").append(a); &#125;)(dataIndex); &#125; &#125;else&#123; mini.alert(data.msg); &#125; &#125; &#125;) &#125; //加载右侧的图片信息 function initImages(docCode)&#123; $.ajax(&#123; url:eg.getRequestUrl()+'/imgManage/getImagesByApplyIdAndDocCode', type:'GET', data:&#123;applyId:applyId,docCode:docCode&#125;, dataType:'json', success:function(data)&#123; if(data.code == 0)&#123;//遍历显示图片 var imageList = data.datalist; $(this).addClass('cur').siblings('a').removeClass('cur'); //$.trim($("#hname").text($(this).text())); var li = ''; for (var i = 0, l = imageList.length; i &lt; l; i++)&#123; li += "&lt;li class='catImg'&gt;&lt;img data-original='"+eg.getRequestUrl()+imageList[i].FILE_PATH+imageList[i].FILE_ID+imageList[i].FILE_TYPE+"' src='"+eg.getRequestUrl()+imageList[i].FILE_PATH+imageList[i].FILE_ID+imageList[i].FILE_TYPE+"'&gt;&lt;/li&gt;"; &#125; $("#jq22").html(li); viewer.update(); &#125;else&#123; mini.alert(data.msg,"温馨提示"); &#125; &#125; &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端插件</category>
        <category>imageview</category>
      </categories>
      <tags>
        <tag>imageview</tag>
        <tag>图片预览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不重复随机数的产生]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BA%A7%E7%94%9F%2F</url>
    <content type="text"><![CDATA[123456int a[100]=0;for(i=0;i=99;i++)&#123;while(a[m=rand()0])a[m]=i;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP GET POST请求]]></title>
    <url>%2F2019%2F01%2F25%2FHTTP-GET-POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.oemp.common; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; /** * @author Post Method */ public class HttpPostUrl &#123; /** * 向指定URL发送POST请求 * @param url * @param paramMap * @return 响应结果 */ public static String sendPost(String url, Map&lt;String, String&gt; paramMap) &#123; PrintWriter out = null; BufferedReader in = null; String result = ""; try &#123; URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty("accept", "*/*"); conn.setRequestProperty("connection", "Keep-Alive"); conn.setRequestProperty("user-agent","Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)"); // conn.setRequestProperty("Charset", "UTF-8"); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 设置请求属性 String param = ""; if (paramMap != null &amp;&amp; paramMap.size() &gt; 0) &#123; Iterator&lt;String&gt; ite = paramMap.keySet().iterator(); while (ite.hasNext()) &#123; String key = ite.next();// key String value = paramMap.get(key); param += key + "=" + value + "&amp;"; &#125; param = param.substring(0, param.length() - 1); &#125; // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123; System.err.println("发送 POST 请求出现异常！" + e); e.printStackTrace(); &#125; // 使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125; /** * 数据流post请求 * @param urlStr * @param xmlInfo */ public static String doPost(String urlStr, String strInfo) &#123; String reStr=""; try &#123; URL url = new URL(urlStr); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setRequestProperty("Pragma:", "no-cache"); con.setRequestProperty("Cache-Control", "no-cache"); con.setRequestProperty("Content-Type", "text/xml"); OutputStreamWriter out = new OutputStreamWriter(con.getOutputStream()); out.write(new String(strInfo.getBytes("utf-8"))); out.flush(); out.close(); BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), "utf-8")); String line = ""; for (line = br.readLine(); line != null; line = br.readLine()) &#123; reStr += line; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return reStr; &#125; /** * 测试主方法 * @param args */ public static void main(String[] args) &#123; Map&lt;String, String&gt; mapParam = new HashMap&lt;String, String&gt;(); mapParam.put("name", "张三"); mapParam.put("validation","test"); String pathUrl = "http://localhost/testPost.action"; String result = sendPost(pathUrl, mapParam); System.out.println(result); &#125; &#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>公共类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP请求</tag>
        <tag>GET</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json树组装TreeBuilder(适用在bootstrap_treeview)]]></title>
    <url>%2F2019%2F01%2F25%2FJson%E6%A0%91%E7%BB%84%E8%A3%85TreeBuilder-%E8%AF%95%E7%94%A8%E5%9C%A8bootstrap-treeview%2F</url>
    <content type="text"><![CDATA[数据的结构如下： 节点ID 父节点ID 显示的内容 其他内容 01 “” 01 “” 02 “” 02 “” 0101 01 0101 “” 0102 01 0102 “” 010101 0101 010101 “” 12345SELECT ID, ORG_NO, ORG_NAME, P_LEVEL, PARENT_ID FROM SYS_ORG START WITH PARENT_ID = '0'CONNECT BY PRIOR ID = PARENT_IDORDER SIBLINGS BY LEVEL_SORT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package com.ms.module.fw.biki;import java.util.*;import net.sf.json.JSONArray;public class TreeBuilder &#123; List&lt;TreeBuilder.Node&gt; nodes = new ArrayList&lt;TreeBuilder.Node&gt;(); public TreeBuilder(List&lt;Node&gt; nodes) &#123; super(); this.nodes = nodes; &#125; /** * 构建JSON树形结构 * @return */ public String buildJSONTree() &#123; List&lt;Node&gt; nodeTree = buildTree(); JSONArray jsonArray = JSONArray.fromObject(nodeTree); return jsonArray.toString(); &#125; /** * 构建树形结构 * @return */ public List&lt;Node&gt; buildTree() &#123; List&lt;Node&gt; treeNodes = new ArrayList&lt;Node&gt;(); List&lt;Node&gt; rootNodes = getRootNodes(); for (Node rootNode : rootNodes) &#123; buildChildNodes(rootNode); treeNodes.add(rootNode); &#125; return treeNodes; &#125; /** * 递归子节点 * @param node */ public void buildChildNodes(Node node) &#123; List&lt;Node&gt; children = getChildNodes(node); if (!children.isEmpty()) &#123; for (Node child : children) &#123; buildChildNodes(child); &#125; node.setMenus(children); &#125; &#125; /** * 获取父节点下所有的子节点 * @param nodes * @param pnode * @return */ public List&lt;Node&gt; getChildNodes(Node pnode) &#123; List&lt;Node&gt; childNodes = new ArrayList&lt;Node&gt;(); for (Node n : nodes) &#123; if (pnode.getId().equals(n.getPid())) &#123; childNodes.add(n); &#125; &#125; return childNodes; &#125; /** * 判断是否为根节点 * 遍历所有节点，如果能找到他们的节点ID = 当前节点的父节点ID，说明不是root节点 * @param nodes * @param inNode * @return */ public boolean rootNode(Node node) &#123; boolean isRootNode = true; for (Node n : nodes) &#123; if (node.getPid().equals(n.getId())) &#123; isRootNode = false; break; &#125; &#125; return isRootNode; &#125; /** * 获取集合中所有的根节点 * @param nodes * @return */ public List&lt;Node&gt; getRootNodes() &#123; List&lt;Node&gt; rootNodes = new ArrayList&lt;Node&gt;(); for (Node n : nodes) &#123; if (rootNode(n)) &#123; rootNodes.add(n); &#125; &#125; return rootNodes; &#125; public static class Node &#123; private String id; private String pid; private String text; private String url; private List&lt;Node&gt; menus; public Node() &#123; &#125; public Node(String id, String pid, String text, String url) &#123; super(); this.id = id; this.pid = pid; this.text = text; this.url = url; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getPid() &#123; return pid; &#125; public void setPid(String pid) &#123; this.pid = pid; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public List&lt;Node&gt; getMenus() &#123; return menus; &#125; public void setMenus(List&lt;Node&gt; menus) &#123; this.menus = menus; &#125; &#125; public static void main(String[] args) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); Node p1 = new Node("01", "", "01", ""); Node p6 = new Node("02", "", "02", ""); Node p7 = new Node("0201", "02", "0201", ""); Node p2 = new Node("0101", "01", "0101", ""); Node p3 = new Node("0102", "01", "0102", ""); Node p4 = new Node("010101", "0101", "010101", ""); Node p5 = new Node("010102", "0101", "010102", ""); nodes.add(p1); nodes.add(p2); nodes.add(p3); nodes.add(p4); nodes.add(p5); nodes.add(p6); nodes.add(p7); TreeBuilder treeBuilder = new TreeBuilder(nodes); System.out.println(treeBuilder.buildJSONTree()); &#125;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>公共类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TreeBuilder</tag>
        <tag>bootstrap_treeview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据request获取用户IP地址公共方法]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%A0%B9%E6%8D%AErequest%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7IP%E5%9C%B0%E5%9D%80%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获取用户真实IP地址，不使用request.getRemoteAddr();的原因是有可能用户使用了代理软件方式避免真实IP地址,可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值，究竟哪个才是真正的用户端的真实IP呢？答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。如：X-Forwarded-For：192.168.1.110, 192.168.1.120, 192.168.1.130,192.168.1.100用户真实IP为： 192.168.1.110 具体的代码如下：12345678910111213141516171819public static String getIpAddress(HttpServletRequest request) &#123; String ip = request.getHeader("x-forwarded-for"); if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("Proxy-Client-IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("WL-Proxy-Client-IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("HTTP_CLIENT_IP"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getHeader("HTTP_X_FORWARDED_FOR"); &#125; if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return ip;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>用户IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA小知识点]]></title>
    <url>%2F2019%2F01%2F24%2FJAVA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[创建List的技巧方法,简单高效、暴力1List&lt;String&gt; list = Arrays.asList("role1","role2","role3"); 数据类型…的使用（不确定参数数量的方法使用）当出现方法的参数不确定个数的时候（参数的类型一样）可以使用数据类型...目前测试了String、int是可以使用的12345678910@Testpublic void testString()&#123; testStrings(&quot;123123&quot;,&quot;123234234&quot;,&quot;asdasd&quot;);&#125;protected void testStrings(String... strargs)&#123; for(String tempStr:strargs)&#123; System.out.println(tempStr); &#125;&#125; 数字数据格式化有些需要格式化为001、002的需求1new DecimalFormat("000").format(123) Java后台获取项目路径(classpath和resourcepath)123456789101112131415public static String getClasspath()&#123; String path = (String.valueOf(Thread.currentThread().getContextClassLoader().getResource(""))+"../../").replaceAll("file:/", "").replaceAll("%20", " ").trim(); if(path.indexOf(":") != 1)&#123; path = File.separator + path; &#125; return path;&#125;public static String getClassResources()&#123; String path = (String.valueOf(Thread.currentThread().getContextClassLoader().getResource(""))).replaceAll("file:/", "").replaceAll("%20", " ").trim(); if(path.indexOf(":") != 1)&#123; path = File.separator + path; &#125; return path;&#125;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片验证码，解决了Session不同步的问题]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86Session%E4%B8%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package cn.gov.csrc.servlet; import java.awt.Color; import java.awt.Font; import java.awt.Graphics; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGImageEncoder; public class CodeServlet extends HttpServlet &#123; /** * 产生验证码图片 */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("image/jpeg"); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "No-cache"); response.setDateHeader("Expires", 0L); int width = 80; int height = 30; BufferedImage image = new BufferedImage(width, height, 1); Graphics g = image.getGraphics(); Random random = new Random(); g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font("Arial", 0, 25)); g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width + 100); int y = random.nextInt(height + 100); int xl = random.nextInt(10); int yl = random.nextInt(12); g.drawOval(x, y, x + xl, y + yl); &#125; String code = request.getParameter("code"); String sRand = code; for (int i = 0; i &lt; sRand.length(); i++) &#123; String rand = sRand.substring(i, i + 1); g.setColor(new Color(20 + random.nextInt(110), 20 + random .nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 14 * i + 5, 25); &#125; g.dispose(); javax.servlet.ServletOutputStream imageOut = response.getOutputStream(); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(imageOut); encoder.encode(image); &#125; private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125; &#125; Web.xml文件： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.gov.csrc.servlet.CodeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/CodeServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; index.jsp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/"; %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;验证码测试&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;script language="javascript" type="text/javascript"&gt; var code ; //在全局 定义验证码 function createCode()&#123; code = ""; var codeLength = 5;//验证码的长度 //所有候选组成验证码的字符，可以用中文 var selectChar = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C', 'D','E','F','G','H','I','J','K','L','M','N','O','P', 'Q','R','S','T','U','V','W','X','Y','Z','a','b','c', 'd','e','f','g','h','i','j','k','l','m','n','o','p', 'q','r','s','t','u','v','w','x','y','z'); for(var i=0;i&lt;codeLength;i++)&#123; var charIndex = Math.floor(Math.random()*60); code +=selectChar[charIndex]; &#125; return code; &#125; function validate ()&#123; var inputCode = document.getElementById("vcode").value.toLowerCase(); if(inputCode.length &lt;=0)&#123; alert("请输入验证码！"); return false; &#125; else if(inputCode != code.toLowerCase())&#123; alert("验证码输入错误！"); show();//刷新验证码 return false; &#125;else&#123; alert("^-^ OK"); return true; &#125; &#125; function show()&#123; //显示验证码 document.getElementById("code").src="CodeServlet?code="+createCode(); &#125; window.onload = function() &#123; //document.onload=show(); show();//页面加载时加载验证码 //这时无论在ie还是在firefox中，js没有加载完，页面的东西是不会被执行的； &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form onsubmit="return validate();" action="" method="post"&gt; &lt;h3&gt;jsp+js+servlet实现验证码&lt;/h3&gt; &lt;br /&gt; 用户名：&lt;input type="text" name="" /&gt;&lt;br /&gt; 请输入验证码： &lt;input type="text" id="vcode" style="width: 60;" maxLength="5" /&gt; &lt;img src="" id="code" /&gt; &lt;a href="#" mce_href="#" onclick="javascript:show();return false;"&gt;看不清,换一张!&lt;/a&gt;&lt;br /&gt; &lt;input type="submit" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>功能相关</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat错误信息界面版本信息泄露]]></title>
    <url>%2F2019%2F01%2F24%2FTomcat%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%95%8C%E9%9D%A2%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[问题描述Tomcat报错页面出现Tomcat版本信息的泄露，具体的效果图见下图 解决方案 进入tomcat/lib下，使用电脑自带的软件解压开文件夹下面的catalina.jar文件，然后找到路径\org\apache\catalina\util路径下的ServerInfo.properties 编辑ServerInfo.properties文件，修改最后三行代码，去掉对应的版本信息，修改后的效果如下图所示 改完后保存，替换到lib包下面的jar包，重启Tomcat，查看报错页面显示的错误信息]]></content>
      <categories>
        <category>安全测评</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx版本信息泄露漏洞解决]]></title>
    <url>%2F2019%2F01%2F24%2Fnginx%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题描述 nginx版本信息的泄露有可能会造成攻击者获取更多的信息 nginx在curl的时候是能看到nginx版本信息的，具体的界面显示如下图所示,可以看到其中有个Server:nginx/1.15.8： 解决方案 修改nginx主配置文件：nginx.conf,取消注释或添加配置语句 12345http &#123; # ...省略一些配置 server_tokens off; #默认是注释掉的 # ...省略一些配置&#125; 编辑php-fpm配置文件，如fastcgi.conf或fcgi.conf（这个配置文件名也可以自定义的，根据具体文件名修改） 12345# 找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;# 修改为fastcgi_param SERVER_SOFTWARE nginx; 重新加载nginx配置文件 12# /etc/init.d/nginx reload 或# service nginx reload 验证是否生效1234567# curl -v -X 192.168.31.7HTTP/1.1 200 OKServer: nginxDate: Tue, 13 Jul 2010 14:26:56 GMTContent-Type: text/html; charset=UTF-8Connection: keep-aliveVary: Accept-Encoding]]></content>
      <categories>
        <category>安全测评</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>安全测评</tag>
        <tag>修复方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Thread 基础使用方法]]></title>
    <url>%2F2019%2F01%2F24%2FJava-Thread-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[线程运行状态的几个方法 start方法 用来启动一个线程，当调用start方法的时候，系统才会开启一个新的线程来执行用户定义的子任务，并为线程分配需要的资源 run方法 run()方法不需要用户调用，当通过start启动一个线程的时候，当线程或得了CPU执行时间，便会自动进入到run方法去执行具体的任务。*继承Thread类必须要重写run方法，在run中定义具体要执行的任务。 sleep方法 12sleep(long millis) //参数为毫秒sleep(long millis,int nanoseconds) // 第一个参数为毫秒，第二个参数为纳秒 sleep相当于让线程睡眠，交出CPU，去执行其他任务。 但是sleep方法不会释放锁，某个对象加锁，则即使调用sleep方法，其他线程也无法访问这个对象： 123456789101112131415161718192021222324252627282930313233public class Test &#123; private int i = 10; private Object object = new Object(); public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; synchronized (object) &#123; i++; System.out.println("i:"+i); try &#123; System.out.println("线程"+Thread.currentThread().getName()+"进入睡眠状态"); Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println("线程"+Thread.currentThread().getName()+"睡眠结束"); i++; System.out.println("i:"+i); &#125; &#125; &#125;&#125; 输出结果如下： 123456789i:11线程Thread-0进入睡眠状态线程Thread-0睡眠结束i:12i:13线程Thread-1进入睡眠状态Disconnected from the target VM, address: '127.0.0.1:13332', transport: 'socket'线程Thread-1睡眠结束i:14 *从上面的输出结果可以看出，当Thread0进入睡眠状态之后，Thread1并没有去执行具体的任务，只有当Thread0执行完成后，此时Thread0释放了对象锁，Thread1才开始执行 yield方法 调用yield方法会让当前线程交出CPU权限，让CPU去执行其他线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体交出的CPU时间，另外yield方法只能让拥有相同优先级的线程获取CPU执行时间的机会。 * 调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点和sleep方法不一样的 join方法 123join()join(long millis) //参数为毫秒join(long millis,int nanoseconds) //第一个参数为毫秒，第二个参数为纳秒 假如在main线程中，调用thread.join方法,则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread方法执行完毕，如果调用的是指定时间join方法，则等待一定的时间 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; System.out.println("进入线程"+Thread.currentThread().getName());//执行顺序① Test test = new Test(); MyThread thread1 = test.new MyThread(); thread1.start(); try &#123; System.out.println("线程"+Thread.currentThread().getName()+"等待");//执行顺序② thread1.join(); System.out.println("线程"+Thread.currentThread().getName()+"继续执行");//执行顺序⑤ &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println("进入线程"+Thread.currentThread().getName());//执行顺序③ try &#123; Thread.currentThread().sleep(5000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println("线程"+Thread.currentThread().getName()+"执行完毕");//执行顺序④ &#125; &#125;&#125; 输出结果如下： 12345①进入线程main②线程main等待③进入线程Thread-0④线程Thread-0执行完毕⑤线程main继续执行 可以看出，当调用thread1.join()方法后，main线程会进入等待，然后等待thread1执行完之后再继续执行。 interrupt方法 中断方法，单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就是说，它可以用来中断一个正处在阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("进入睡眠状态"); Thread.currentThread().sleep(10000); System.out.println("睡眠完毕"); &#125; catch (InterruptedException e) &#123; System.out.println("得到中断异常"); &#125; System.out.println("run方法执行完毕"); &#125; &#125;&#125; 输出结果如下： 123进入睡眠状态得到中断异常run方法执行完毕 从上面的结果输出可以看出： 当线程调用interrupt的时候，中断处于阻塞状态的线程。12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; &#125;&#125; 上面的程序会一直执行下去，执行到Int的最大值，说明了一点interrupt方法不能中断正在运行中的线程 但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志置为true，那么可以通过调用isInterrupted()判断中断标志是否被置为中断。1234567891011121314151617181920212223242526272829package com.xydtech.controller.prdman.prdconfig;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(!isInterrupted()&amp;&amp;i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; &#125;&#125; 上面这段代码中，设置thread为interrupt之后，内部while循环的时候查询到不满足条件了，自然退出了循环，但是一般不建议通过这种方式来中断线程，一般会在Thread中添加一个属性isStop来指标是否结束while循环，然后再在while循环中判断isStop的值123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); thread.setStop(true); &#125; catch (InterruptedException e) &#123; &#125; &#125; class MyThread extends Thread&#123; boolean isStop = false; @Override public void run() &#123; int i = 0; while(!isStop &amp;&amp; i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+" while循环"); i++; &#125; &#125; public void setStop(boolean stop) &#123; isStop = stop; &#125; &#125; stop方法destroy方法这两个方法基本上被废弃了，基本上不会被使用到 线程相关属性的方法 getId() 得到线程的IDgetName()和setName() 用来得到或者设置线程的名称getPriority和setPriority 用来获取和设置线程的优先级setDaemon和isDaemon用来设置线程为守护线程和判断线程是否为守护线程。 *重点：守护线程和用户线程的却别是，守护线程依赖于创建它的线程，而用户线程不依赖于创建它的线程，当mian方法运行完毕后，守护线程会随之消亡。但是用户线程不会消失，直至其运行完毕。在JVM中，垃圾收集器线程就是守护线程。Thread类中有一个比较常用的静态类方法currentThread用来获取当前线程。 方法调用和Thread的生命周期关系]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java子线程执行完毕之后，主线程继续执行]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[业务说明：项目中经常会出现将一个庞大的业务拆分成多个小部分，独自在分内运行，但前后任务之间又需要一定的执行顺序，所以就用到了标题中的“主线程执行过程中等待子线程都异步执行完成后才继续执行的问题” 第一个简单的例子123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); &#125; System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程在执行!"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面这段代码输出如下结果，很明显，这个是主线程执行完成之后，子线程又执行的，这个先后顺序不确定，因为有可能若干个子线程执行完后，主线程才执行到执行结束1234567891011主线程已经执行结束了!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行!子线程在执行! 能解决问题的第一个例子12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); try &#123; for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); myThread.join(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程在执行!"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面这段代码是能够实现子线程执行完毕之后，再执行主线程，但是存在一个问题就是子线程是一个一个顺序执行的，也就没有了意义，所以可以看下下面的异步执行的代码1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); long beginTime = System.currentTimeMillis(); Vector&lt;MyThread&gt; myThreadVector = new Vector&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; MyThread myThread = test.new MyThread(); myThread.start(); myThreadVector.add(myThread); &#125; for(MyThread tempMyThread : myThreadVector)&#123; try &#123; tempMyThread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("一共执行了"+(System.currentTimeMillis() - beginTime)+"ms"); System.out.println("主线程已经执行结束了!"); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println("子线程开始执行！"); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 简单解析一下上面的代码：首先上面的代码输出如下：12345678910111213子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！子线程开始执行！Disconnected from the target VM, address: &apos;127.0.0.1:14413&apos;, transport: &apos;socket&apos;一共执行了1027ms主线程已经执行结束了! 首先创建一个Vector，然后通过创建Thread塞入到Vector中，然后再遍历Vector进行join动作，这样就可以不需要考虑子线程中sleep，动态的启动所有的线程]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编码规范]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[版权说明：本文档摘抄自《阿里巴巴Java开发手册（详尽版）》 摘抄不意味着单纯的Copy，而是对别人知识汲取和吸收的同时添加自己的个人理解 Java 编码规则手册 版本号 更新时间 备注 V1.0 2018-11-22 初始化版本 一、编程规约（一）命名风格 【强制】代码中的命名不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例：_name/__name/$name/name_/name$/name__ 【强制】代码中命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式 说明：正确的英文拼写和语法可以让阅读者易于理解，便面歧义 反例：DaZhePromotion()[打折]/getPingFenByName()[获取评分]/int 某变量=3 【强制】类名使用UpperCameCase风格，但以下情况例外DO/BO/DTO/VO/AO/PO/UID等 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCameCase风格，必须遵从驼峰形式。 正例：localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，尽量将语义表达清楚，不要害怕变量长度太长。 正例：MAX_STOCK_COUNT 反例：MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾 【强制】类型与中括号紧挨相连来表示数组 正例：定义整形数组 int[] arrayDemo 反例：在 main 参数中，使用 String args[]来定义 【强制】POJO 类中布尔类型的变量，都不要加 is前缀，否则部分框架解析会引起序列化错误 反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式 正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils 【强制】杜绝完全不规范的缩写，避免望文不知义 反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【强制】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意 正例：在JDK中，表达原子更新的类名为：AtomicReferenceFieldUpdater 反例：变量 int a 的随意命名方式 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念 正例：public class OrderFactory;,public class LoginProxy;,public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量 正例：接口方法签名void commit();接口基础常量 String COMPANY = &quot;alibaba&quot;; 反例：接口方法定义 public abstract void f(); 说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现 接口和实现类的命名有两套规则 1）【强制】对于 Service和DAO类，基于 SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别 正例：CacheServiceImpl 实现 CacheService接口 2）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形式） 正例：AbstractTranslator 实现 Translatable接口 【参考】枚举类名建议带上 Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开 说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有 正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON 【参考】 Service/DAO层方法命名规则 获取单个对象的方法用 get做前缀 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects 获取统计值的方法用 count 做前缀 插入的方法用 save/insert做前缀 删除的方法用 remove/delete 做前缀 修改的方法用 update做前缀 领域模型命名规约 数据对象：xxxDO，xxx 即为数据表名 数据传输对象：xxxDTO，xxx为业务领域相关的名称 展示对象：xxxVO，xxx一般为网页名称 POJO是 DO/DTO/BO/VO的统称，禁止命名成 xxxPOJO （二）常量定义 【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中反例： 1234//Magic values, except for predefined, are forbidden in coding.if (key.equals("Id#taobao_1")) &#123; //...&#125; 正例： 1234String KEY_PRE = "Id#taobao_1"; if (KEY_PRE.equals(key)) &#123; //...&#125; 【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护 说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护 正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下 反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量 ​ 类 A 中：public static final String YES = &quot;yes&quot;; ​ 类 B 中：public static final String YES = &quot;y&quot;; ​ A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题 子工程内部共享常量：即在当前子工程的 constant 目录下 包内共享常量：即在当前包下单独的constant目录下 类内共享常量：直接在类内部 private static final 定义 【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义（扩展enmu的使用方法）说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节正例： 12345678public enum SeasonEnum &#123; SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4); private int seq; SeasonEnum(int seq) &#123; this.seq = seq; &#125;&#125; （三）代码格式 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则 左大括号前不换行 左大括号后换行 右大括号前换行 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行 【强制】左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。详见第 5 条下方正例提示 反例：if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格 【强制】任何二目、三目运算符的左右两边都需要加一个空格 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等 【强制】采用 4 个空格缩进，禁止使用 tab 字符说明：如果使用tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character（扩展IDEA设置按TAB时输入四个空格的方法）；而在 eclipse 中，必须勾选 insert spaces for tabs正例： 12345678910111213141516171819public static void main(String[] args) &#123; // 缩进 4 个空格 String say = "hello"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println("world"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println("ok"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 【强制】注释的双斜线与注释内容之间有且仅有一个空格正例： 12// 这是示例注释，请注意在双斜线之后有一个空格String ygb = new String(); 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则- 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例- 运算符与下文一起换行- 方法调用的点符号与下文一起换行- 方法调用中的多个参数需要换行时，在逗号后进行- 在括号前不要换行，见反例正例： 123456StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append("zi").append("xin") .append("huang") .append("huang") .append("huang"); 反例： 1234567StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，不要在括号前换行sb.append("zi").append("xin")...append("huang");// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行method(args1, args2, args3, ..., argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格 正例：下例中实参的args1，后边必须要有一个空格 method(args1, args2, args3); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows格式 【推荐】单个方法的总行数不超过 80 行 说明：包括方法签名、结束右大括号、方法内代码、注释、空行、回车及任何不可见字符的总行数不超过 80 行 正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐正例： 1234int one = 1;long two = 2L;float three = 3F;StringBuffer sb = new StringBuffer(); 说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情 【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性 说明：任何情形，没有必要插入多个空行进行隔开 （四）OOP规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可 【强制】所有的覆写方法，必须加@Override 注解 说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）正例： 1public List&lt;User&gt; listUsers(String type, Long... ids) &#123;...&#125; 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么正例： 1234@Deprecatedpublic static String toJson(Object obj) &#123; return toJson(getAttributes(obj));&#125; 【强制】不能使用过时的类或方法 说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么 【强制】Object 的 equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 正例：&quot;test&quot;.equals(object); 反例：object.equals(&quot;test&quot;) 说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断 关于基本数据类型与包装数据类型的使用标准如下 【强制】所有的 POJO 类属性必须使用包装数据类型 【强制】RPC 方法的返回值和参数必须使用包装数据类型 【推荐】所有的局部变量使用基本数据类型 说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE(空指针异常)问题，或者入库检查，都由使用者来保证 正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险 反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出 【强制】定义 DO/DTO/VO 等 POJO类时，不要设定任何属性默认值 反例：POJO 类的 gmtCreate 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值 说明：注意 serialVersionUID 不一致会抛出序列化运行时异常 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中 【强制】POJO 类必须写toString 方法。使用 IDE 中的工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString 说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题 【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和getXxx()方法 说明：框架在调用属性 xxx的提取方法时，并不能确定哪个方法一定是被优先调用到 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险说明： 1234String str = "a,b,c,,";String[] ary = str.split(",");// 预期大于 3，结果是 3System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 16 条规则 【推荐】类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度反例： 1234567public Integer getData() &#123; if (condition) &#123; return this.data + 100; &#125; else &#123; return this.data - 100; &#125;&#125; 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费(扩展Java中的String，StringBuilder，StringBuffer三者的区别)反例： 1234String str = "start";for (int i = 0; i &lt; 100; i++) &#123; str = str + "hello";&#125; 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字 不允许被继承的类，如：String 类 不允许修改引用的域对象 不允许被重写的方法，如：POJO 类的 setter 方法 不允许运行过程中重新赋值的局部变量 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构 【推荐】慎用 Object 的 clone方法来拷贝对象 说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现域对象的深度遍历式拷贝 【推荐】类成员与方法访问控制从严 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private 工具类不允许有 public 或 default 构造方法 类非 static 成员变量并且与子类共享，必须是 protected 类非 static成员变量并且仅在本类使用，必须是 private 类 static 成员变量如果仅在本类使用，必须是 private 若是 static成员变量，考虑是否为 final 类成员方法只供类内部调用，必须是 private 类成员方法只对继承类公开，那么限制为 protected 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的 （五）集合处理 【强制】关于 hashCode 和 equals的处理，遵循如下规则 只要重写 equals，就必须重写 hashCode 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals 说明：String重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用 【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList 说明：subList 返回的是ArrayList 的内部类SubList，并不是 ArrayList 而是ArrayList的一个视图，对于 SubList子列表的所有操作最终会反映到原列表上 【强制】在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()说明：使用toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致正例： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add("guan");list.add("bao");String[] array = new String[list.size()];array = list.toArray(array); 反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常 说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组 12String[] str = new String[] &#123; "you", "wu" &#125;;List list = Arrays.asList(str) 第一种情况：list.add(&quot;yangguanbao&quot;); 运行时异常 第二种情况：str[0] = &quot;gujin&quot;; 那么 list.get(0)也会随之修改 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而&lt;? super T&gt;不能使用 get 方法，作为接口调用赋值时易出错 说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt; 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁正例： 12345678910List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("1");list.add("2");Iterator&lt;String&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); if (删除元素的条件) &#123; iterator.remove(); &#125;&#125; 反例： 12345for (String item : list) &#123; if ("1".equals(item)) &#123; list.remove(item); &#125;&#125; 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗 【强制】在 JDK7 版本及以上，Comparator（扩展Java] 用 Comparator 实现排序） 实现类要满足如下三个条件，不然Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常 说明：三个条件如下 x，y 的比较结果和 y，x 的比较结果相反 x&gt;y，y&gt;z，则 x&gt;z x=y，则 x，z 比较结果和 y，z 比较结果相同 反例：下例中没有处理相等的情况，实际使用中可能会出现异常 123456new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125;; 【推荐】集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略说明：菱形泛型，即 diamond，直接使用&lt;&gt;来指代前边已经指定的类型正例： 1234// &lt;&gt; diamond 方式HashMap&lt;String, String&gt; userCache = new HashMap&lt;&gt;(16);// 全省略方式ArrayList&lt;User&gt; users = new ArrayList(10); 【推荐】集合初始化时，指定集合初始值大小 说明：HashMap使用 HashMap(int initialCapacity)初始化 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法 正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合 【推荐】高度注意 Map 类集合K/V能不能存储null 值的情况，如下表格 | 集合类 | Key | Value | Super | 说明 || —————– | ————————————– | ————————————– | ———– | ———————- || Hashtable | 不允许为 null | 不允许为 null | Dictionary | 线程安全 || ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 锁分段技术（JDK8:CAS） || TreeMap | 不允许为 null | 允许为 null | AbstractMap | 线程不安全 || HashMap | 允许为 null | 允许为 null | AbstractMap | 线程不安全 | 反例：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常 【推荐】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响 说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是order/sort 【推荐】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List的contains 方法进行遍历、对比、去重操作 （六）并发处理 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全 说明：资源驱动类、工具类、单例工厂类都需要注意 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯正例： 123456public class TimerTaskThread extends Thread &#123; public TimerTaskThread() &#123; super.setName("TimerTaskThread"); ... &#125;&#125; 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程（扩展Java并发编程：线程池的使用） 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 说明：Executors返回的线程池对象的弊端如下 FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类 正例：注意线程安全，使用 DateUtils。亦推荐如下处理： 123456private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat("yyyy-MM-dd"); &#125;&#125;; 说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次 【强制】多线程并行处理定时任务时，Timer运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService则没有这个问题 【强制】禁止在循环中调用synchronized（同步）方法说明：方法的同步需要消耗相当大的资源，不要在循环中调用同步方法反例： 1234567891011import java.util.Vector;public class SYN &#123; public synchronized void method (Object o) &#123; &#125; private void test () &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; method (vector.elementAt(i)); // violation &#125; &#125; private Vector vector = new Vector (5, 5);&#125; 正例： 12345678910111213import java.util.Vector;public class SYN &#123; public void method (Object o) &#123; &#125;private void test () &#123;synchronized&#123;//在一个同步块中执行非同步方法 for (int i = 0; i &lt; vector.size(); i++) &#123; method (vector.elementAt(i)); &#125; &#125; &#125; private Vector vector = new Vector (5, 5);&#125; 【强制】禁止在循环中使用表达式说明：在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快反例： 1234567import java.util.Vector;class CEL &#123; void method (Vector vector) &#123; for (int i = 0; i &lt; vector.size (); i++) // Violation ; // ... &#125;&#125; 正例： 1234567class CEL_fixed &#123; void method (Vector vector) &#123; int size = vector.size () for (int i = 0; i &lt; size; i++) ; // ... &#125;&#125; 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果 说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降（扩展多线程下生成随机数） 说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式 正例：在 JDK7 之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型反例： 1234567891011class LazyInitDemo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125;// other methods and fields...&#125; （七）控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件 说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替 反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止 【强制】在 if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成 12345 if (condition) &#123; ... return obj; &#125;// 接着写 else 的业务逻辑代码; 说明：如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层 正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下 123456789101112public void today() &#123; if (isBusy()) &#123; System.out.println(“change time.”); return; &#125; if (isFree()) &#123; System.out.println(“go to travel.”); return; &#125; System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return;&#125; 【推荐】除常用方法（如getXxx/isXxx等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢正例： 12345// 伪代码如下final boolean existed = (file.open(fileName, "w") != null) &amp;&amp; (...) || (...);if (existed) &#123; ...&#125; 反例： 123if ((file.open(fileName, "w") != null) &amp;&amp; (...) || (...)) &#123; ...&#125; 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外） 【推荐】避免采用取反逻辑运算符 说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法 正例：使用if (x &lt; 628)来表达 x 小于 628 反例：使用 if (!(x &gt;= 628)) 来表达 x 小于 628 【推荐】接口入参保护，这种场景常见的是用作批量操作的接口 【推荐】下列情形，需要进行参数校验： 调用频次低的方法 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失 需要极高稳定性和可用性的方法 对外提供的开放接口，不管是 RPC/API/HTTP 接口 敏感权限入口 【推荐】下列情形，不需要进行参数校验 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO的参数校验，可以省略 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数 （八）注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容\/格式，不得使用// xxx 方式 说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：对子类的实现要求，或者调用注意事项，请一并说明 【强制】所有的类都必须添加创建者和创建日期 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可 反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义 【推荐】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除 说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码） 【推荐】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 【推荐】核心代码注释量不得低于文件总行数的30%，非核心代码注释量不得低于文件总行数的20% （九）其他 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”) 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法 说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime() 说明：如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类 【强制】删除未引用类，避免使用以”.*”结尾的引用，引用的顺序如下： JDK标准包（例如：import java.io.IOException等） 第三方的包（例如：import org.dom4j.Node等） 项目的公共包 【强制】禁止在循环体中生命并实例化变量说明：在循环体中声明并实例化临时变量将会增加内存消耗，增加垃圾回收的次数；尤其是大对象，严格禁止在循环体内声明并实例化对象反例： 123456789import java.util.Vector;public class LOOP &#123; void method (Vector v) &#123; for (int i=0;i &lt; v.size();i++) &#123; Object o = new Object(); // 不建议 o = v.elementAt(i); &#125; &#125;&#125; 正例： 123456789import java.util.Vector;public class LOOP &#123; void method (Vector v) &#123; Object o; for (int i=0;i&lt;v.size();i++) &#123; o = v.elementAt(i); &#125; &#125;&#125; 【推荐】不要在视图模板中加入任何复杂的逻辑 说明：根据 MVC理论，视图的职责是展示，不要抢模型和控制器的活 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存 【推荐】及时清理不再使用的代码段或配置信息 说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余 正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由 二、异常日志（一）异常处理 【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过 catch NumberFormatException 来实现 正例：if (obj != null) {...} 反例：try { obj.method(); } catch (NullPointerException e) {…} 【强制】异常不要用来做流程控制，条件控制 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多 【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理 说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch 说明：如果 JDK7 及以上，可以使用 try-with-resources 方式（扩展Java进阶知识点3：更优雅地关闭资源 - try-with-resource及其异常抑制） 【强制】不要在 finally 块中使用 return 说明：finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值 说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null 的情况 【强制】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE 数据库的查询结果可能为 null 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null 远程调用返回对象时，一律要求进行空指针判断，防止 NPE 对于 Session 中获取的数据，建议 NPE 检查，避免空指针 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE 正例：使用JDK8 的 Optional 类来防止 NPE 问题。（扩展Java8 如何正确使用 Optional） 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等 【推荐】对于公司外的 http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息” 说明：关于 RPC 方法返回方式使用 Result 方式的理由 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题 【推荐】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化 正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {...} （二）日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式 appName_logType_logName.log logType:日志类型，如 stats/monitor/access 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找 正例：mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式 说明：logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印 正例：（条件）建设采用如下方式 123if (logger.isDebugEnabled()) &#123; logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);&#125; 正例：（占位符） 1logger.debug("Processing trade with id: &#123;&#125; and symbol : &#123;&#125; ", id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml中设置 additivity=false。 正例：&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出 正例：logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e); 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从 三、安全规约 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库 【强制】用户请求传入的任何参数必须做有效性验证 说明：忽略参数校验可能导致 page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS 说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据 【强制】表单、AJAX 提交必须执行 CSRF 安全验证 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 四、MySQL数据库（一）建表规约 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否） 说明：任何字段如果是非负数，必须是unsigned 注意：POJO类中任何布尔类型的变量，都不要加is前缀，所以，需要在设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取之含义与取值范围 正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL在Windows下不区分大小写，单在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdConfig，level_3_name 【强制】表名不适用复数名词 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 【强制】禁用保留字，如desc、range、match、delayed等，请参照MySQL官方保留字 【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名为idx_字段名。 说明：pk_即primary key；uk_即unique key;idx_即index的简称。 【强制】小数类型为decimal，禁止使用float和double 说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成证书和小数部分分开存储。 【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出一张表，用主键来对应，避免影响其他字段索引效率。 【强制】表必备三个字段：id，gmt_create，gmt_modified 说明：其中id必为主键，类型为bigint unsigned、表单时自增，步长为1。gmt_create，gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新 【推荐】表的命名最好是“业务名称_表的作用” 正例：alipay_task/force_project/trade_config 【推荐】库名尽量与应用名保持一致 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 不是频繁修改的字段 不是varchar超长字段，更不能是text字段 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间，节约索引存储，更重要的是提升检索速度 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围 | 对象 | 年龄区间 | 类型 | 字节 | 表示范围 || ——– | ——— | ——————- | —- | ——————– || 人 | 150岁之内 | tinyint unsigned | 1 | 无符号：0~255 || 龟 | 数百岁 | smallint unsigned | 2 | 无符号：0~65535 || 恐龙化石 | 数千万年 | int unsigned | 4 | 无符号：0~约42.9亿 || 太阳 | 约50亿年 | bigint unsigned | 8 | 无符号：0~10的19次方 | （二）索引规约 【强制】业务上具有唯一特性的字段，及时是多个字段的组合，也必须建成唯一索引 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高了查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生 【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双标join也要注意表索引和SQL性能 【强制】在varchar字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会打到90%以上，可以使用count(distinct left(列名，索引长度))/count(*)的区分度来确定. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引：a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b;索引a_b无法排序 【推荐】利用覆盖索引来进行查询操作，避免全表。 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的中类分别为朱建索引、唯一索引、普通索引三种，而覆盖索引知识一种查询的一种效果，用explain的结果，extra列会出现using index 【推荐】利用延迟关联或者子查询优化超多分页场景 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的地下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联 1SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】防止因字段类型不同造成隐式转换，导致索引失效 【参考】创建索引避免有如下极端误解 宁滥勿缺：任务一个查询就需要建一个索引 宁缺毋滥：认为索引会小号控件、严重拖慢更新和新增速度 地址唯一索引：任务业务的唯一性一律需要在应用层通过“先查后插”方式解决 （三）SQL语句 【强制】不要使用count(列名)或者count(常量)来代替count(\*),count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL或非NULL无关。 说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 【强制】count(distinct col)计算该列除NULL之外的不重复行数，注意count(distinct col1,col2)如果其中一列全为NULL，那么及时另一列有不同的值，也返回0 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但是sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题 正例：可以使用如下方式来避免sum的NPE问题： 1SELECT IF(ISNULL(SUM(g)),0,SUM(g))FROM table; 【强制】使用ISNULL()来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL NULL&lt;&gt;NULL的返回结果是NULL，而不是false NULL=NULL的结果返回值是NULL，而不是true NULL&lt;&gt;1的返回结果是NULL，而不是true 【强制】在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句 【强制】不得使用外检或级联，一切外键概念必须在应用层解决 说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误后才能执行更新语句 【推荐】in操作能避免则避免，是在避免不了，需要仔细评估in后边集合元素数量，控制在1000个内。 【参考】注意字符串统计函数的区别说明： SELECT LENGTH(“轻松工作”);返回12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4 如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码区别 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同 （四）ORM映射 【强制】在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明说明： 增加查询分析器解析成本 增减字段容易与resultMap配置不一致 无用字段增加网络小号，尤其是text类型字段 【强制】不要用resultClass当返回参数，及时所有的类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必须有一个POJO类与之对应 说明：配置映射关系，是字段与DO类解耦，方便维护 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL 注入 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控 【强制】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等 五、Oracle数据库（一）对象命名规范 【强制】数据库名称定义为系统名+模块名说明： 全局数据库名和SID名要求一致 因SID名只能包含字符和数字，所以全局数据库和SID名中不能含有“_”等字符 【强制】表空间命名规范 面向用户的专用数据表空间以用户名+_+data命名 ，如Aud 用户专用数据表空间可命名为Aud_data 面向用户的专用索引表空间以用户名+_+idx命名 面向用户的专用临时表空间以用户名+_+tmp命名 面向用户的专用回滚段表空间以用户名+_+rbs命名 面向应用的表空间以应用名+_data/应用名+_idx/应用名+_tmp/应用名+_rbs 命名 LOB 段数据专用表空间以其数据表空间+_+lobs 命名，如上例中数据表空间为Aud_data，则LOB 段表空间可命名为Aud_data_lobs 表空间文件命名以表空间名+两位数序号(序号从01开始)组成，如Aud_data01 等 【强制】表名的命名规范- 一般表采用系统名+t_+模块名+_+表义名 格式构成- 若数据库中只含有单个模块，命名可采用系统名+t_+表义名格式构成- 模块名或表义名均以其汉语拼音的首字符命名，表义名中汉语拼音均采用小写，且字符间不加分割符- 表别名命名规则：取表义名的前3 个字符加最后一个字符。如果存在冲突，适当增加字符（如取表义名的前4 个字符加最后一个字符等）- 临时表采用系统名+t_tmp_+表义名 格式构成 正例： 123dft_gy_cbap：系统名（电费 df）+t_+模块名（高压 gy）+_+表义名（抄表安排 cbap）dft_cbbj: 系统名（电费 df）+t_+表义名（抄表标记 cbbj）dft_tmp_hj: 系统名（电费 df）+tmp+表义名（合计hj）(此处为临时表) 【强制】属性（列或字段）命名规则 采用有意义的列名，为实际含义的汉语拼音的首字符，且字符间不加任何分割符 属性名前不要加表名等作为前缀 属性后不加任何类型标识作为后缀 不要使用“ID”作为列名 关联字段命名以 cd+_+关联表的表义名（或缩写）+_+字段名进行 【强制】主键命名规则 任何表都必须定义主键 表主键命名为：pk+_+表名(或缩写)+_+主键标识如pk_YHXX_IDKH等 【强制】外键命名规则 表外键命名为： fk+_+表名(或缩写)+_主表名(或缩写)+_+主键标识如fk_YHLX_YHXX_SFZH等 【强制】CHECK约束命名规则 CHECK 约束命名为： chk+_+CHECK约束的列名（或缩写） 【强制】UNIQUE约束命名规则 UNIQUE 约束命名为： unq+_+UNIQUE约束的列名（或缩写） 【强制】索引命名规则 索引的命名为：表名（或缩写）+_+列名+_idx，其中多单词组成的属性列列名取前几个单词首字符再加末单词首字符组成如yd_kh 表khid上的index: yd_kh_khid_idx 【强制】视图命名规则 视图命名以系统名v_+模块名作为前缀，其他命名规则和表的命名类似 （二）SQL编写规范 【强制】表面使用数据库类型的自动转换功能反例： 1SELECT * FROM category WHERE id = '123'; -- id如果是数字类型的，在这就需要内置转换，所以尽量保持数据类型一致 【参考】SELECT语句编写规范 关键字大写，列表名表名小写 由SELECT 开头，后跟一个显示查询结果的列表 由FROM 开头，后跟一个或多个获取数据所涉及的表 由WHERE 开头，后跟一个或多个确定所需值的条件 由GROUP BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行汇总 由ORDER BY开头，后跟一个或多个表列名，通过这些列以对查询结果进行排序 【参考】尽量避免在循环中使用SQL语句 【参考】避免在WHERE子句中对列施以函数；正例： 123456SELECT *FROM service_promotionWHERE gmt_modified&gt;= TO_DATE('2001-9-01','yyyy-mm-dd')AND gmt_modified&lt; TO_DATE('2001-9-02','yyyy-mm-dd'); 反例： 1234SELECT *FROM service_promotionWHERE TO_CHAR(gmt_modified,’yyyy-mm-dd’)= '20001-09-01'; （三）类型选择 【强制】不同的数据类型选择不同的数据存储类型，不要什么都用varchar2 用char(1)代表布尔值 应尽量使用varchar2代替char类型 varchar2最多4000字符 date精确到微秒，而非天 使用clob代替long,blob代替long raw oracle只有number一种数据类型，使用时请给定长度 附件：专有名词解释 POJO（Plain Ordinary Java Object）：在本手册中，POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等 OOP（Object Oriented Programming）：本手册泛指类、对象的变成处理方式 ORM（Object Relation Mapping）：对象关系映射，对象领域模型与底层数据之间的转换，本文繁殖iBATIS，mybatis等框架 NPE（java.lang.NullPointterException）：空指针异常 IDE（Integrated Development Environment）：用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本手册泛指IDEA和Eclipse OOM（Out of Memory）：源于java.lang.OutOfMemoryError，当JVM没有足够的内存来为对象分配空间并且垃圾回收无法回收空间时，系统出现的严重状况]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户登录对账号和密码加解密]]></title>
    <url>%2F2019%2F01%2F23%2F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%AF%B9%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[背景说明闲的无聊，F12看了下项目上的登录，一看账号和密码都是明文发送的，因此找了下网络上的一些文章，对项目进行了优化 背景目前的项目登录的时候都是明文的传递账号和密码，具体如下图所示 解决方案准备资源 jar包(使用Maven引入jar包，如果不是Maven项目可以去Maven仓库将jar下载下来，然后导入项目中) 12345&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt; &lt;version&gt;1.46&lt;/version&gt;&lt;/dependency&gt; 加密js文件在Github上找到这个项目https://github.com/travist/jsencrypt的bin目录下下载jsencrypt.min.js进行 具体步骤 （后台）创建一个RSA工具类(RSAUtil.java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import java.security.*;import java.security.interfaces.RSAPublicKey;/** * @ClassName RASUtil * @Description TODO * @Date 2018/12/109:52 * @Version 1.0 **/public class RSAUtil&#123; //KeyPair is a simple holder for a key pair. private static final KeyPair keyPair = initKey(); /** * 初始化方法，产生key pair，提供provider和random * @return KeyPair instance */ private static KeyPair initKey() &#123; try &#123; //添加provider Provider provider = new org.bouncycastle.jce.provider.BouncyCastleProvider(); Security.addProvider(provider); //产生用于安全加密的随机数 SecureRandom random = new SecureRandom(); KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA", provider); generator.initialize(1024, random); return generator.generateKeyPair(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 产生public key * @return public key字符串 */ public static String generateBase64PublicKey() &#123; PublicKey publicKey = (RSAPublicKey)keyPair.getPublic(); //encodeBase64(): Encodes binary data using the base64 //algorithm but does not chunk the output. //getEncoded():返回key的原始编码形式 return new String(Base64.encodeBase64(publicKey.getEncoded())); &#125; /** * 解密数据 * @param string 需要解密的字符串 * @return 破解之后的字符串 */ public static String decryptBase64(String string) &#123; //decodeBase64():将Base64数据解码为"八位字节”数据 return new String(decrypt(Base64.decodeBase64(string.getBytes()))); &#125; private static byte[] decrypt(byte[] byteArray) &#123; try &#123; Provider provider = new org.bouncycastle.jce.provider.BouncyCastleProvider(); Security.addProvider(provider); //Cipher: 提供加密和解密功能的实例 //transformation: "algorithm/mode/padding" Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", provider); PrivateKey privateKey = keyPair.getPrivate(); //初始化 cipher.init(Cipher.DECRYPT_MODE, privateKey); //doFinal(): 加密或者解密数据 byte[] plainText = cipher.doFinal(byteArray); return plainText; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; （后台）编写一个生成公钥的接口 12345678910111213141516171819202122/** *@Description 生成公钥 *@param *@return java.lang.String *@date 2018/12/10 9:48 **/@RequestMapping("/genPubKey")@ResponseBodypublic String genPubKey()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("code",-1); String publicKey = ""; try &#123; publicKey = RSAUtil.generateBase64PublicKey(); map.put("pubkey",publicKey); map.put("code",1); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put("msg",e.getMessage()); &#125; return publicKey;&#125; （前台）登录界面引入jsencrypt.min.js，初始化登录页的同时初始化公钥 123456789101112131415161718192021//页面初始化，调取公钥var publicKey = &apos;&apos;;$(function()&#123; getPublicKey();&#125;)//调取后台生成公钥接口function getPublicKey()&#123; $.ajax(&#123; url: &quot;user/genPubKey&quot;, type: &quot;post&quot;, dataType: &quot;text&quot;, data:&#123;&#125;, success: function(data) &#123; if(data) publicKey = data; if(publicKey==null)&#123; alert(获取publicKey失败，请联系管理员！); &#125; &#125; &#125;);&#125; （前台）点击登录时，使用公钥生成私钥，加密账号和密码 1234567891011var uname = $.trim($(&quot;#userName&quot;).val());var upwd = $.trim($(&quot;#passWord&quot;).val());var encrypt = new JSEncrypt();if(publicKey)&#123;encrypt.setPublicKey(publicKey);//设置公钥到前端生成私钥uname = encrypt.encrypt(uname);//加密用户名upwd = encrypt.encrypt(upwd);//加密密码//通过ajax发送加密的账号和密码到后台.....&#125; （后台）后台账号和密码解密 12String loginID = RSAUtil.decryptBase64(username);String pwd = RSAUtil.decryptBase64(passwd); 总结前台页面加载时调用生成公钥方法生成公钥，然后用户点击登录时，获取用户名和密码，根据之前生成的公钥，进行私钥加密，传入后台的数据就是已经加密过的数据，然后我们在后台进行解密，得到用户输入的原始密码和账户]]></content>
      <categories>
        <category>后端开发语言</category>
        <category>Java</category>
        <category>功能相关</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>登录</tag>
        <tag>加解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 操作页面打印操作（不使用插件）]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[页面打印​ 打印之前没怎么接触过，最近项目有需求在系统中实现打印合同的功能，系统中的合同是用Bootstrap实现的html页面，因此就查阅资料，发现window.print方法可以在不使用外部打印插件的前提下，可以进行页面的打印操作，这种既简单又好操作，但是存在一个缺点是：页面内容的替换 实现原理实现原理很简单：是通过页面替换到window.document.body中的内容，然后就可以用window.print就可以打印window.document.body中的内容 实现代码123456789101112131415&lt;body&gt;...&lt;div id="print-content" class="container" style="clear: both;width: 210mm;height: 297mm"&gt; ....&lt;/div&gt;....&lt;script&gt; var bdhtml = window.document.body.innerHTML;//获取当前页的html代码 //获取需要打印的html代码 window.document.body.innerHTML = $("#print-content")[0].innerHTML; window.print(); window.document.body.innerHTML = bdhtml;//还原页面内容&lt;/script&gt;&lt;/body&gt; 效果Chrome Firfox和IE这两个浏览器是没有打印预览的，是直接弹出打印页面的 扩展Chrome打印的时候会出现页眉和页脚中有地址的问题，可以直接点击上图中左侧的页眉页脚中取消勾选]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 遍历JSON]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E9%81%8D%E5%8E%86JSON%2F</url>
    <content type="text"><![CDATA[背景说明：常规下一般是用不到Json对象的遍历的，但是如果要做一些公共方法的时候，有可能会用到，比如说后端扔给你一个json串，需要你把数据反显到页面上，这种就需要进行处理了，遍历扔给你json串，然后获取和页面上匹配的内容，进行赋值操作，当然这个过程中还得需要判断控件的类型，毕竟存在一些特殊类型的控件，比如说文件上传和回显、复选框、单选框等等特殊控件 遍历有规律的JSON对象12345678910111213packJson = [&#123;"name":"nikita", "password":"1111"&#125;,&#123;"name":"tony", "password":"2222"&#125;];for(var p in packJson)&#123;//遍历json数组时，这么写p为索引，0,1 alert(packJson[p].name + " " + packJson[p].password);&#125; 遍历无规律的JSON对象123456789101112&lt;script&gt;var json = [ &#123;dd:'SB',AA:'东东',re1:123&#125;, &#123;cccc:'dd',lk:'1qw'&#125;];for(var i=0,l=json.length;i&lt;l;i++)&#123; for(var key in json[i])&#123; alert(key+':'+json[i][key]); &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>Javascript实例</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 基础知识]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[js字符串转int(parseInt)1alert(parseInt(childNode)+1); js删除Object对象中的属性1delete obj.attr]]></content>
      <categories>
        <category>前端开发语言</category>
        <category>Javascript</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
